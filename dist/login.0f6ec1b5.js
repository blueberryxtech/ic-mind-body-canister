// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"wtkGg":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "d953f9080f6ec1b5";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"1xC6H":[function(require,module,exports) {
var Refresh = require("6d18d6bd340e7473");
var ErrorOverlay = require("74ad5ea14201648c");
Refresh.injectIntoGlobalHook(window);
window.$RefreshReg$ = function() {};
window.$RefreshSig$ = function() {
    return function(type) {
        return type;
    };
};
ErrorOverlay.setEditorHandler(function editorHandler(errorLocation) {
    let file = `${errorLocation.fileName}:${errorLocation.lineNumber || 1}:${errorLocation.colNumber || 1}`;
    fetch(`/__parcel_launch_editor?file=${encodeURIComponent(file)}`);
});
ErrorOverlay.startReportingRuntimeErrors({
    onError: function() {}
});
window.addEventListener("parcelhmraccept", ()=>{
    ErrorOverlay.dismissRuntimeErrors();
});

},{"6d18d6bd340e7473":"786KC","74ad5ea14201648c":"1dldy"}],"eraRr":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$416b = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$416b.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>LoginPage);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _reactHelmetAsync = require("react-helmet-async");
var _login = require("../sections/login");
function LoginPage() {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _jsxDevRuntime.Fragment), {
        children: [
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _reactHelmetAsync.Helmet), {
                children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("title", {
                    children: "Login"
                }, void 0, false, {
                    fileName: "src/mind_body_assets/src/pages/login.jsx",
                    lineNumber: 11,
                    columnNumber: 9
                }, this)
            }, void 0, false, {
                fileName: "src/mind_body_assets/src/pages/login.jsx",
                lineNumber: 10,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _login.LoginView), {}, void 0, false, {
                fileName: "src/mind_body_assets/src/pages/login.jsx",
                lineNumber: 14,
                columnNumber: 7
            }, this)
        ]
    }, void 0, true);
}
_c = LoginPage;
var _c;
$RefreshReg$(_c, "LoginPage");

  $parcel$ReactRefreshHelpers$416b.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react-helmet-async":"hTtyd","../sections/login":"eiYZr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"eiYZr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LoginView", ()=>(0, _loginViewDefault.default));
var _loginView = require("./login-view");
var _loginViewDefault = parcelHelpers.interopDefault(_loginView);

},{"./login-view":"44qe5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44qe5":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$3e86 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$3e86.prelude(module);

try {
//process
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>LoginView);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _authClient = require("@dfinity/auth-client");
var _agent = require("@dfinity/agent");
var _mindBody = require("../../../../declarations/mind_body");
var _0Xsequence = require("0xsequence");
var _socketIoClient = require("socket.io-client");
var _socketIoClientDefault = parcelHelpers.interopDefault(_socketIoClient);
//UI
var _box = require("@mui/material/Box");
var _boxDefault = parcelHelpers.interopDefault(_box);
var _link = require("@mui/material/Link");
var _linkDefault = parcelHelpers.interopDefault(_link);
var _card = require("@mui/material/Card");
var _cardDefault = parcelHelpers.interopDefault(_card);
var _stack = require("@mui/material/Stack");
var _stackDefault = parcelHelpers.interopDefault(_stack);
var _button = require("@mui/material/Button");
var _buttonDefault = parcelHelpers.interopDefault(_button);
var _typography = require("@mui/material/Typography");
var _typographyDefault = parcelHelpers.interopDefault(_typography);
var _unstableGrid2 = require("@mui/material/Unstable_Grid2");
var _unstableGrid2Default = parcelHelpers.interopDefault(_unstableGrid2);
var _styles = require("@mui/material/styles");
var _css = require("../../theme/css");
var _logo = require("../../components/logo");
var _logoDefault = parcelHelpers.interopDefault(_logo);
var _appWidgetSummary = require("../../modules/app-widget-summary");
var _appWidgetSummaryDefault = parcelHelpers.interopDefault(_appWidgetSummary);
var _s = $RefreshSig$();
function LoginView() {
    _s();
    const theme = (0, _styles.useTheme)();
    const [icpId, setIcpId] = _react.useState("");
    //web3 wallet
    const [proof, setProof] = _react.useState("");
    const [web3Address, setWeb3Address] = _react.useState("");
    const [socket, setSocket] = _react.useState(null);
    (0, _0Xsequence.sequence).initWallet({
        defaultNetwork: "mainnet"
    });
    const loginAction = async ()=>{
        // create an auth client
        let authClient = await (0, _authClient.AuthClient).create();
        // start the login process and wait for it to finish
        await new Promise((resolve)=>{
            authClient.login({
                identityProvider: undefined,
                onSuccess: resolve
            });
        });
        // At this point you're authenticated, and you can get the identity from the auth client:
        const identity = authClient.getIdentity();
        // Using the identity obtained from the auth client, you can create an agent to interact with the IC.
        const agent = new (0, _agent.HttpAgent)({
            identity
        });
        // Using the interface description of our webapp, you create an actor that you use to call the service methods.
        actor = (0, _mindBody.createActor)("pvznn-pyaaa-aaaan-qlljq-cai", {
            agent
        });
        loadICPid();
        return false;
    };
    const loadICPid = async ()=>{
        // get ICP-ID
        const icpIdValue = await (0, _mindBody.mind_body).getIcpId();
        window.$icpId = icpIdValue;
        setIcpId(icpIdValue);
    };
    const loginWeb3 = async ()=>{
        const wallet = (0, _0Xsequence.sequence).getWallet();
        const details = await wallet.connect({
            app: "blueberry",
            authorize: true
        });
        if (details.connected) {
            window.$web3AddressId = details.session?.accountAddress;
            console.log(details.session?.accountAddress);
            setProof(details.proof?.proofString);
            setWeb3Address(details.session?.accountAddress);
        }
    };
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _boxDefault.default), {
        sx: {
            ...(0, _css.bgGradient)({
                color: (0, _styles.alpha)(theme.palette.background.default, 0.9),
                imgUrl: "/assets/background/overlay_4.jpg"
            }),
            height: 1
        },
        children: [
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _logoDefault.default), {
                sx: {
                    position: "fixed",
                    top: {
                        xs: 16,
                        md: 24
                    },
                    left: {
                        xs: 16,
                        md: 24
                    }
                }
            }, void 0, false, {
                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                lineNumber: 91,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _stackDefault.default), {
                alignItems: "center",
                justifyContent: "center",
                sx: {
                    height: 1
                },
                children: [
                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _cardDefault.default), {
                        sx: {
                            p: 5,
                            width: 1,
                            maxWidth: 420,
                            height: 420
                        },
                        children: [
                            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _typographyDefault.default), {
                                variant: "h4",
                                children: "connect web3 identity"
                            }, void 0, false, {
                                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                lineNumber: 108,
                                columnNumber: 11
                            }, this),
                            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _typographyDefault.default), {
                                variant: "body2",
                                sx: {
                                    mt: 2,
                                    mb: 5
                                },
                                children: [
                                    "Don\u2019t have an ICP account?",
                                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _linkDefault.default), {
                                        variant: "subtitle2",
                                        href: "https://identity.ic0.app/",
                                        sx: {
                                            ml: 0.5
                                        },
                                        children: "Get started"
                                    }, void 0, false, {
                                        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                        lineNumber: 112,
                                        columnNumber: 13
                                    }, this)
                                ]
                            }, void 0, true, {
                                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                lineNumber: 110,
                                columnNumber: 11
                            }, this),
                            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _stackDefault.default), {
                                direction: "row",
                                spacing: 2,
                                children: [
                                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _buttonDefault.default), {
                                        fullWidth: true,
                                        size: "large",
                                        color: "inherit",
                                        variant: "outlined",
                                        onClick: loginAction,
                                        sx: {
                                            borderColor: (0, _styles.alpha)(theme.palette.grey[500], 0.16)
                                        },
                                        children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _typographyDefault.default), {
                                            variant: "subtitle2",
                                            sx: {
                                                ml: 0.5
                                            },
                                            children: "ICP"
                                        }, void 0, false, {
                                            fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                            lineNumber: 126,
                                            columnNumber: 15
                                        }, this)
                                    }, void 0, false, {
                                        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                        lineNumber: 118,
                                        columnNumber: 13
                                    }, this),
                                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _buttonDefault.default), {
                                        fullWidth: true,
                                        size: "large",
                                        color: "inherit",
                                        variant: "outlined",
                                        onClick: loginWeb3,
                                        sx: {
                                            borderColor: (0, _styles.alpha)(theme.palette.grey[500], 0.16)
                                        },
                                        children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _typographyDefault.default), {
                                            variant: "subtitle2",
                                            sx: {
                                                ml: 0.5
                                            },
                                            children: "ethereum"
                                        }, void 0, false, {
                                            fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                            lineNumber: 139,
                                            columnNumber: 15
                                        }, this)
                                    }, void 0, false, {
                                        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                        lineNumber: 131,
                                        columnNumber: 13
                                    }, this)
                                ]
                            }, void 0, true, {
                                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                lineNumber: 117,
                                columnNumber: 11
                            }, this)
                        ]
                    }, void 0, true, {
                        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                        lineNumber: 100,
                        columnNumber: 9
                    }, this),
                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _cardDefault.default), {
                        sx: {
                            p: 5,
                            width: 1,
                            marginTop: 5,
                            maxWidth: 420,
                            height: 620
                        },
                        children: [
                            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _typographyDefault.default), {
                                variant: "body2",
                                sx: {
                                    mt: 2,
                                    mb: 5
                                },
                                children: [
                                    "icp identity:",
                                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _appWidgetSummaryDefault.default), {
                                        subtitle: window.$icpId,
                                        color: "success"
                                    }, void 0, false, {
                                        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                        lineNumber: 154,
                                        columnNumber: 13
                                    }, this)
                                ]
                            }, void 0, true, {
                                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                lineNumber: 152,
                                columnNumber: 11
                            }, this),
                            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _typographyDefault.default), {
                                variant: "body2",
                                sx: {
                                    mt: 2,
                                    mb: 5
                                },
                                children: [
                                    "ethereum identity:",
                                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _appWidgetSummaryDefault.default), {
                                        subtitle: window.$web3AddressId,
                                        color: "success"
                                    }, void 0, false, {
                                        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                        lineNumber: 161,
                                        columnNumber: 13
                                    }, this)
                                ]
                            }, void 0, true, {
                                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                                lineNumber: 159,
                                columnNumber: 11
                            }, this)
                        ]
                    }, void 0, true, {
                        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                        lineNumber: 145,
                        columnNumber: 9
                    }, this)
                ]
            }, void 0, true, {
                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                lineNumber: 99,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _stackDefault.default), {
                alignItems: "center",
                justifyContent: "center",
                sx: {
                    height: 1
                }
            }, void 0, false, {
                fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
                lineNumber: 168,
                columnNumber: 7
            }, this)
        ]
    }, void 0, true, {
        fileName: "src/mind_body_assets/src/sections/login/login-view.jsx",
        lineNumber: 82,
        columnNumber: 5
    }, this);
}
_s(LoginView, "8V9MyrxaZ6ogyt0RIkX4xqUhtyo=", false, function() {
    return [
        (0, _styles.useTheme)
    ];
});
_c = LoginView;
var _c;
$RefreshReg$(_c, "LoginView");

  $parcel$ReactRefreshHelpers$3e86.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","@dfinity/auth-client":"d9Vw7","@dfinity/agent":"5Kuav","../../../../declarations/mind_body":"1DbUn","0xsequence":"5cSAw","@mui/material/Box":"eQD0H","@mui/material/Link":"f1yGe","@mui/material/Card":"hWYZ3","@mui/material/Stack":"cuThX","@mui/material/Button":"73csw","@mui/material/Typography":"faxSz","@mui/material/Unstable_Grid2":"2ssQQ","@mui/material/styles":"1lzai","../../theme/css":"jJA8o","../../components/logo":"cezYn","../../modules/app-widget-summary":"f0v58","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru","socket.io-client":"8HBJR"}],"5cSAw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initWallet", ()=>(0, _provider.initWallet));
parcelHelpers.export(exports, "sequence", ()=>sequence);
var _abi = require("@0xsequence/abi");
var _api = require("@0xsequence/api");
var _auth = require("@0xsequence/auth");
var _guard = require("@0xsequence/guard");
var _indexer = require("@0xsequence/indexer");
var _metadata = require("@0xsequence/metadata");
var _multicall = require("@0xsequence/multicall");
var _network = require("@0xsequence/network");
var _provider = require("@0xsequence/provider");
var _relayer = require("@0xsequence/relayer");
var _core = require("@0xsequence/core");
var _utils = require("@0xsequence/utils");
var _signhub = require("@0xsequence/signhub");
var _sessions = require("@0xsequence/sessions");
var _migration = require("@0xsequence/migration");
var _account = require("@0xsequence/account");
function _mergeNamespaces(n, m) {
    m.forEach(function(e) {
        e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
            if (k !== "default" && !(k in n)) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    });
    return Object.freeze(n);
}
var abi = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _abi
]);
var api = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _api
]);
var auth = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _auth
]);
var guard = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _guard
]);
var indexer = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _indexer
]);
var metadata = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _metadata
]);
var multicall = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _multicall
]);
var network = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _network
]);
var provider = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _provider
]);
var relayer = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _relayer
]);
const transactions = (0, _core.commons).transaction;
var transactions$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    transactions: transactions
});
var utils = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null,
    isValidSignature: (0, _provider.isValidSignature),
    isValidMessageSignature: (0, _provider.isValidMessageSignature),
    isValidTypedDataSignature: (0, _provider.isValidTypedDataSignature),
    isWalletUpToDate: (0, _provider.isWalletUpToDate)
}, [
    _utils
]);
var core = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _core
]);
var signhub = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _signhub
]);
var sessions = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _sessions
]);
var migration = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _migration
]);
var account = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null
}, [
    _account
]);
var sequence = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi,
    api: api,
    auth: auth,
    guard: guard,
    indexer: indexer,
    metadata: metadata,
    multicall: multicall,
    network: network,
    provider: provider,
    relayer: relayer,
    transactions: transactions$1,
    utils: utils,
    core: core,
    signhub: signhub,
    sessions: sessions,
    migration: migration,
    account: account,
    initWallet: (0, _provider.initWallet),
    getWallet: (0, _provider.getWallet),
    unregisterWallet: (0, _provider.unregisterWallet),
    SequenceProvider: (0, _provider.SequenceProvider),
    SequenceClient: (0, _provider.SequenceClient),
    SequenceSigner: (0, _provider.SequenceSigner)
});

},{"@0xsequence/abi":"hbXMf","@0xsequence/api":"3yLVZ","@0xsequence/auth":"9VCSm","@0xsequence/guard":"9AD2Z","@0xsequence/indexer":"a0cuA","@0xsequence/metadata":"2CrG1","@0xsequence/multicall":"7BTRB","@0xsequence/network":"01lBM","@0xsequence/provider":"1PHQ1","@0xsequence/relayer":"kiNl3","@0xsequence/core":"cIuGJ","@0xsequence/utils":"7jY5X","@0xsequence/signhub":"jyR3Z","@0xsequence/sessions":"d1XjM","@0xsequence/migration":"l6xLq","@0xsequence/account":"3UL2G","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hbXMf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "walletContracts", ()=>walletContracts);
const abi$7 = [
    {
        inputs: [
            {
                internalType: "bytes32",
                type: "bytes32"
            }
        ],
        name: "getAlternativeSignature",
        outputs: [
            {
                internalType: "string",
                type: "string"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];
var erc5719 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi$7
});
const abi$6 = [
    {
        type: "function",
        name: "isValidSignature",
        constant: true,
        inputs: [
            {
                type: "bytes32"
            },
            {
                type: "bytes"
            }
        ],
        outputs: [
            {
                type: "bytes4"
            }
        ],
        payable: false,
        stateMutability: "view"
    }
];
const returns = {
    isValidSignatureBytes32: "0x1626ba7e"
};
var erc1271 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi$6,
    returns: returns
});
const abi$5 = [
    {
        inputs: [
            {
                internalType: "bytes",
                name: "error",
                type: "bytes"
            }
        ],
        name: "ERC1271Revert",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "error",
                type: "bytes"
            }
        ],
        name: "ERC6492DeployFailed",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_signer",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes"
            }
        ],
        name: "isValidSig",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_signer",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes"
            },
            {
                internalType: "bool",
                name: "allowSideEffects",
                type: "bool"
            },
            {
                internalType: "bool",
                name: "deployAlreadyDeployed",
                type: "bool"
            }
        ],
        name: "isValidSigImpl",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_signer",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes"
            }
        ],
        name: "isValidSigNoThrow",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_signer",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes"
            }
        ],
        name: "isValidSigWithSideEffects",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_signer",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes"
            }
        ],
        name: "isValidSigWithSideEffectsNoThrow",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    }
];
var erc6492 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi$5
});
const abi$4 = [
    {
        type: "function",
        name: "deploy",
        constant: false,
        inputs: [
            {
                type: "address"
            },
            {
                type: "bytes32"
            }
        ],
        outputs: [],
        payable: true,
        stateMutability: "payable"
    }
];
var factory = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi$4
});
const abi$3 = [
    {
        type: "function",
        name: "nonce",
        constant: true,
        inputs: [],
        outputs: [
            {
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view"
    },
    {
        type: "function",
        name: "readNonce",
        constant: true,
        inputs: [
            {
                type: "uint256"
            }
        ],
        outputs: [
            {
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view"
    },
    {
        type: "function",
        name: "updateImplementation",
        constant: false,
        inputs: [
            {
                type: "address"
            }
        ],
        outputs: [],
        payable: false,
        stateMutability: "nonpayable"
    },
    {
        type: "function",
        name: "selfExecute",
        constant: false,
        inputs: [
            {
                components: [
                    {
                        type: "bool",
                        name: "delegateCall"
                    },
                    {
                        type: "bool",
                        name: "revertOnError"
                    },
                    {
                        type: "uint256",
                        name: "gasLimit"
                    },
                    {
                        type: "address",
                        name: "target"
                    },
                    {
                        type: "uint256",
                        name: "value"
                    },
                    {
                        type: "bytes",
                        name: "data"
                    }
                ],
                type: "tuple[]"
            }
        ],
        outputs: [],
        payable: false,
        stateMutability: "nonpayable"
    },
    {
        type: "function",
        name: "execute",
        constant: false,
        inputs: [
            {
                components: [
                    {
                        type: "bool",
                        name: "delegateCall"
                    },
                    {
                        type: "bool",
                        name: "revertOnError"
                    },
                    {
                        type: "uint256",
                        name: "gasLimit"
                    },
                    {
                        type: "address",
                        name: "target"
                    },
                    {
                        type: "uint256",
                        name: "value"
                    },
                    {
                        type: "bytes",
                        name: "data"
                    }
                ],
                type: "tuple[]"
            },
            {
                type: "uint256"
            },
            {
                type: "bytes"
            }
        ],
        outputs: [],
        payable: false,
        stateMutability: "nonpayable"
    },
    {
        type: "function",
        name: "createContract",
        inputs: [
            {
                type: "bytes"
            }
        ],
        payable: true,
        stateMutability: "payable"
    },
    {
        type: "function",
        name: "setExtraImageHash",
        constant: false,
        inputs: [
            {
                type: "bytes32",
                name: "imageHash"
            },
            {
                type: "uint256",
                name: "expiration"
            }
        ],
        outputs: [],
        payable: false,
        stateMutability: "nonpayable"
    }
];
var mainModule = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi$3
});
const abi$2 = [
    {
        type: "function",
        name: "updateImageHash",
        constant: true,
        inputs: [
            {
                type: "bytes32"
            }
        ],
        outputs: [],
        payable: false,
        stateMutability: "view"
    },
    {
        type: "function",
        name: "imageHash",
        constant: true,
        inputs: [],
        outputs: [
            {
                type: "bytes32"
            }
        ],
        payable: false,
        stateMutability: "view"
    }
];
var mainModuleUpgradable = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi$2
});
const abi$1 = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_factory",
                type: "address"
            },
            {
                internalType: "address",
                name: "_mainModule",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "_wallet",
                type: "address"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "_imageHash",
                type: "bytes32"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "_threshold",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "bytes",
                name: "_signers",
                type: "bytes"
            }
        ],
        name: "RequiredConfig",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "_wallet",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "_signer",
                type: "address"
            }
        ],
        name: "RequiredSigner",
        type: "event"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_addr",
                type: "address"
            }
        ],
        name: "callBalanceOf",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callBlockNumber",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_i",
                type: "uint256"
            }
        ],
        name: "callBlockhash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callChainId",
        outputs: [
            {
                internalType: "uint256",
                name: "id",
                type: "uint256"
            }
        ],
        stateMutability: "pure",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_addr",
                type: "address"
            }
        ],
        name: "callCode",
        outputs: [
            {
                internalType: "bytes",
                name: "code",
                type: "bytes"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_addr",
                type: "address"
            }
        ],
        name: "callCodeHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "codeHash",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_addr",
                type: "address"
            }
        ],
        name: "callCodeSize",
        outputs: [
            {
                internalType: "uint256",
                name: "size",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callCoinbase",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callDifficulty",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callGasLeft",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callGasLimit",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callGasPrice",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callOrigin",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "callTimestamp",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "knownImageHashes",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        name: "lastImageHashUpdate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "lastSignerUpdate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "lastWalletUpdate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "bool",
                        name: "delegateCall",
                        type: "bool"
                    },
                    {
                        internalType: "bool",
                        name: "revertOnError",
                        type: "bool"
                    },
                    {
                        internalType: "uint256",
                        name: "gasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "address",
                        name: "target",
                        type: "address"
                    },
                    {
                        internalType: "uint256",
                        name: "value",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "data",
                        type: "bytes"
                    }
                ],
                internalType: "struct IModuleCalls.Transaction[]",
                name: "_txs",
                type: "tuple[]"
            }
        ],
        name: "multiCall",
        outputs: [
            {
                internalType: "bool[]",
                name: "_successes",
                type: "bool[]"
            },
            {
                internalType: "bytes[]",
                name: "_results",
                type: "bytes[]"
            }
        ],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_wallet",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_threshold",
                type: "uint256"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "weight",
                        type: "uint256"
                    },
                    {
                        internalType: "address",
                        name: "signer",
                        type: "address"
                    }
                ],
                internalType: "struct RequireUtils.Member[]",
                name: "_members",
                type: "tuple[]"
            },
            {
                internalType: "bool",
                name: "_index",
                type: "bool"
            }
        ],
        name: "publishConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_wallet",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32"
            },
            {
                internalType: "uint256",
                name: "_sizeMembers",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes"
            },
            {
                internalType: "bool",
                name: "_index",
                type: "bool"
            }
        ],
        name: "publishInitialSigners",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_wallet",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_nonce",
                type: "uint256"
            }
        ],
        name: "requireMinNonce",
        outputs: [],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_expiration",
                type: "uint256"
            }
        ],
        name: "requireNonExpired",
        outputs: [],
        stateMutability: "view",
        type: "function"
    }
];
var sequenceUtils = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi$1
});
const abi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "requireFreshSigner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }
];
var requireFreshSigner = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    abi: abi
});
const walletContracts = {
    erc6492,
    erc5719,
    erc1271,
    factory,
    mainModule,
    mainModuleUpgradable,
    sequenceUtils,
    requireFreshSigner
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3yLVZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "API", ()=>API);
parcelHelpers.export(exports, "SequenceAPIClient", ()=>SequenceAPIClient);
parcelHelpers.export(exports, "SmartRampOrderStatus", ()=>SmartRampOrderStatus);
parcelHelpers.export(exports, "SmartRampTxnStatus", ()=>SmartRampTxnStatus);
parcelHelpers.export(exports, "SortOrder", ()=>SortOrder);
parcelHelpers.export(exports, "WebRPCSchemaHash", ()=>WebRPCSchemaHash);
parcelHelpers.export(exports, "WebRPCSchemaVersion", ()=>WebRPCSchemaVersion);
parcelHelpers.export(exports, "WebRPCVersion", ()=>WebRPCVersion);
var global = arguments[3];
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
/* eslint-disable */ // sequence-api v0.4.0 e4aaaf3a3c07a1f339226fcac3b8addcb3120c7b
// --
// Code generated by webrpc-gen@v0.10.x-dev with typescript@v0.10.0 generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=typescript@v0.10.0 -client -out=./clients/api.gen.ts
// WebRPC description and code-gen version
const WebRPCVersion = "v1";
// Schema version of your RIDL schema
const WebRPCSchemaVersion = "v0.4.0";
// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = "e4aaaf3a3c07a1f339226fcac3b8addcb3120c7b";
//
// Types
//
let SmartRampOrderStatus = /*#__PURE__*/ function(SmartRampOrderStatus) {
    SmartRampOrderStatus["UNKNOWN"] = "UNKNOWN";
    SmartRampOrderStatus["RUNNING_CHECKS"] = "RUNNING_CHECKS";
    SmartRampOrderStatus["PROCESSING"] = "PROCESSING";
    SmartRampOrderStatus["FAILED"] = "FAILED";
    SmartRampOrderStatus["COMPLETE"] = "COMPLETE";
    return SmartRampOrderStatus;
}({});
let SmartRampTxnStatus = /*#__PURE__*/ function(SmartRampTxnStatus) {
    SmartRampTxnStatus["UNKNOWN"] = "UNKNOWN";
    SmartRampTxnStatus["SUCCESSFUL"] = "SUCCESSFUL";
    SmartRampTxnStatus["FAILED"] = "FAILED";
    return SmartRampTxnStatus;
}({});
let SortOrder = /*#__PURE__*/ function(SortOrder) {
    SortOrder["DESC"] = "DESC";
    SortOrder["ASC"] = "ASC";
    return SortOrder;
}({});
//
// Client
//
class API {
    constructor(hostname, fetch){
        this.hostname = void 0;
        this.fetch = void 0;
        this.path = "/rpc/API/";
        this.ping = (headers)=>{
            return this.fetch(this.url("Ping"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.version = (headers)=>{
            return this.fetch(this.url("Version"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        version: _data.version
                    };
                });
            });
        };
        this.runtimeStatus = (headers)=>{
            return this.fetch(this.url("RuntimeStatus"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.getSequenceContext = (headers)=>{
            return this.fetch(this.url("GetSequenceContext"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        data: _data.data
                    };
                });
            });
        };
        this.getAuthToken = (args, headers)=>{
            return this.fetch(this.url("GetAuthToken"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        jwtToken: _data.jwtToken,
                        address: _data.address,
                        user: _data.user
                    };
                });
            });
        };
        this.sendPasswordlessLink = (args, headers)=>{
            return this.fetch(this.url("SendPasswordlessLink"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.friendList = (args, headers)=>{
            return this.fetch(this.url("FriendList"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        friends: _data.friends
                    };
                });
            });
        };
        this.getFriendByAddress = (args, headers)=>{
            return this.fetch(this.url("GetFriendByAddress"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        friend: _data.friend
                    };
                });
            });
        };
        this.searchFriends = (args, headers)=>{
            return this.fetch(this.url("SearchFriends"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        friends: _data.friends
                    };
                });
            });
        };
        this.addFriend = (args, headers)=>{
            return this.fetch(this.url("AddFriend"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        friend: _data.friend
                    };
                });
            });
        };
        this.updateFriendNickname = (args, headers)=>{
            return this.fetch(this.url("UpdateFriendNickname"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        friend: _data.friend
                    };
                });
            });
        };
        this.removeFriend = (args, headers)=>{
            return this.fetch(this.url("RemoveFriend"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.contractCall = (args, headers)=>{
            return this.fetch(this.url("ContractCall"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        returns: _data.returns
                    };
                });
            });
        };
        this.decodeContractCall = (args, headers)=>{
            return this.fetch(this.url("DecodeContractCall"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        call: _data.call
                    };
                });
            });
        };
        this.lookupContractCallSelectors = (args, headers)=>{
            return this.fetch(this.url("LookupContractCallSelectors"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        signatures: _data.signatures
                    };
                });
            });
        };
        this.userStorageFetch = (args, headers)=>{
            return this.fetch(this.url("UserStorageFetch"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        object: _data.object
                    };
                });
            });
        };
        this.userStorageSave = (args, headers)=>{
            return this.fetch(this.url("UserStorageSave"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        ok: _data.ok
                    };
                });
            });
        };
        this.userStorageDelete = (args, headers)=>{
            return this.fetch(this.url("UserStorageDelete"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        ok: _data.ok
                    };
                });
            });
        };
        this.userStorageFetchAll = (args, headers)=>{
            return this.fetch(this.url("UserStorageFetchAll"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        objects: _data.objects
                    };
                });
            });
        };
        this.getMoonpayLink = (args, headers)=>{
            return this.fetch(this.url("GetMoonpayLink"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        signedUrl: _data.signedUrl
                    };
                });
            });
        };
        this.getSardineClientToken = (headers)=>{
            return this.fetch(this.url("GetSardineClientToken"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        token: _data.token
                    };
                });
            });
        };
        this.isUsingGoogleMail = (args, headers)=>{
            return this.fetch(this.url("IsUsingGoogleMail"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        yes: _data.yes
                    };
                });
            });
        };
        this.resolveENSAddress = (args, headers)=>{
            return this.fetch(this.url("ResolveENSAddress"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        address: _data.address,
                        ok: _data.ok
                    };
                });
            });
        };
        this.isValidSignature = (args, headers)=>{
            return this.fetch(this.url("IsValidSignature"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        isValid: _data.isValid
                    };
                });
            });
        };
        this.isValidMessageSignature = (args, headers)=>{
            return this.fetch(this.url("IsValidMessageSignature"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        isValid: _data.isValid
                    };
                });
            });
        };
        this.isValidTypedDataSignature = (args, headers)=>{
            return this.fetch(this.url("IsValidTypedDataSignature"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        isValid: _data.isValid
                    };
                });
            });
        };
        this.isValidETHAuthProof = (args, headers)=>{
            return this.fetch(this.url("IsValidETHAuthProof"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        isValid: _data.isValid
                    };
                });
            });
        };
        this.getCoinPrices = (args, headers)=>{
            return this.fetch(this.url("GetCoinPrices"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        tokenPrices: _data.tokenPrices
                    };
                });
            });
        };
        this.getCollectiblePrices = (args, headers)=>{
            return this.fetch(this.url("GetCollectiblePrices"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        tokenPrices: _data.tokenPrices
                    };
                });
            });
        };
        this.getExchangeRate = (args, headers)=>{
            return this.fetch(this.url("GetExchangeRate"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        exchangeRate: _data.exchangeRate
                    };
                });
            });
        };
        this.memoryStore = (args, headers)=>{
            return this.fetch(this.url("MemoryStore"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        ok: _data.ok
                    };
                });
            });
        };
        this.memoryLoad = (args, headers)=>{
            return this.fetch(this.url("MemoryLoad"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        value: _data.value
                    };
                });
            });
        };
        this.listPayCardsOnFile = (headers)=>{
            return this.fetch(this.url("ListPayCardsOnFile"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        payCards: _data.payCards
                    };
                });
            });
        };
        this.savePayCard = (args, headers)=>{
            return this.fetch(this.url("SavePayCard"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        ok: _data.ok,
                        payCard: _data.payCard
                    };
                });
            });
        };
        this.updatePayCardCVC = (args, headers)=>{
            return this.fetch(this.url("UpdatePayCardCVC"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        ok: _data.ok
                    };
                });
            });
        };
        this.deletePayCard = (args, headers)=>{
            return this.fetch(this.url("DeletePayCard"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        ok: _data.ok
                    };
                });
            });
        };
        this.smartRampQuote = (args, headers)=>{
            return this.fetch(this.url("SmartRampQuote"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        quoteDetails: _data.quoteDetails
                    };
                });
            });
        };
        this.smartRampPurchase = (args, headers)=>{
            return this.fetch(this.url("SmartRampPurchase"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        processing: _data.processing,
                        receipt: _data.receipt
                    };
                });
            });
        };
        this.smartRampWaitOrderConfirmation = (args, headers)=>{
            return this.fetch(this.url("SmartRampWaitOrderConfirmation"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        done: _data.done,
                        receipt: _data.receipt
                    };
                });
            });
        };
        this.smartRampGetOrder = (args, headers)=>{
            return this.fetch(this.url("SmartRampGetOrder"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        order: _data.order
                    };
                });
            });
        };
        this.smartRampCheckCardAuthorization = (args, headers)=>{
            return this.fetch(this.url("SmartRampCheckCardAuthorization"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        cardAuth: _data.cardAuth
                    };
                });
            });
        };
        this.smartRampOrdersList = (args, headers)=>{
            return this.fetch(this.url("SmartRampOrdersList"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        orders: _data.orders
                    };
                });
            });
        };
        this.smartRampGetOrderTxnHash = (args, headers)=>{
            return this.fetch(this.url("SmartRampGetOrderTxnHash"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        txnHash: _data.txnHash,
                        txnSuccessful: _data.txnSuccessful
                    };
                });
            });
        };
        this.smartRampSubmitCardAuthorization = (args, headers)=>{
            return this.fetch(this.url("SmartRampSubmitCardAuthorization"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.adminSmartRampGetOrder = (args, headers)=>{
            return this.fetch(this.url("AdminSmartRampGetOrder"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        order: _data.order
                    };
                });
            });
        };
        this.adminSmartRampListCompletedOrders = (args, headers)=>{
            return this.fetch(this.url("AdminSmartRampListCompletedOrders"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        orders: _data.orders
                    };
                });
            });
        };
        this.adminSmartRampListPendingOrders = (args, headers)=>{
            return this.fetch(this.url("AdminSmartRampListPendingOrders"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        pendingOrders: _data.pendingOrders
                    };
                });
            });
        };
        this.getInviteInfo = (headers)=>{
            return this.fetch(this.url("GetInviteInfo"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        inviteInfo: _data.inviteInfo
                    };
                });
            });
        };
        this.isValidAccessCode = (args, headers)=>{
            return this.fetch(this.url("IsValidAccessCode"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.internalClaimAccessCode = (args, headers)=>{
            return this.fetch(this.url("InternalClaimAccessCode"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.walletRecover = (args, headers)=>{
            return this.fetch(this.url("WalletRecover"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        encryptedWallet: _data.encryptedWallet
                    };
                });
            });
        };
        this.blockNumberAtTime = (args, headers)=>{
            return this.fetch(this.url("BlockNumberAtTime"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        blocks: _data.blocks
                    };
                });
            });
        };
        this.paperSessionSecret = (args, headers)=>{
            return this.fetch(this.url("PaperSessionSecret"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        secret: _data.secret
                    };
                });
            });
        };
        this.paperSessionSecret2 = (args, headers)=>{
            return this.fetch(this.url("PaperSessionSecret2"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        secret: _data.secret
                    };
                });
            });
        };
        this.hostname = hostname;
        this.fetch = (input, init)=>fetch(input, init);
    }
    url(name) {
        return this.hostname + this.path + name;
    }
}
const createHTTPRequest = (body = {}, headers = {})=>{
    return {
        method: "POST",
        headers: _extends({}, headers, {
            "Content-Type": "application/json"
        }),
        body: JSON.stringify(body || {})
    };
};
const buildResponse = (res)=>{
    return res.text().then((text)=>{
        let data;
        try {
            data = JSON.parse(text);
        } catch (err) {
            throw {
                code: "unknown",
                msg: `expecting JSON, got: ${text}`,
                status: res.status
            };
        }
        if (!res.ok) throw data; // webrpc error response
        return data;
    });
};
const fetch = typeof global === "object" ? global.fetch : window.fetch;
class SequenceAPIClient extends API {
    constructor(hostname, projectAccessKey, jwtAuth){
        super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch);
        this.projectAccessKey = projectAccessKey;
        this.jwtAuth = jwtAuth;
        this._fetch = (input, init)=>{
            // automatically include jwt and access key auth header to requests
            // if its been set on the api client
            const headers = {};
            const jwtAuth = this.jwtAuth;
            const projectAccessKey = this.projectAccessKey;
            if (jwtAuth && jwtAuth.length > 0) headers["Authorization"] = `BEARER ${jwtAuth}`;
            if (projectAccessKey && projectAccessKey.length > 0) headers["X-Access-Key"] = projectAccessKey;
            // before the request is made
            init.headers = _extends({}, init.headers, headers);
            return fetch(input, init);
        };
        this.fetch = this._fetch;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9VCSm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthError", ()=>AuthError);
parcelHelpers.export(exports, "CRITICAL_CHAINS", ()=>CRITICAL_CHAINS);
parcelHelpers.export(exports, "ErrAccountIsRequired", ()=>ErrAccountIsRequired);
parcelHelpers.export(exports, "Session", ()=>Session);
parcelHelpers.export(exports, "SessionSettingsDefault", ()=>SessionSettingsDefault);
parcelHelpers.export(exports, "ValidateSequenceWalletProof", ()=>ValidateSequenceWalletProof);
parcelHelpers.export(exports, "isSessionDumpV1", ()=>isSessionDumpV1);
parcelHelpers.export(exports, "isSessionDumpV2", ()=>isSessionDumpV2);
parcelHelpers.export(exports, "signAuthorization", ()=>signAuthorization);
var _ethers = require("ethers");
var _ethauth = require("@0xsequence/ethauth");
var _network = require("@0xsequence/network");
var _account = require("@0xsequence/account");
var _api = require("@0xsequence/api");
var _indexer = require("@0xsequence/indexer");
var _metadata = require("@0xsequence/metadata");
var _utils = require("@0xsequence/utils");
var _sessions = require("@0xsequence/sessions");
var _signhub = require("@0xsequence/signhub");
var _core = require("@0xsequence/core");
// Default session expiration of ETHAuth token (1 week)
const DEFAULT_SESSION_EXPIRATION = 604800;
const EXPIRATION_JWT_MARGIN = 60; // seconds
class Services {
    constructor(account, settings, status = {}, projectAccessKey){
        this.account = account;
        this.settings = settings;
        this.status = status;
        this._initialAuthRequest = void 0;
        // proof strings are indexed by account address and app name, see getProofStringKey()
        this.proofStrings = new Map();
        this.onAuthCallbacks = [];
        this.apiClient = void 0;
        this.metadataClient = void 0;
        this.indexerClients = new Map();
        this.projectAccessKey = void 0;
        this.projectAccessKey = projectAccessKey;
    }
    now() {
        return Math.floor(Date.now() / 1000);
    }
    get expiration() {
        var _this$settings$metada;
        return Math.max((_this$settings$metada = this.settings.metadata.expiration) != null ? _this$settings$metada : DEFAULT_SESSION_EXPIRATION, 120);
    }
    onAuth(cb) {
        this.onAuthCallbacks.push(cb);
        return ()=>this.onAuthCallbacks = this.onAuthCallbacks.filter((c)=>c !== cb);
    }
    async dump() {
        if (!this.status.jwt) return {
            metadata: this.settings.metadata
        };
        return {
            jwt: {
                token: await this.status.jwt.token,
                expiration: this.status.jwt.expiration
            },
            metadata: this.status.metadata
        };
    }
    auth(maxTries = 5) {
        var _this = this;
        if (this._initialAuthRequest) return this._initialAuthRequest;
        this._initialAuthRequest = async function() {
            const url = _this.settings.sequenceApiUrl;
            if (!url) throw Error("No sequence api url");
            let jwtAuth;
            for(let i = 1;; i++)try {
                jwtAuth = (await _this.getJWT(true)).token;
                break;
            } catch (error) {
                if (i === maxTries) {
                    console.error(`couldn't authenticate after ${maxTries} attempts`, error);
                    throw error;
                }
            }
            return new (0, _api.SequenceAPIClient)(url, undefined, jwtAuth);
        }();
        return this._initialAuthRequest;
    }
    async getJWT(tryAuth) {
        var _this2 = this;
        const url = this.settings.sequenceApiUrl;
        if (!url) throw Error("No sequence api url");
        // check if we already have or are waiting for a token
        if (this.status.jwt) {
            const _jwt = this.status.jwt;
            const _token = await _jwt.token;
            if (this.now() < _jwt.expiration) return {
                token: _token,
                expiration: _jwt.expiration
            };
            // token expired, delete it and get a new one
            this.status.jwt = undefined;
        }
        if (!tryAuth) throw new Error("no auth token in memory");
        const proofStringKey = this.getProofStringKey();
        const { proofString, expiration } = this.getProofString(proofStringKey);
        const jwt = {
            token: proofString.then(async function(proofString) {
                const api = new (0, _api.SequenceAPIClient)(url);
                const authResp = await api.getAuthToken({
                    ewtString: proofString
                });
                if ((authResp == null ? void 0 : authResp.status) === true && authResp.jwtToken.length !== 0) return authResp.jwtToken;
                else {
                    if (!await _this2.isProofStringValid(proofString)) _this2.proofStrings.delete(proofStringKey);
                    throw new Error("no auth token from server");
                }
            }).catch((reason)=>{
                this.status.jwt = undefined;
                throw reason;
            }),
            expiration
        };
        this.status.jwt = jwt;
        jwt.token.then((token)=>{
            this.onAuthCallbacks.forEach((cb)=>{
                try {
                    cb({
                        status: "fulfilled",
                        value: token
                    });
                } catch (_unused) {}
            });
        }).catch((reason)=>{
            this.onAuthCallbacks.forEach((cb)=>{
                try {
                    cb({
                        status: "rejected",
                        reason
                    });
                } catch (_unused2) {}
            });
        });
        const token = await jwt.token;
        return {
            token,
            expiration
        };
    }
    getProofStringKey() {
        return `${this.account.address} - ${this.settings.metadata.name}`;
    }
    async isProofStringValid(proofString) {
        try {
            const ethAuth = new (0, _ethauth.ETHAuth)();
            const chainId = (0, _ethers.ethers).BigNumber.from(this.settings.sequenceApiChainId);
            const network = (0, _network.findNetworkConfig)(this.account.networks, chainId);
            if (!network) throw Error("No network found");
            ethAuth.chainId = chainId.toNumber();
            // TODO: Modify ETHAuth so it can take a provider instead of a url
            // -----
            // Can't pass jwt here since this is used for getting the jwt
            ethAuth.provider = new (0, _ethers.ethers).providers.StaticJsonRpcProvider((0, _utils.getEthersConnectionInfo)(network.rpcUrl, this.projectAccessKey), {
                name: "",
                chainId: chainId.toNumber()
            });
            await ethAuth.decodeProof(proofString);
            return true;
        } catch (_unused3) {
            return false;
        }
    }
    async getAPIClient(tryAuth = true) {
        if (!this.apiClient) {
            const url = this.settings.sequenceApiUrl;
            if (!url) throw Error("No sequence api url");
            const jwtAuth = (await this.getJWT(tryAuth)).token;
            this.apiClient = new (0, _api.SequenceAPIClient)(url, undefined, jwtAuth);
        }
        return this.apiClient;
    }
    async getMetadataClient(tryAuth = true) {
        if (!this.metadataClient) {
            const jwtAuth = (await this.getJWT(tryAuth)).token;
            this.metadataClient = new (0, _metadata.SequenceMetadata)(this.settings.sequenceMetadataUrl, undefined, jwtAuth);
        }
        return this.metadataClient;
    }
    async getIndexerClient(chainId, tryAuth = true) {
        const network = (0, _network.findNetworkConfig)(this.account.networks, chainId);
        if (!network) throw Error(`No network for chain ${chainId}`);
        if (!this.indexerClients.has(network.chainId)) {
            if (network.indexer) this.indexerClients.set(network.chainId, network.indexer);
            else if (network.indexerUrl) {
                const jwtAuth = (await this.getJWT(tryAuth)).token;
                this.indexerClients.set(network.chainId, new (0, _indexer.SequenceIndexer)(network.indexerUrl, undefined, jwtAuth));
            } else throw Error(`No indexer url for chain ${chainId}`);
        }
        return this.indexerClients.get(network.chainId);
    }
    getProofString(key) {
        // check if we already have or are waiting for a proof string
        if (this.proofStrings.has(key)) {
            const _proofString = this.proofStrings.get(key);
            if (this.now() < _proofString.expiration) return _proofString;
            // proof string expired, delete it and make a new one
            this.proofStrings.delete(key);
        }
        const proof = new (0, _ethauth.Proof)({
            address: this.account.address
        });
        proof.claims.app = this.settings.metadata.name;
        if (typeof window === "object") proof.claims.ogn = window.location.origin;
        proof.setExpiryIn(this.expiration);
        const ethAuth = new (0, _ethauth.ETHAuth)();
        const chainId = (0, _ethers.ethers).BigNumber.from(this.settings.sequenceApiChainId);
        const network = (0, _network.findNetworkConfig)(this.account.networks, chainId);
        if (!network) throw Error("No network found");
        ethAuth.chainId = chainId.toNumber();
        // TODO: Modify ETHAuth so it can take a provider instead of a url
        // -----
        // Can't pass jwt here since this is used for getting the jwt
        ethAuth.provider = new (0, _ethers.ethers).providers.StaticJsonRpcProvider((0, _utils.getEthersConnectionInfo)(network.rpcUrl, this.projectAccessKey), {
            name: "",
            chainId: chainId.toNumber()
        });
        const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN;
        const proofString = {
            proofString: Promise.resolve(// NOTICE: TODO: Here we ask the account to sign the message
            // using whatever configuration we have ON-CHAIN, this means
            // that the account will still use the v1 wallet, even if the migration
            // was signed.
            //
            // This works for Sequence webapp v1 -> v2 because all v1 configurations share the same formula
            // (torus + guard), but if we ever decide to allow cross-device login, then it will not work, because
            // those other signers may not be part of the configuration.
            //
            this.account.signDigest(proof.messageDigest(), this.settings.sequenceApiChainId, true, "eip6492")).then((s)=>{
                proof.signature = s;
                return ethAuth.encodeProof(proof, true);
            }).catch((reason)=>{
                this.proofStrings.delete(key);
                throw reason;
            }),
            expiration
        };
        this.proofStrings.set(key, proofString);
        return proofString;
    }
}
// signAuthorization will perform an EIP712 typed-data message signing of ETHAuth domain via the provided
// Signer and authorization options.
const signAuthorization = async (signer, chainId, options)=>{
    const address = (0, _ethers.ethers).utils.getAddress(await signer.getAddress());
    if (!address || address === "" || address === "0x") throw ErrAccountIsRequired;
    const proof = new (0, _ethauth.Proof)();
    proof.address = address;
    if (!options || !options.app || options.app === "") throw new AuthError("authorization options requires app to be set");
    proof.claims.app = options.app;
    proof.claims.ogn = options.origin;
    proof.claims.n = options.nonce;
    proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION);
    const typedData = proof.messageTypedData();
    const chainIdNumber = (0, _network.toChainIdNumber)(chainId);
    proof.signature = await (signer instanceof (0, _account.Account) ? // Account can sign EIP-6492 signatures, so it doesn't require deploying the wallet
    signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber, "eip6492") : signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber));
    const ethAuth = new (0, _ethauth.ETHAuth)();
    const proofString = await ethAuth.encodeProof(proof, true);
    return {
        typedData,
        proofString
    };
};
// TODO: review......
class AuthError extends Error {
    constructor(message){
        super(message);
        this.name = "AuthError";
    }
}
const ErrAccountIsRequired = new AuthError("auth error: account address is empty");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function isSessionDumpV1(obj) {
    return obj.config && obj.metadata && obj.version === undefined;
}
function isSessionDumpV2(obj) {
    return obj.version === 2 && obj.address;
}
// These chains are always validated for migrations
// if they are not available, the login will fail
const CRITICAL_CHAINS = [
    1,
    137
];
const SessionSettingsDefault = {
    contexts: (0, _core.commons).context.defaultContexts,
    networks: (0, _network.allNetworks),
    tracker: new (0, _sessions.trackers).remote.RemoteConfigTracker("https://sessions.sequence.app")
};
class Session {
    constructor(networks, contexts, account, services){
        this.networks = networks;
        this.contexts = contexts;
        this.account = account;
        this.services = services;
    }
    async dump() {
        const base = {
            version: 2,
            address: this.account.address
        };
        if (this.services) return _extends({}, base, await this.services.dump());
        return base;
    }
    static async singleSigner(args) {
        let { signer } = args;
        if (typeof signer === "string") signer = new (0, _ethers.ethers).Wallet(signer);
        const orchestrator = new (0, _signhub.Orchestrator)([
            signer
        ]);
        const referenceSigner = await signer.getAddress();
        const threshold = 1;
        const addSigners = [
            {
                weight: 1,
                address: referenceSigner
            }
        ];
        const selectWallet = args.selectWallet || async function(wallets) {
            var _args$settings$tracke, _args$settings;
            if (wallets.length === 0) return undefined;
            // Find a wallet that was originally created
            // as a 1/1 of the reference signer
            const tracker = (_args$settings$tracke = (_args$settings = args.settings) == null ? void 0 : _args$settings.tracker) != null ? _args$settings$tracke : SessionSettingsDefault.tracker;
            const configs = await Promise.all(wallets.map(async function(wallet) {
                const imageHash = await tracker.imageHashOfCounterfactualWallet({
                    wallet
                });
                return {
                    wallet,
                    config: imageHash && await tracker.configOfImageHash({
                        imageHash: imageHash.imageHash
                    })
                };
            }));
            for (const config of configs){
                if (!config.config) continue;
                const coder = (0, _core.universal).genericCoderFor(config.config.version);
                const signers = coder.config.signersOf(config.config);
                if (signers.length === 1 && signers[0].address === referenceSigner) return config.wallet;
            }
            return undefined;
        };
        return Session.open(_extends({}, args, {
            orchestrator,
            referenceSigner,
            threshold,
            addSigners,
            selectWallet
        }));
    }
    static async open(args) {
        var _findNetworkConfig$ch, _findNetworkConfig, _settings$services$se, _settings$services, _networks$;
        const { referenceSigner, threshold, addSigners, selectWallet, onAccountAddress, settings, editConfigOnMigration, onMigration, orchestrator, projectAccessKey } = args;
        const { contexts, networks, tracker, services } = _extends({}, SessionSettingsDefault, settings);
        // The reference network is mainnet, if mainnet is not available, we use the first network
        const referenceChainId = (_findNetworkConfig$ch = (_findNetworkConfig = (0, _network.findNetworkConfig)(networks, (_settings$services$se = settings == null || (_settings$services = settings.services) == null ? void 0 : _settings$services.sequenceApiChainId) != null ? _settings$services$se : (0, _network.ChainId).MAINNET)) == null ? void 0 : _findNetworkConfig.chainId) != null ? _findNetworkConfig$ch : (_networks$ = networks[0]) == null ? void 0 : _networks$.chainId;
        if (!referenceChainId) throw Error("No reference chain found");
        const foundWallets = await tracker.walletsOfSigner({
            signer: referenceSigner
        });
        const selectedWallet = await selectWallet(foundWallets.map((w)=>w.wallet));
        let account;
        if (selectedWallet) {
            onAccountAddress == null || onAccountAddress(selectedWallet);
            // existing account, lets update it
            account = new (0, _account.Account)({
                address: selectedWallet,
                tracker,
                networks,
                contexts,
                orchestrator,
                projectAccessKey
            });
            // Get the latest configuration of the wallet (on the reference chain)
            // now this configuration should be of the latest version, so we can start
            // manipulating it.
            // NOTICE: We are performing the wallet update on a single chain, assuming that
            // all other networks have the same configuration. This is not always true.
            if (addSigners && addSigners.length > 0) {
                // New wallets never need migrations
                // (because we create them on the latest version)
                let status = await account.status(referenceChainId);
                // If the wallet was created originally on v2, then we can skip
                // the migration checks all together.
                if (status.original.version !== status.version || account.version !== status.version) {
                    // Account may not have been migrated yet, so we need to check
                    // if it has been migrated and if not, migrate it (in all chains)
                    const { migratedAllChains: isFullyMigrated, failedChains } = await account.isMigratedAllChains();
                    // Failed chains must not contain mainnet or polygon, otherwise we cannot proceed.
                    if (failedChains.some((c)=>CRITICAL_CHAINS.includes(c))) throw Error(`Failed to fetch account status on ${failedChains.join(", ")}`);
                    if (!isFullyMigrated) {
                        // This is an oportunity for whoever is opening the session to
                        // feed the orchestrator with more signers, so that the migration
                        // can be completed.
                        if (onMigration && !await onMigration(account)) throw Error("Migration cancelled, cannot open session");
                        const { failedChains: _failedChains } = await account.signAllMigrations(editConfigOnMigration || ((c)=>c));
                        if (_failedChains.some((c)=>CRITICAL_CHAINS.includes(c))) throw Error(`Failed to sign migrations on ${_failedChains.join(", ")}`);
                        // If we are using a dedupped tracker we need to invalidate the cache
                        // otherwise we run the risk of not seeing the signed migrations reflected.
                        if ((0, _sessions.trackers).isDedupedTracker(tracker)) tracker.invalidateCache();
                        let isFullyMigrated2;
                        [isFullyMigrated2, status] = await Promise.all([
                            account.isMigratedAllChains().then((r)=>r.migratedAllChains),
                            account.status(referenceChainId)
                        ]);
                        if (!isFullyMigrated2) throw Error("Failed to migrate account");
                    }
                }
                // NOTICE: We only need to do this because the API will not be able to
                // validate the v2 signature (if the account has an onchain version of 1)
                // we could speed this up by sending the migration alongside the jwt request
                // and letting the API validate it offchain.
                if (status.onChain.version !== status.version) await account.doBootstrap(referenceChainId, undefined, status);
                const prevConfig = status.config;
                const nextConfig = account.coders.config.editConfig(prevConfig, {
                    add: addSigners,
                    threshold
                });
                // Only update the onchain config if the imageHash has changed
                if (account.coders.config.imageHashOf(prevConfig) !== account.coders.config.imageHashOf(nextConfig)) {
                    const newConfig = account.coders.config.editConfig(nextConfig, {
                        checkpoint: account.coders.config.checkpointOf(prevConfig).add(1)
                    });
                    await account.updateConfig(newConfig);
                }
            }
        } else {
            if (!addSigners || addSigners.length === 0) throw Error("Cannot create new account without signers");
            if (!threshold) throw Error("Cannot create new account without threshold");
            // fresh account
            account = await (0, _account.Account).new({
                config: {
                    threshold,
                    checkpoint: 0,
                    signers: addSigners
                },
                tracker,
                contexts,
                orchestrator,
                networks,
                projectAccessKey
            });
            onAccountAddress == null || onAccountAddress(account.address);
            // sign a digest and send it to the tracker
            // otherwise the tracker will not know about this account
            await account.publishWitness();
            // safety check, the remove tracker should be able to find
            // this account for the reference signer
            const _foundWallets = await tracker.walletsOfSigner({
                signer: referenceSigner,
                noCache: true
            });
            if (!_foundWallets.some((w)=>w.wallet === account.address)) throw Error("Account not found on tracker");
        }
        let servicesObj;
        if (services) {
            servicesObj = new Services(account, services);
            servicesObj.auth(); // fire and forget
            servicesObj.onAuth((result)=>{
                if (result.status === "fulfilled") account.setJwt(result.value);
            });
        }
        return new Session(networks, contexts, account, servicesObj);
    }
    static async load(args) {
        const { dump, settings, editConfigOnMigration, onMigration, orchestrator } = args;
        const { contexts, networks, tracker, services } = _extends({}, SessionSettingsDefault, settings);
        let account;
        if (isSessionDumpV1(dump)) {
            var _dump$jwt$expiration, _dump$jwt, _dump$jwt2;
            // Old configuration format used to also contain an "address" field
            // but if it doesn't, it means that it was a "counterfactual" account
            // not yet updated, so we need to compute the address
            const oldAddress = dump.config.address || (0, _core.commons).context.addressOf(contexts[1], (0, _core.v1).config.ConfigCoder.imageHashOf(_extends({}, dump.config, {
                version: 1
            })));
            const jwtExpired = ((_dump$jwt$expiration = (_dump$jwt = dump.jwt) == null ? void 0 : _dump$jwt.expiration) != null ? _dump$jwt$expiration : 0) < Math.floor(Date.now() / 1000);
            account = new (0, _account.Account)({
                address: oldAddress,
                tracker,
                networks,
                contexts,
                orchestrator,
                jwt: jwtExpired ? undefined : (_dump$jwt2 = dump.jwt) == null ? void 0 : _dump$jwt2.token
            });
            // TODO: This property may not hold if the user adds a new network
            if (!await account.isMigratedAllChains().then((r)=>r.migratedAllChains)) {
                // This is an oportunity for whoever is opening the session to
                // feed the orchestrator with more signers, so that the migration
                // can be completed.
                if (onMigration && !await onMigration(account)) throw Error("Migration cancelled, cannot open session");
                console.log("Migrating account...");
                await account.signAllMigrations(editConfigOnMigration);
                if (!await account.isMigratedAllChains().then((r)=>r.migratedAllChains)) throw Error("Failed to migrate account");
            }
        // We may need to update the JWT if the account has been migrated
        } else if (isSessionDumpV2(dump)) {
            var _dump$jwt$expiration2, _dump$jwt3, _dump$jwt4;
            const jwtExpired = ((_dump$jwt$expiration2 = (_dump$jwt3 = dump.jwt) == null ? void 0 : _dump$jwt3.expiration) != null ? _dump$jwt$expiration2 : 0) < Math.floor(Date.now() / 1000);
            account = new (0, _account.Account)({
                address: dump.address,
                tracker,
                networks,
                contexts,
                orchestrator,
                jwt: jwtExpired ? undefined : (_dump$jwt4 = dump.jwt) == null ? void 0 : _dump$jwt4.token
            });
        } else throw Error("Invalid dump format");
        let servicesObj;
        if (services) {
            var _dump$jwt$expiration3;
            servicesObj = new Services(account, services, dump.jwt && {
                jwt: {
                    token: Promise.resolve(dump.jwt.token),
                    expiration: (_dump$jwt$expiration3 = dump.jwt.expiration) != null ? _dump$jwt$expiration3 : (0, _utils.jwtDecodeClaims)(dump.jwt.token).exp
                },
                metadata: dump.metadata
            });
        }
        return new Session(networks, contexts, account, servicesObj);
    }
}
const ValidateSequenceWalletProof = (readerFor, tracker, context)=>{
    return async (_provider, chainId, proof)=>{
        const digest = proof.messageDigest();
        const isValid = await readerFor(chainId).isValidSignature(proof.address, digest, proof.signature);
        return {
            isValid
        };
    };
};

},{"ethers":"hdHML","@0xsequence/ethauth":"lOpRc","@0xsequence/network":"01lBM","@0xsequence/account":"3UL2G","@0xsequence/api":"3yLVZ","@0xsequence/indexer":"a0cuA","@0xsequence/metadata":"2CrG1","@0xsequence/utils":"7jY5X","@0xsequence/sessions":"d1XjM","@0xsequence/signhub":"jyR3Z","@0xsequence/core":"cIuGJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hdHML":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Signer", ()=>(0, _ethers.Signer));
parcelHelpers.export(exports, "Wallet", ()=>(0, _ethers.Wallet));
parcelHelpers.export(exports, "VoidSigner", ()=>(0, _ethers.VoidSigner));
parcelHelpers.export(exports, "getDefaultProvider", ()=>(0, _ethers.getDefaultProvider));
parcelHelpers.export(exports, "providers", ()=>(0, _ethers.providers));
parcelHelpers.export(exports, "BaseContract", ()=>(0, _ethers.BaseContract));
parcelHelpers.export(exports, "Contract", ()=>(0, _ethers.Contract));
parcelHelpers.export(exports, "ContractFactory", ()=>(0, _ethers.ContractFactory));
parcelHelpers.export(exports, "BigNumber", ()=>(0, _ethers.BigNumber));
parcelHelpers.export(exports, "FixedNumber", ()=>(0, _ethers.FixedNumber));
parcelHelpers.export(exports, "constants", ()=>(0, _ethers.constants));
parcelHelpers.export(exports, "errors", ()=>(0, _ethers.errors));
parcelHelpers.export(exports, "logger", ()=>(0, _ethers.logger));
parcelHelpers.export(exports, "utils", ()=>(0, _ethers.utils));
parcelHelpers.export(exports, "wordlists", ()=>(0, _ethers.wordlists));
parcelHelpers.export(exports, "version", ()=>(0, _ethers.version));
parcelHelpers.export(exports, "Wordlist", ()=>(0, _ethers.Wordlist));
parcelHelpers.export(exports, "ethers", ()=>_ethers);
// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js
var _ethers = require("./ethers");
"use strict";
try {
    const anyGlobal = window;
    if (anyGlobal._ethers == null) anyGlobal._ethers = _ethers;
} catch (error) {}

},{"./ethers":"LOU4X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"LOU4X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
////////////////////////
// Exports
parcelHelpers.export(exports, "Signer", ()=>(0, _abstractSigner.Signer));
parcelHelpers.export(exports, "Wallet", ()=>(0, _wallet.Wallet));
parcelHelpers.export(exports, "VoidSigner", ()=>(0, _abstractSigner.VoidSigner));
parcelHelpers.export(exports, "getDefaultProvider", ()=>(0, _providers.getDefaultProvider));
parcelHelpers.export(exports, "providers", ()=>_providers);
parcelHelpers.export(exports, "BaseContract", ()=>(0, _contracts.BaseContract));
parcelHelpers.export(exports, "Contract", ()=>(0, _contracts.Contract));
parcelHelpers.export(exports, "ContractFactory", ()=>(0, _contracts.ContractFactory));
parcelHelpers.export(exports, "BigNumber", ()=>(0, _bignumber.BigNumber));
parcelHelpers.export(exports, "FixedNumber", ()=>(0, _bignumber.FixedNumber));
parcelHelpers.export(exports, "constants", ()=>_constants);
parcelHelpers.export(exports, "errors", ()=>(0, _logger.ErrorCode));
parcelHelpers.export(exports, "logger", ()=>logger);
parcelHelpers.export(exports, "utils", ()=>_utils);
parcelHelpers.export(exports, "wordlists", ()=>(0, _wordlists.wordlists));
parcelHelpers.export(exports, "version", ()=>////////////////////////
    // Compile-Time Constants
    (0, _version.version));
parcelHelpers.export(exports, "Wordlist", ()=>(0, _wordlists.Wordlist));
var _contracts = require("@ethersproject/contracts");
var _bignumber = require("@ethersproject/bignumber");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _wallet = require("@ethersproject/wallet");
var _constants = require("@ethersproject/constants");
var _providers = require("@ethersproject/providers");
var _wordlists = require("@ethersproject/wordlists");
var _utils = require("./utils");
var _logger = require("@ethersproject/logger");
////////////////////////
// Compile-Time Constants
// This is generated by "npm run dist"
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));

},{"@ethersproject/contracts":"97okZ","@ethersproject/bignumber":"ckYYW","@ethersproject/abstract-signer":"g9Ey5","@ethersproject/wallet":"2DfhD","@ethersproject/constants":"gKbDE","@ethersproject/providers":"bErvj","@ethersproject/wordlists":"czmoZ","./utils":"1VLBZ","@ethersproject/logger":"hLvB2","./_version":"aosLW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"97okZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseContract", ()=>BaseContract);
parcelHelpers.export(exports, "Contract", ()=>Contract);
parcelHelpers.export(exports, "ContractFactory", ()=>ContractFactory);
var _abi = require("@ethersproject/abi");
var _abstractProvider = require("@ethersproject/abstract-provider");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _transactions = require("@ethersproject/transactions");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
///////////////////////////////
const allowedTransactionKeys = {
    chainId: true,
    data: true,
    from: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true,
    customData: true,
    ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
    return __awaiter(this, void 0, void 0, function*() {
        const name = yield nameOrPromise;
        if (typeof name !== "string") logger.throwArgumentError("invalid address or ENS name", "name", name);
        // If it is already an address, just use it (after adding checksum)
        try {
            return (0, _address.getAddress)(name);
        } catch (error) {}
        if (!resolver) logger.throwError("a provider or signer is needed to resolve ENS names", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName"
        });
        const address = yield resolver.resolveName(name);
        if (address == null) logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
        return address;
    });
}
// Recursively replaces ENS names with promises to resolve the name and resolves all properties
function resolveAddresses(resolver, value, paramType) {
    return __awaiter(this, void 0, void 0, function*() {
        if (Array.isArray(paramType)) return yield Promise.all(paramType.map((paramType, index)=>{
            return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);
        }));
        if (paramType.type === "address") return yield resolveName(resolver, value);
        if (paramType.type === "tuple") return yield resolveAddresses(resolver, value, paramType.components);
        if (paramType.baseType === "array") {
            if (!Array.isArray(value)) return Promise.reject(logger.makeError("invalid value for array", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "value",
                value
            }));
            return yield Promise.all(value.map((v)=>resolveAddresses(resolver, v, paramType.arrayChildren)));
        }
        return value;
    });
}
function populateTransaction(contract, fragment, args) {
    return __awaiter(this, void 0, void 0, function*() {
        // If an extra argument is given, it is overrides
        let overrides = {};
        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") overrides = (0, _properties.shallowCopy)(args.pop());
        // Make sure the parameter count matches
        logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
        // Populate "from" override (allow promises)
        if (contract.signer) {
            if (overrides.from) // Contracts with a Signer are from the Signer's frame-of-reference;
            // but we allow overriding "from" if it matches the signer
            overrides.from = (0, _properties.resolveProperties)({
                override: resolveName(contract.signer, overrides.from),
                signer: contract.signer.getAddress()
            }).then((check)=>__awaiter(this, void 0, void 0, function*() {
                    if ((0, _address.getAddress)(check.signer) !== check.override) logger.throwError("Contract with a Signer cannot override from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                        operation: "overrides.from"
                    });
                    return check.override;
                }));
            else overrides.from = contract.signer.getAddress();
        } else if (overrides.from) overrides.from = resolveName(contract.provider, overrides.from);
        // Wait for all dependencies to be resolved (prefer the signer over the provider)
        const resolved = yield (0, _properties.resolveProperties)({
            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
            address: contract.resolvedAddress,
            overrides: (0, _properties.resolveProperties)(overrides) || {}
        });
        // The ABI coded transaction
        const data = contract.interface.encodeFunctionData(fragment, resolved.args);
        const tx = {
            data: data,
            to: resolved.address
        };
        // Resolved Overrides
        const ro = resolved.overrides;
        // Populate simple overrides
        if (ro.nonce != null) tx.nonce = (0, _bignumber.BigNumber).from(ro.nonce).toNumber();
        if (ro.gasLimit != null) tx.gasLimit = (0, _bignumber.BigNumber).from(ro.gasLimit);
        if (ro.gasPrice != null) tx.gasPrice = (0, _bignumber.BigNumber).from(ro.gasPrice);
        if (ro.maxFeePerGas != null) tx.maxFeePerGas = (0, _bignumber.BigNumber).from(ro.maxFeePerGas);
        if (ro.maxPriorityFeePerGas != null) tx.maxPriorityFeePerGas = (0, _bignumber.BigNumber).from(ro.maxPriorityFeePerGas);
        if (ro.from != null) tx.from = ro.from;
        if (ro.type != null) tx.type = ro.type;
        if (ro.accessList != null) tx.accessList = (0, _transactions.accessListify)(ro.accessList);
        // If there was no "gasLimit" override, but the ABI specifies a default, use it
        if (tx.gasLimit == null && fragment.gas != null) {
            // Compute the intrinsic gas cost for this transaction
            // @TODO: This is based on the yellow paper as of Petersburg; this is something
            // we may wish to parameterize in v6 as part of the Network object. Since this
            // is always a non-nil to address, we can ignore G_create, but may wish to add
            // similar logic to the ContractFactory.
            let intrinsic = 21000;
            const bytes = (0, _bytes.arrayify)(data);
            for(let i = 0; i < bytes.length; i++){
                intrinsic += 4;
                if (bytes[i]) intrinsic += 64;
            }
            tx.gasLimit = (0, _bignumber.BigNumber).from(fragment.gas).add(intrinsic);
        }
        // Populate "value" override
        if (ro.value) {
            const roValue = (0, _bignumber.BigNumber).from(ro.value);
            if (!roValue.isZero() && !fragment.payable) logger.throwError("non-payable method cannot override value", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.value",
                value: overrides.value
            });
            tx.value = roValue;
        }
        if (ro.customData) tx.customData = (0, _properties.shallowCopy)(ro.customData);
        if (ro.ccipReadEnabled) tx.ccipReadEnabled = !!ro.ccipReadEnabled;
        // Remove the overrides
        delete overrides.nonce;
        delete overrides.gasLimit;
        delete overrides.gasPrice;
        delete overrides.from;
        delete overrides.value;
        delete overrides.type;
        delete overrides.accessList;
        delete overrides.maxFeePerGas;
        delete overrides.maxPriorityFeePerGas;
        delete overrides.customData;
        delete overrides.ccipReadEnabled;
        // Make sure there are no stray overrides, which may indicate a
        // typo or using an unsupported key.
        const leftovers = Object.keys(overrides).filter((key)=>overrides[key] != null);
        if (leftovers.length) logger.throwError(`cannot override ${leftovers.map((l)=>JSON.stringify(l)).join(",")}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "overrides",
            overrides: leftovers
        });
        return tx;
    });
}
function buildPopulate(contract, fragment) {
    return function(...args) {
        return populateTransaction(contract, fragment, args);
    };
}
function buildEstimate(contract, fragment) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!signerOrProvider) logger.throwError("estimate require a provider or signer", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "estimateGas"
            });
            const tx = yield populateTransaction(contract, fragment, args);
            return yield signerOrProvider.estimateGas(tx);
        });
    };
}
function addContractWait(contract, tx) {
    const wait = tx.wait.bind(tx);
    tx.wait = (confirmations)=>{
        return wait(confirmations).then((receipt)=>{
            receipt.events = receipt.logs.map((log)=>{
                let event = (0, _properties.deepCopy)(log);
                let parsed = null;
                try {
                    parsed = contract.interface.parseLog(log);
                } catch (e) {}
                // Successfully parsed the event log; include it
                if (parsed) {
                    event.args = parsed.args;
                    event.decode = (data, topics)=>{
                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
                    };
                    event.event = parsed.name;
                    event.eventSignature = parsed.signature;
                }
                // Useful operations
                event.removeListener = ()=>{
                    return contract.provider;
                };
                event.getBlock = ()=>{
                    return contract.provider.getBlock(receipt.blockHash);
                };
                event.getTransaction = ()=>{
                    return contract.provider.getTransaction(receipt.transactionHash);
                };
                event.getTransactionReceipt = ()=>{
                    return Promise.resolve(receipt);
                };
                return event;
            });
            return receipt;
        });
    };
}
function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            // Extract the "blockTag" override if present
            let blockTag = undefined;
            if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
                const overrides = (0, _properties.shallowCopy)(args.pop());
                if (overrides.blockTag != null) blockTag = yield overrides.blockTag;
                delete overrides.blockTag;
                args.push(overrides);
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) yield contract._deployed(blockTag);
            // Call a node and get the result
            const tx = yield populateTransaction(contract, fragment, args);
            const result = yield signerOrProvider.call(tx, blockTag);
            try {
                let value = contract.interface.decodeFunctionResult(fragment, result);
                if (collapseSimple && fragment.outputs.length === 1) value = value[0];
                return value;
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) {
                    error.address = contract.address;
                    error.args = args;
                    error.transaction = tx;
                }
                throw error;
            }
        });
    };
}
function buildSend(contract, fragment) {
    return function(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!contract.signer) logger.throwError("sending a transaction requires a signer", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "sendTransaction"
            });
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) yield contract._deployed();
            const txRequest = yield populateTransaction(contract, fragment, args);
            const tx = yield contract.signer.sendTransaction(txRequest);
            // Tweak the tx.wait so the receipt has extra properties
            addContractWait(contract, tx);
            return tx;
        });
    };
}
function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) return buildCall(contract, fragment, collapseSimple);
    return buildSend(contract, fragment);
}
function getEventTag(filter) {
    if (filter.address && (filter.topics == null || filter.topics.length === 0)) return "*";
    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic)=>{
        if (Array.isArray(topic)) return topic.join("|");
        return topic;
    }).join(":") : "");
}
class RunningEvent {
    constructor(tag, filter){
        (0, _properties.defineReadOnly)(this, "tag", tag);
        (0, _properties.defineReadOnly)(this, "filter", filter);
        this._listeners = [];
    }
    addListener(listener, once) {
        this._listeners.push({
            listener: listener,
            once: once
        });
    }
    removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item)=>{
            if (done || item.listener !== listener) return true;
            done = true;
            return false;
        });
    }
    removeAllListeners() {
        this._listeners = [];
    }
    listeners() {
        return this._listeners.map((i)=>i.listener);
    }
    listenerCount() {
        return this._listeners.length;
    }
    run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item)=>{
            const argsCopy = args.slice();
            // Call the callback in the next event loop
            setTimeout(()=>{
                item.listener.apply(this, argsCopy);
            }, 0);
            // Reschedule it if it not "once"
            return !item.once;
        });
        return listenerCount;
    }
    prepareEvent(event) {}
    // Returns the array that will be applied to an emit
    getEmit(event) {
        return [
            event
        ];
    }
}
class ErrorRunningEvent extends RunningEvent {
    constructor(){
        super("error", null);
    }
}
// @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting
class FragmentRunningEvent extends RunningEvent {
    constructor(address, contractInterface, fragment, topics){
        const filter = {
            address: address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
            if (topic !== topics[0]) logger.throwArgumentError("topic mismatch", "topics", topics);
            filter.topics = topics.slice();
        } else filter.topics = [
            topic
        ];
        super(getEventTag(filter), filter);
        (0, _properties.defineReadOnly)(this, "address", address);
        (0, _properties.defineReadOnly)(this, "interface", contractInterface);
        (0, _properties.defineReadOnly)(this, "fragment", fragment);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics)=>{
            return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
            event.args = null;
            event.decodeError = error;
        }
    }
    getEmit(event) {
        const errors = (0, _abi.checkResultErrors)(event.args);
        if (errors.length) throw errors[0].error;
        const args = (event.args || []).slice();
        args.push(event);
        return args;
    }
}
// A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics
class WildcardRunningEvent extends RunningEvent {
    constructor(address, contractInterface){
        super("*", {
            address: address
        });
        (0, _properties.defineReadOnly)(this, "address", address);
        (0, _properties.defineReadOnly)(this, "interface", contractInterface);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        try {
            const parsed = this.interface.parseLog(event);
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
            event.decode = (data, topics)=>{
                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
            };
            event.args = parsed.args;
        } catch (error) {
        // No matching event
        }
    }
}
class BaseContract {
    constructor(addressOrName, contractInterface, signerOrProvider){
        // @TODO: Maybe still check the addressOrName looks like a valid address or name?
        //address = getAddress(address);
        (0, _properties.defineReadOnly)(this, "interface", (0, _properties.getStatic)(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
            (0, _properties.defineReadOnly)(this, "provider", null);
            (0, _properties.defineReadOnly)(this, "signer", null);
        } else if ((0, _abstractSigner.Signer).isSigner(signerOrProvider)) {
            (0, _properties.defineReadOnly)(this, "provider", signerOrProvider.provider || null);
            (0, _properties.defineReadOnly)(this, "signer", signerOrProvider);
        } else if ((0, _abstractProvider.Provider).isProvider(signerOrProvider)) {
            (0, _properties.defineReadOnly)(this, "provider", signerOrProvider);
            (0, _properties.defineReadOnly)(this, "signer", null);
        } else logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        (0, _properties.defineReadOnly)(this, "callStatic", {});
        (0, _properties.defineReadOnly)(this, "estimateGas", {});
        (0, _properties.defineReadOnly)(this, "functions", {});
        (0, _properties.defineReadOnly)(this, "populateTransaction", {});
        (0, _properties.defineReadOnly)(this, "filters", {});
        {
            const uniqueFilters = {};
            Object.keys(this.interface.events).forEach((eventSignature)=>{
                const event = this.interface.events[eventSignature];
                (0, _properties.defineReadOnly)(this.filters, eventSignature, (...args)=>{
                    return {
                        address: this.address,
                        topics: this.interface.encodeFilterTopics(event, args)
                    };
                });
                if (!uniqueFilters[event.name]) uniqueFilters[event.name] = [];
                uniqueFilters[event.name].push(eventSignature);
            });
            Object.keys(uniqueFilters).forEach((name)=>{
                const filters = uniqueFilters[name];
                if (filters.length === 1) (0, _properties.defineReadOnly)(this.filters, name, this.filters[filters[0]]);
                else logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
            });
        }
        (0, _properties.defineReadOnly)(this, "_runningEvents", {});
        (0, _properties.defineReadOnly)(this, "_wrappedEmits", {});
        if (addressOrName == null) logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        (0, _properties.defineReadOnly)(this, "address", addressOrName);
        if (this.provider) (0, _properties.defineReadOnly)(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        else try {
            (0, _properties.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0, _address.getAddress)(addressOrName)));
        } catch (error) {
            // Without a provider, we cannot use ENS names
            logger.throwError("provider is required to use ENS name as contract address", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "new Contract"
            });
        }
        // Swallow bad ENS names to prevent Unhandled Exceptions
        this.resolvedAddress.catch((e)=>{});
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature)=>{
            const fragment = this.interface.functions[signature];
            // Check that the signature is unique; if not the ABI generation has
            // not been cleaned or may be incorrectly generated
            if (uniqueSignatures[signature]) {
                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
                return;
            }
            uniqueSignatures[signature] = true;
            // Track unique names; we only expose bare named functions if they
            // are ambiguous
            {
                const name = fragment.name;
                if (!uniqueNames[`%${name}`]) uniqueNames[`%${name}`] = [];
                uniqueNames[`%${name}`].push(signature);
            }
            if (this[signature] == null) (0, _properties.defineReadOnly)(this, signature, buildDefault(this, fragment, true));
            // We do not collapse simple calls on this bucket, which allows
            // frameworks to safely use this without introspection as well as
            // allows decoding error recovery.
            if (this.functions[signature] == null) (0, _properties.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));
            if (this.callStatic[signature] == null) (0, _properties.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));
            if (this.populateTransaction[signature] == null) (0, _properties.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));
            if (this.estimateGas[signature] == null) (0, _properties.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));
        });
        Object.keys(uniqueNames).forEach((name)=>{
            // Ambiguous names to not get attached as bare names
            const signatures = uniqueNames[name];
            if (signatures.length > 1) return;
            // Strip off the leading "%" used for prototype protection
            name = name.substring(1);
            const signature = signatures[0];
            // If overwriting a member property that is null, swallow the error
            try {
                if (this[name] == null) (0, _properties.defineReadOnly)(this, name, this[signature]);
            } catch (e) {}
            if (this.functions[name] == null) (0, _properties.defineReadOnly)(this.functions, name, this.functions[signature]);
            if (this.callStatic[name] == null) (0, _properties.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);
            if (this.populateTransaction[name] == null) (0, _properties.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);
            if (this.estimateGas[name] == null) (0, _properties.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);
        });
    }
    static getContractAddress(transaction) {
        return (0, _address.getContractAddress)(transaction);
    }
    static getInterface(contractInterface) {
        if ((0, _abi.Interface).isInterface(contractInterface)) return contractInterface;
        return new (0, _abi.Interface)(contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
        return this._deployed();
    }
    _deployed(blockTag) {
        if (!this._deployedPromise) {
            // If we were just deployed, we know the transaction we should occur in
            if (this.deployTransaction) this._deployedPromise = this.deployTransaction.wait().then(()=>{
                return this;
            });
            else // @TODO: Once we allow a timeout to be passed in, we will wait
            // up to that many blocks for getCode
            // Otherwise, poll for our code to be deployed
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code)=>{
                if (code === "0x") logger.throwError("contract not deployed", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                    contractAddress: this.address,
                    operation: "getDeployed"
                });
                return this;
            });
        }
        return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
        if (!this.signer) logger.throwError("sending a transactions require a signer", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction(fallback)"
        });
        const tx = (0, _properties.shallowCopy)(overrides || {});
        [
            "from",
            "to"
        ].forEach(function(key) {
            if (tx[key] == null) return;
            logger.throwError("cannot override " + key, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: key
            });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(()=>{
            return this.signer.sendTransaction(tx);
        });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
        if (typeof signerOrProvider === "string") signerOrProvider = new (0, _abstractSigner.VoidSigner)(signerOrProvider, this.provider);
        const contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) (0, _properties.defineReadOnly)(contract, "deployTransaction", this.deployTransaction);
        return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
        return (0, _abi.Indexed).isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
        // Already have an instance of this event running; we can re-use it
        if (this._runningEvents[runningEvent.tag]) return this._runningEvents[runningEvent.tag];
        return runningEvent;
    }
    _getRunningEvent(eventName) {
        if (typeof eventName === "string") {
            // Listen for "error" events (if your contract has an error event, include
            // the full signature to bypass this special event keyword)
            if (eventName === "error") return this._normalizeRunningEvent(new ErrorRunningEvent());
            // Listen for any event that is registered
            if (eventName === "event") return this._normalizeRunningEvent(new RunningEvent("event", null));
            // Listen for any event
            if (eventName === "*") return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
            // Get the event Fragment (throws if ambiguous/unknown event)
            const fragment = this.interface.getEvent(eventName);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        // We have topics to filter by...
        if (eventName.topics && eventName.topics.length > 0) {
            // Is it a known topichash? (throws if no matching topichash)
            try {
                const topic = eventName.topics[0];
                if (typeof topic !== "string") throw new Error("invalid topic"); // @TODO: May happen for anonymous events
                const fragment = this.interface.getEvent(topic);
                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
            } catch (error) {}
            // Filter by the unknown topichash
            const filter = {
                address: this.address,
                topics: eventName.topics
            };
            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
            delete this._runningEvents[runningEvent.tag];
            // If we have a poller for this, remove it
            const emit = this._wrappedEmits[runningEvent.tag];
            if (emit && runningEvent.filter) {
                this.provider.off(runningEvent.filter, emit);
                delete this._wrappedEmits[runningEvent.tag];
            }
        }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
        const event = (0, _properties.deepCopy)(log);
        event.removeListener = ()=>{
            if (!listener) return;
            runningEvent.removeListener(listener);
            this._checkRunningEvents(runningEvent);
        };
        event.getBlock = ()=>{
            return this.provider.getBlock(log.blockHash);
        };
        event.getTransaction = ()=>{
            return this.provider.getTransaction(log.transactionHash);
        };
        event.getTransactionReceipt = ()=>{
            return this.provider.getTransactionReceipt(log.transactionHash);
        };
        // This may throw if the topics and data mismatch the signature
        runningEvent.prepareEvent(event);
        return event;
    }
    _addEventListener(runningEvent, listener, once) {
        if (!this.provider) logger.throwError("events require a provider or a signer with a provider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "once"
        });
        runningEvent.addListener(listener, once);
        // Track this running event and its listeners (may already be there; but no hard in updating)
        this._runningEvents[runningEvent.tag] = runningEvent;
        // If we are not polling the provider, start polling
        if (!this._wrappedEmits[runningEvent.tag]) {
            const wrappedEmit = (log)=>{
                let event = this._wrapEvent(runningEvent, log, listener);
                // Try to emit the result for the parameterized event...
                if (event.decodeError == null) try {
                    const args = runningEvent.getEmit(event);
                    this.emit(runningEvent.filter, ...args);
                } catch (error) {
                    event.decodeError = error.error;
                }
                // Always emit "event" for fragment-base events
                if (runningEvent.filter != null) this.emit("event", event);
                // Emit "error" if there was an error
                if (event.decodeError != null) this.emit("error", event.decodeError, event);
            };
            this._wrappedEmits[runningEvent.tag] = wrappedEmit;
            // Special events, like "error" do not have a filter
            if (runningEvent.filter != null) this.provider.on(runningEvent.filter, wrappedEmit);
        }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = (0, _properties.shallowCopy)(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && (0, _bytes.isHexString)(fromBlockOrBlockhash, 32)) {
            if (toBlock != null) logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
            filter.blockHash = fromBlockOrBlockhash;
        } else {
            filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
            filter.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter).then((logs)=>{
            return logs.map((log)=>this._wrapEvent(runningEvent, log, null));
        });
    }
    on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
    }
    once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
    }
    emit(eventName, ...args) {
        if (!this.provider) return false;
        const runningEvent = this._getRunningEvent(eventName);
        const result = runningEvent.run(args) > 0;
        // May have drained all the "once" events; check for living events
        this._checkRunningEvents(runningEvent);
        return result;
    }
    listenerCount(eventName) {
        if (!this.provider) return 0;
        if (eventName == null) return Object.keys(this._runningEvents).reduce((accum, key)=>{
            return accum + this._runningEvents[key].listenerCount();
        }, 0);
        return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
        if (!this.provider) return [];
        if (eventName == null) {
            const result = [];
            for(let tag in this._runningEvents)this._runningEvents[tag].listeners().forEach((listener)=>{
                result.push(listener);
            });
            return result;
        }
        return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
        if (!this.provider) return this;
        if (eventName == null) {
            for(const tag in this._runningEvents){
                const runningEvent = this._runningEvents[tag];
                runningEvent.removeAllListeners();
                this._checkRunningEvents(runningEvent);
            }
            return this;
        }
        // Delete any listeners
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
    }
    off(eventName, listener) {
        if (!this.provider) return this;
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
    }
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
}
class Contract extends BaseContract {
}
class ContractFactory {
    constructor(contractInterface, bytecode, signer){
        let bytecodeHex = null;
        if (typeof bytecode === "string") bytecodeHex = bytecode;
        else if ((0, _bytes.isBytes)(bytecode)) bytecodeHex = (0, _bytes.hexlify)(bytecode);
        else if (bytecode && typeof bytecode.object === "string") // Allow the bytecode object from the Solidity compiler
        bytecodeHex = bytecode.object;
        else // Crash in the next verification step
        bytecodeHex = "!";
        // Make sure it is 0x prefixed
        if (bytecodeHex.substring(0, 2) !== "0x") bytecodeHex = "0x" + bytecodeHex;
        // Make sure the final result is valid bytecode
        if (!(0, _bytes.isHexString)(bytecodeHex) || bytecodeHex.length % 2) logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        // If we have a signer, make sure it is valid
        if (signer && !(0, _abstractSigner.Signer).isSigner(signer)) logger.throwArgumentError("invalid signer", "signer", signer);
        (0, _properties.defineReadOnly)(this, "bytecode", bytecodeHex);
        (0, _properties.defineReadOnly)(this, "interface", (0, _properties.getStatic)(new.target, "getInterface")(contractInterface));
        (0, _properties.defineReadOnly)(this, "signer", signer || null);
    }
    // @TODO: Future; rename to populateTransaction?
    getDeployTransaction(...args) {
        let tx = {};
        // If we have 1 additional argument, we allow transaction overrides
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
            tx = (0, _properties.shallowCopy)(args.pop());
            for(const key in tx){
                if (!allowedTransactionKeys[key]) throw new Error("unknown transaction override " + key);
            }
        }
        // Do not allow these to be overridden in a deployment transaction
        [
            "data",
            "from",
            "to"
        ].forEach((key)=>{
            if (tx[key] == null) return;
            logger.throwError("cannot override " + key, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: key
            });
        });
        if (tx.value) {
            const value = (0, _bignumber.BigNumber).from(tx.value);
            if (!value.isZero() && !this.interface.deploy.payable) logger.throwError("non-payable constructor cannot override value", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.value",
                value: tx.value
            });
        }
        // Make sure the call matches the constructor signature
        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        // Set the data to the bytecode + the encoded constructor arguments
        tx.data = (0, _bytes.hexlify)((0, _bytes.concat)([
            this.bytecode,
            this.interface.encodeDeploy(args)
        ]));
        return tx;
    }
    deploy(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            let overrides = {};
            // If 1 extra parameter was passed in, it contains overrides
            if (args.length === this.interface.deploy.inputs.length + 1) overrides = args.pop();
            // Make sure the call matches the constructor signature
            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
            // Resolve ENS names and promises in the arguments
            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
            params.push(overrides);
            // Get the deployment transaction (with optional overrides)
            const unsignedTx = this.getDeployTransaction(...params);
            // Send the deployment transaction
            const tx = yield this.signer.sendTransaction(unsignedTx);
            const address = (0, _properties.getStatic)(this.constructor, "getContractAddress")(tx);
            const contract = (0, _properties.getStatic)(this.constructor, "getContract")(address, this.interface, this.signer);
            // Add the modified wait that wraps events
            addContractWait(contract, tx);
            (0, _properties.defineReadOnly)(contract, "deployTransaction", tx);
            return contract;
        });
    }
    attach(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
    }
    connect(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
    }
    static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) logger.throwError("missing compiler output", (0, _logger.Logger).errors.MISSING_ARGUMENT, {
            argument: "compilerOutput"
        });
        if (typeof compilerOutput === "string") compilerOutput = JSON.parse(compilerOutput);
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) bytecode = compilerOutput.bytecode;
        else if (compilerOutput.evm && compilerOutput.evm.bytecode) bytecode = compilerOutput.evm.bytecode;
        return new this(abi, bytecode, signer);
    }
    static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
    }
    static getContractAddress(tx) {
        return (0, _address.getContractAddress)(tx);
    }
    static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
    }
}

},{"@ethersproject/abi":"fYeCq","@ethersproject/abstract-provider":"g1jr1","@ethersproject/abstract-signer":"g9Ey5","@ethersproject/address":"ggdAz","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@ethersproject/transactions":"d1ust","@ethersproject/logger":"hLvB2","./_version":"6ewae","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fYeCq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConstructorFragment", ()=>(0, _fragments.ConstructorFragment));
parcelHelpers.export(exports, "ErrorFragment", ()=>(0, _fragments.ErrorFragment));
parcelHelpers.export(exports, "EventFragment", ()=>(0, _fragments.EventFragment));
parcelHelpers.export(exports, "Fragment", ()=>(0, _fragments.Fragment));
parcelHelpers.export(exports, "FunctionFragment", ()=>(0, _fragments.FunctionFragment));
parcelHelpers.export(exports, "ParamType", ()=>(0, _fragments.ParamType));
parcelHelpers.export(exports, "FormatTypes", ()=>(0, _fragments.FormatTypes));
parcelHelpers.export(exports, "AbiCoder", ()=>(0, _abiCoder.AbiCoder));
parcelHelpers.export(exports, "defaultAbiCoder", ()=>(0, _abiCoder.defaultAbiCoder));
parcelHelpers.export(exports, "Interface", ()=>(0, _interface.Interface));
parcelHelpers.export(exports, "Indexed", ()=>(0, _interface.Indexed));
parcelHelpers.export(exports, "checkResultErrors", ()=>(0, _interface.checkResultErrors));
parcelHelpers.export(exports, "LogDescription", ()=>(0, _interface.LogDescription));
parcelHelpers.export(exports, "TransactionDescription", ()=>(0, _interface.TransactionDescription));
var _fragments = require("./fragments");
var _abiCoder = require("./abi-coder");
var _interface = require("./interface");
"use strict";

},{"./fragments":"jvsHr","./abi-coder":"4pw2B","./interface":"8nE5c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jvsHr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FormatTypes", ()=>FormatTypes);
parcelHelpers.export(exports, "ParamType", ()=>ParamType);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "EventFragment", ()=>EventFragment);
parcelHelpers.export(exports, "ConstructorFragment", ()=>ConstructorFragment);
parcelHelpers.export(exports, "FunctionFragment", ()=>FunctionFragment);
parcelHelpers.export(exports, "ErrorFragment", ()=>ErrorFragment);
var _bignumber = require("@ethersproject/bignumber");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const _constructorGuard = {};
let ModifiersBytes = {
    calldata: true,
    memory: true,
    storage: true
};
let ModifiersNest = {
    calldata: true,
    memory: true
};
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) return true;
    } else if (type === "address") {
        if (name === "payable") return true;
    } else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) return true;
    }
    if (ModifiersBytes[name] || name === "payable") logger.throwArgumentError("invalid modifier", "name", name);
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = {
            type: "",
            name: "",
            parent: parent,
            state: {
                allowType: true
            }
        };
        if (allowIndexed) node.indexed = false;
        return node;
    }
    let parent = {
        type: "",
        name: "",
        state: {
            allowType: true
        }
    };
    let node = parent;
    for(let i = 0; i < param.length; i++){
        let c = param[i];
        switch(c){
            case "(":
                if (node.state.allowType && node.type === "") node.type = "tuple";
                else if (!node.state.allowParams) throwError(i);
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [
                    newNode(node)
                ];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) throwError(i);
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) node.name = "";
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) throwError(i);
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) throwError(i);
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) node.name = "";
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) throwError(i);
                            if (node.indexed) throwError(i);
                            node.indexed = true;
                            node.name = "";
                        } else if (checkModifier(node.type, node.name)) node.name = "";
                        else node.state.allowName = false;
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) throwError(i);
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) throwError(i);
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                } else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                } else if (node.state.readArray) node.type += c;
                else throwError(i);
        }
    }
    if (node.parent) logger.throwArgumentError("unexpected eof", "param", param);
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) throwError(originalParam.length - 7);
        if (node.indexed) throwError(originalParam.length - 7);
        node.indexed = true;
        node.name = "";
    } else if (checkModifier(node.type, node.name)) node.name = "";
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for(let key in params)(0, _properties.defineReadOnly)(object, key, params[key]);
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params){
        if (constructorGuard !== _constructorGuard) logger.throwError("use fromString", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
        });
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: ParamType.fromObject({
                type: match[1],
                components: this.components
            }),
            baseType: "array"
        });
        else populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
        });
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) {
            let result = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: this.name || undefined
            };
            if (typeof this.indexed === "boolean") result.indexed = this.indexed;
            if (this.components) result.components = this.components.map((comp)=>JSON.parse(comp.format(format)));
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) result += this.type;
            result += "(" + this.components.map((comp)=>comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
        } else result += this.type;
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) result += " indexed";
            if (format === FormatTypes.full && this.name) result += " " + this.name;
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof value === "string") return ParamType.fromString(value, allowIndexed);
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) return value;
        return new ParamType(_constructorGuard, {
            name: value.name || null,
            type: verifyType(value.type),
            indexed: value.indexed == null ? null : !!value.indexed,
            components: value.components ? value.components.map(ParamType.fromObject) : null
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param)=>ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params){
        if (constructorGuard !== _constructorGuard) logger.throwError("use a static from method", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
        });
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) return value;
        if (typeof value === "string") return Fragment.fromString(value);
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) return value;
        switch(value.type){
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") return EventFragment.fromString(value.substring(5).trim());
        else if (value.split(" ")[0] === "function") return FunctionFragment.fromString(value.substring(8).trim());
        else if (value.split("(")[0].trim() === "constructor") return ConstructorFragment.fromString(value.trim());
        else if (value.split(" ")[0] === "error") return ErrorFragment.fromString(value.substring(5).trim());
        return logger.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))
        });
        let result = "";
        if (format !== FormatTypes.sighash) result += "event ";
        result += this.name + "(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) result += "anonymous ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return EventFragment.fromString(value);
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) return value;
        if (value.type !== "event") logger.throwArgumentError("invalid event object", "value", value);
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) logger.throwArgumentError("invalid event string", "value", value);
        let anonymous = false;
        match[3].split(" ").forEach((modifier)=>{
            switch(modifier.trim()){
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return value && value._isFragment && value.type === "event";
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
        if (!comps[1].match(/^[0-9]+$/)) logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        params.gas = (0, _bignumber.BigNumber).from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier)=>{
        switch(modifier.trim()){
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
        if (value.constant != null) {
            if (!!value.constant !== result.constant) logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
        }
        // Set (and check things are consistent) the payable property
        result.payable = result.stateMutability === "payable";
        if (value.payable != null) {
            if (!!value.payable !== result.payable) logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
        }
    } else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") logger.throwArgumentError("unable to determine stateMutability", "value", value);
        result.constant = !!value.constant;
        if (result.constant) result.stateMutability = "view";
        else result.stateMutability = result.payable ? "payable" : "nonpayable";
        if (result.payable && result.constant) logger.throwArgumentError("cannot have constant payable function", "value", value);
    } else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = result.constant ? "view" : "payable";
    } else if (value.type !== "constructor") logger.throwArgumentError("unable to determine stateMutability", "value", value);
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : undefined,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))
        });
        if (format === FormatTypes.sighash) logger.throwError("cannot format a constructor for sighash", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
        });
        let result = "constructor(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") result += this.stateMutability + " ";
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return ConstructorFragment.fromString(value);
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) return value;
        if (value.type !== "constructor") logger.throwArgumentError("invalid constructor object", "value", value);
        let state = verifyState(value);
        if (state.constant) logger.throwArgumentError("constructor cannot be constant", "value", value);
        const params = {
            name: null,
            type: value.type,
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: value.gas ? (0, _bignumber.BigNumber).from(value.gas) : null
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = {
            type: "constructor"
        };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") logger.throwArgumentError("invalid constructor string", "value", value);
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return value && value._isFragment && value.type === "constructor";
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : undefined,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format))),
            outputs: this.outputs.map((output)=>JSON.parse(output.format(format)))
        });
        let result = "";
        if (format !== FormatTypes.sighash) result += "function ";
        result += this.name + "(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") result += this.stateMutability + " ";
            } else if (this.constant) result += "view ";
            if (this.outputs && this.outputs.length) result += "returns (" + this.outputs.map((output)=>output.format(format)).join(", ") + ") ";
            if (this.gas != null) result += "@" + this.gas.toString() + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return FunctionFragment.fromString(value);
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) return value;
        if (value.type !== "function") logger.throwArgumentError("invalid function object", "value", value);
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
            outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: value.gas ? (0, _bignumber.BigNumber).from(value.gas) : null
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = {
            type: "function"
        };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) logger.throwArgumentError("invalid function string", "value", value);
        let parens = comps[0].match(regexParen);
        if (!parens) logger.throwArgumentError("invalid function signature", "value", value);
        params.name = parens[1].trim();
        if (params.name) verifyIdentifier(params.name);
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") logger.throwArgumentError("unexpected tokens", "value", value);
            params.outputs = parseParams(returns[2], false);
        } else params.outputs = [];
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return value && value._isFragment && value.type === "function";
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") logger.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))
        });
        let result = "";
        if (format !== FormatTypes.sighash) result += "error ";
        result += this.name + "(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return ErrorFragment.fromString(value);
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) return value;
        if (value.type !== "error") logger.throwArgumentError("invalid error object", "value", value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = {
            type: "error"
        };
        let parens = value.match(regexParen);
        if (!parens) logger.throwArgumentError("invalid error signature", "value", value);
        params.name = parens[1].trim();
        if (params.name) verifyIdentifier(params.name);
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return value && value._isFragment && value.type === "error";
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) type = "uint256" + type.substring(4);
    else if (type.match(/^int($|[^1-9])/)) type = "int256" + type.substring(3);
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) logger.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for(let offset = 0; offset < value.length; offset++){
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        } else {
            accum += c;
            if (c === "(") depth++;
            else if (c === ")") {
                depth--;
                if (depth === -1) logger.throwArgumentError("unbalanced parenthesis", "value", value);
            }
        }
    }
    if (accum) result.push(accum);
    return result;
}

},{"@ethersproject/bignumber":"ckYYW","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"9uxOS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ckYYW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BigNumber", ()=>(0, _bignumber.BigNumber));
parcelHelpers.export(exports, "formatFixed", ()=>(0, _fixednumber.formatFixed));
parcelHelpers.export(exports, "FixedFormat", ()=>(0, _fixednumber.FixedFormat));
parcelHelpers.export(exports, "FixedNumber", ()=>(0, _fixednumber.FixedNumber));
parcelHelpers.export(exports, "parseFixed", ()=>(0, _fixednumber.parseFixed));
// Internal methods used by address
parcelHelpers.export(exports, "_base16To36", ()=>(0, _bignumber._base16To36));
parcelHelpers.export(exports, "_base36To16", ()=>(0, _bignumber._base36To16));
var _bignumber = require("./bignumber");
var _fixednumber = require("./fixednumber");

},{"./bignumber":"eCYd8","./fixednumber":"4kqiW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCYd8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBigNumberish", ()=>isBigNumberish);
parcelHelpers.export(exports, "BigNumber", ()=>BigNumber);
// value should have no prefix
parcelHelpers.export(exports, "_base36To16", ()=>_base36To16);
// value should have no prefix
parcelHelpers.export(exports, "_base16To36", ()=>_base16To36);
/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */ var _bnJs = require("bn.js");
var _bnJsDefault = parcelHelpers.interopDefault(_bnJs);
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var BN = (0, _bnJsDefault.default).BN;
const logger = new (0, _logger.Logger)((0, _version.version));
const _constructorGuard = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, _bytes.isHexString)(value) || typeof value === "bigint" || (0, _bytes.isBytes)(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex){
        if (constructorGuard !== _constructorGuard) logger.throwError("cannot call constructor directly; use BigNumber.from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        });
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") return BigNumber.from(this._hex.substring(1));
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) throwFault("division-by-zero", "div");
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) throwFault("division-by-zero", "mod");
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) throwFault("negative-power", "pow");
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) throwFault("unbound-bitwise-result", "and");
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) throwFault("unbound-bitwise-result", "or");
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) throwFault("unbound-bitwise-result", "xor");
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) throwFault("negative-width", "mask");
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) throwFault("negative-width", "shl");
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) throwFault("negative-width", "shr");
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return this._hex[0] === "-";
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        } catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        } catch (e) {}
        return logger.throwError("this platform does not support BigInt", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            } else if (arguments[0] === 16) logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", (0, _logger.Logger).errors.UNEXPECTED_ARGUMENT, {});
            else logger.throwError("BigNumber.toString does not accept parameters", (0, _logger.Logger).errors.UNEXPECTED_ARGUMENT, {});
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        };
    }
    static from(value) {
        if (value instanceof BigNumber) return value;
        if (typeof value === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) return new BigNumber(_constructorGuard, toHex(value));
            if (value.match(/^-?[0-9]+$/)) return new BigNumber(_constructorGuard, toHex(new BN(value)));
            return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
            if (value % 1) throwFault("underflow", "BigNumber.from", value);
            if (value >= MAX_SAFE || value <= -MAX_SAFE) throwFault("overflow", "BigNumber.from", value);
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") return BigNumber.from(anyValue.toString());
        if ((0, _bytes.isBytes)(anyValue)) return BigNumber.from((0, _bytes.hexlify)(anyValue));
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof hex === "string") return BigNumber.from(hex);
            } else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") hex = anyValue.hex;
                if (typeof hex === "string") {
                    if ((0, _bytes.isHexString)(hex) || hex[0] === "-" && (0, _bytes.isHexString)(hex.substring(1))) return BigNumber.from(hex);
                }
            }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof value !== "string") return toHex(value.toString(16));
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") logger.throwArgumentError("invalid hex", "value", value);
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") return value;
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") value = "0x" + value;
    // Normalize zero
    if (value === "0x") return "0x00";
    // Make the string even length
    if (value.length % 2) value = "0x0" + value.substring(2);
    // Trim to smallest even-length string
    while(value.length > 4 && value.substring(0, 4) === "0x00")value = "0x" + value.substring(4);
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") return new BN("-" + hex.substring(3), 16);
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = {
        fault: fault,
        operation: operation
    };
    if (value != null) params.value = value;
    return logger.throwError(fault, (0, _logger.Logger).errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
    return new BN(value, 36).toString(16);
}
function _base16To36(value) {
    return new BN(value, 16).toString(36);
}

},{"bn.js":"VopIn","@ethersproject/bytes":"htrqZ","@ethersproject/logger":"hLvB2","./_version":"gN5k0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"VopIn":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("bd440367abe2ded7").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this._strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) return c - 48;
        else if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else assert(false, "Invalid character in " + string);
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) b = c - 49 + 0xa;
            else if (c >= 17) b = c - 17 + 0xa;
            else b = c;
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this._strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
    } catch (e) {
        BN.prototype.inspect = inspect;
    }
    else BN.prototype.inspect = inspect;
    function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) res[position++] = word >> 8 & 0xff;
            if (position < res.length) res[position++] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position < res.length) res[position++] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length)res[position++] = 0;
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) res[position--] = word >> 8 & 0xff;
            if (position >= 0) res[position--] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position >= 0) res[position--] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0)res[position--] = 0;
        }
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q._strip();
        a._strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is a BN v4 instance
        r.strip();
        else // r is a BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"bd440367abe2ded7":"jhUEF"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"htrqZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBytesLike", ()=>isBytesLike);
parcelHelpers.export(exports, "isBytes", ()=>isBytes);
parcelHelpers.export(exports, "arrayify", ()=>arrayify);
parcelHelpers.export(exports, "concat", ()=>concat);
parcelHelpers.export(exports, "stripZeros", ()=>stripZeros);
parcelHelpers.export(exports, "zeroPad", ()=>zeroPad);
parcelHelpers.export(exports, "isHexString", ()=>isHexString);
parcelHelpers.export(exports, "hexlify", ()=>hexlify);
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/ parcelHelpers.export(exports, "hexDataLength", ()=>hexDataLength);
parcelHelpers.export(exports, "hexDataSlice", ()=>hexDataSlice);
parcelHelpers.export(exports, "hexConcat", ()=>hexConcat);
parcelHelpers.export(exports, "hexValue", ()=>hexValue);
parcelHelpers.export(exports, "hexStripZeros", ()=>hexStripZeros);
parcelHelpers.export(exports, "hexZeroPad", ()=>hexZeroPad);
parcelHelpers.export(exports, "splitSignature", ()=>splitSignature);
parcelHelpers.export(exports, "joinSignature", ()=>joinSignature);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
///////////////////////////////
function isHexable(value) {
    return !!value.toHexString;
}
function addSlice(array) {
    if (array.slice) return array;
    array.slice = function() {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
    return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
    if (value == null) return false;
    if (value.constructor === Uint8Array) return true;
    if (typeof value === "string") return false;
    if (!isInteger(value.length) || value.length < 0) return false;
    for(let i = 0; i < value.length; i++){
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) return false;
    }
    return true;
}
function arrayify(value, options) {
    if (!options) options = {};
    if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while(value){
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) result.push(0);
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") value = "0x" + value;
    if (isHexable(value)) value = value.toHexString();
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") hex = "0" + hex;
            else if (options.hexPad === "right") hex += "0";
            else logger.throwArgumentError("hex data is odd-length", "value", value);
        }
        const result = [];
        for(let i = 0; i < hex.length; i += 2)result.push(parseInt(hex.substring(i, i + 2), 16));
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) return addSlice(new Uint8Array(value));
    return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map((item)=>arrayify(item));
    const length = objects.reduce((accum, item)=>accum + item.length, 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object)=>{
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) return result;
    // Find the first non-zero entry
    let start = 0;
    while(start < result.length && result[start] === 0)start++;
    // If we started with zeros, strip them
    if (start) result = result.slice(start);
    return result;
}
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) logger.throwArgumentError("value out of range", "value", arguments[0]);
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;
    if (length && value.length !== 2 + 2 * length) return false;
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) options = {};
    if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while(value){
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) hex = "0" + hex;
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof value === "bigint") {
        value = value.toString(16);
        if (value.length % 2) return "0x0" + value;
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") value = "0x" + value;
    if (isHexable(value)) return value.toHexString();
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") value = "0x0" + value.substring(2);
            else if (options.hexPad === "right") value += "0";
            else logger.throwArgumentError("hex data is odd-length", "value", value);
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for(let i = 0; i < value.length; i++){
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
    if (typeof data !== "string") data = hexlify(data);
    else if (!isHexString(data) || data.length % 2) return null;
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof data !== "string") data = hexlify(data);
    else if (!isHexString(data) || data.length % 2) logger.throwArgumentError("invalid hexData", "value", data);
    offset = 2 + 2 * offset;
    if (endOffset != null) return "0x" + data.substring(offset, 2 + 2 * endOffset);
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item)=>{
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, {
        hexPad: "left"
    }));
    if (trimmed === "0x") return "0x0";
    return trimmed;
}
function hexStripZeros(value) {
    if (typeof value !== "string") value = hexlify(value);
    if (!isHexString(value)) logger.throwArgumentError("invalid hex string", "value", value);
    value = value.substring(2);
    let offset = 0;
    while(offset < value.length && value[offset] === "0")offset++;
    return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
    if (typeof value !== "string") value = hexlify(value);
    else if (!isHexString(value)) logger.throwArgumentError("invalid hex string", "value", value);
    if (value.length > 2 * length + 2) logger.throwArgumentError("value out of range", "value", arguments[1]);
    while(value.length < 2 * length + 2)value = "0x0" + value.substring(2);
    return value;
}
function splitSignature(signature) {
    const result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (isBytesLike(signature)) {
        let bytes = arrayify(signature);
        // Get the r, s and v
        if (bytes.length === 64) {
            // EIP-2098; pull the v from the top bit of s and clear it
            result.v = 27 + (bytes[32] >> 7);
            bytes[32] &= 0x7f;
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
        } else if (bytes.length === 65) {
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
            result.v = bytes[64];
        } else logger.throwArgumentError("invalid signature string", "signature", signature);
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) result.v += 27;
            else logger.throwArgumentError("signature invalid v byte", "signature", signature);
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - result.v % 2;
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) bytes[32] |= 0x80;
        result._vs = hexlify(bytes.slice(32, 64));
    } else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            const vs = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs);
            // Set or check the recid
            const recoveryParam = vs[0] >= 128 ? 1 : 0;
            if (result.recoveryParam == null) result.recoveryParam = recoveryParam;
            else if (result.recoveryParam !== recoveryParam) logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            // Set or check the s
            vs[0] &= 0x7f;
            const s = hexlify(vs);
            if (result.s == null) result.s = s;
            else if (result.s !== s) logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            else if (result.v === 0 || result.v === 1) result.recoveryParam = result.v;
            else result.recoveryParam = 1 - result.v % 2;
        } else if (result.v == null) result.v = 27 + result.recoveryParam;
        else {
            const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
            if (result.recoveryParam !== recId) logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
        }
        if (result.r == null || !isHexString(result.r)) logger.throwArgumentError("signature missing or invalid r", "signature", signature);
        else result.r = hexZeroPad(result.r, 32);
        if (result.s == null || !isHexString(result.s)) logger.throwArgumentError("signature missing or invalid s", "signature", signature);
        else result.s = hexZeroPad(result.s, 32);
        const vs = arrayify(result.s);
        if (vs[0] >= 128) logger.throwArgumentError("signature s out of range", "signature", signature);
        if (result.recoveryParam) vs[0] |= 0x80;
        const _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) logger.throwArgumentError("signature invalid _vs", "signature", signature);
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) result._vs = _vs;
        else if (result._vs !== _vs) logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
}
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        signature.recoveryParam ? "0x1c" : "0x1b"
    ]));
}

},{"@ethersproject/logger":"hLvB2","./_version":"4BMks","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hLvB2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LogLevel", ()=>LogLevel);
parcelHelpers.export(exports, "ErrorCode", ()=>ErrorCode);
parcelHelpers.export(exports, "Logger", ()=>Logger);
var _version = require("./_version");
"use strict";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = {
    debug: 1,
    "default": 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        [
            "NFD",
            "NFC",
            "NFKD",
            "NFKC"
        ].forEach((form)=>{
            try {
                if ("test".normalize(form) !== "test") throw new Error("bad normalize");
            } catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) throw new Error("missing " + missing.join(", "));
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) throw new Error("broken implementation");
    } catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version){
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        if (_logLevel > LogLevels[level]) return;
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) return this.makeError("censored error", code, {});
        if (!code) code = Logger.errors.UNKNOWN_ERROR;
        if (!params) params = {};
        const messageDetails = [];
        Object.keys(params).forEach((key)=>{
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for(let i = 0; i < value.length; i++){
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                } else messageDetails.push(key + "=" + JSON.stringify(value));
            } catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch(code){
            case ErrorCode.NUMERIC_FAULT:
                {
                    url = "NUMERIC_FAULT";
                    const fault = message;
                    switch(fault){
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            url += "-" + fault;
                            break;
                        case "negative-power":
                        case "negative-width":
                            url += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            url += "-unbound-result";
                            break;
                    }
                    break;
                }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        if (messageDetails.length) message += " (" + messageDetails.join(", ") + ")";
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) return;
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) return;
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) message = "platform missing String.prototype.normalize";
        if (_normalizeError) this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
        });
    }
    checkSafeUint53(value, message) {
        if (typeof value !== "number") return;
        if (message == null) message = "value not safe";
        if (value < 0 || value >= 0x1fffffffffffff) this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: value
        });
        if (value % 1) this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: value
        });
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) message = ": " + message;
        else message = "";
        if (count < expectedCount) this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
            count: count,
            expectedCount: expectedCount
        });
        if (count > expectedCount) this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
            count: count,
            expectedCount: expectedCount
        });
    }
    checkNew(target, kind) {
        if (target === Object || target == null) this.throwError("missing new", Logger.errors.MISSING_NEW, {
            name: kind.name
        });
    }
    checkAbstract(target, kind) {
        if (target === kind) this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, {
            name: target.name,
            operation: "new"
        });
        else if (target === Object || target == null) this.throwError("missing new", Logger.errors.MISSING_NEW, {
            name: kind.name
        });
    }
    static globalLogger() {
        if (!_globalLogger) _globalLogger = new Logger((0, _version.version));
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
        });
        if (_permanentCensorErrors) {
            if (!censorship) return;
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

},{"./_version":"7HqMB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7HqMB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "logger/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BMks":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "bytes/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gN5k0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "bignumber/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kqiW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatFixed", ()=>formatFixed);
parcelHelpers.export(exports, "parseFixed", ()=>parseFixed);
parcelHelpers.export(exports, "FixedFormat", ()=>FixedFormat);
parcelHelpers.export(exports, "FixedNumber", ()=>FixedNumber);
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _bignumber = require("./bignumber");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const _constructorGuard = {};
const Zero = (0, _bignumber.BigNumber).from(0);
const NegativeOne = (0, _bignumber.BigNumber).from(-1);
function throwFault(message, fault, operation, value) {
    const params = {
        fault: fault,
        operation: operation
    };
    if (value !== undefined) params.value = value;
    return logger.throwError(message, (0, _logger.Logger).errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while(zeros.length < 256)zeros += zeros;
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof decimals !== "number") try {
        decimals = (0, _bignumber.BigNumber).from(decimals).toNumber();
    } catch (e) {}
    if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) return "1" + zeros.substring(0, decimals);
    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) decimals = 0;
    const multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = (0, _bignumber.BigNumber).from(value);
    const negative = value.lt(Zero);
    if (negative) value = value.mul(NegativeOne);
    let fraction = value.mod(multiplier).toString();
    while(fraction.length < multiplier.length - 1)fraction = "0" + fraction;
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) value = whole;
    else value = whole + "." + fraction;
    if (negative) value = "-" + value;
    return value;
}
function parseFixed(value, decimals) {
    if (decimals == null) decimals = 0;
    const multiplier = getMultiplier(decimals);
    if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) logger.throwArgumentError("invalid decimal value", "value", value);
    // Is it negative?
    const negative = value.substring(0, 1) === "-";
    if (negative) value = value.substring(1);
    if (value === ".") logger.throwArgumentError("missing value", "value", value);
    // Split it into a whole and fractional part
    const comps = value.split(".");
    if (comps.length > 2) logger.throwArgumentError("too many decimal points", "value", value);
    let whole = comps[0], fraction = comps[1];
    if (!whole) whole = "0";
    if (!fraction) fraction = "0";
    // Trim trailing zeros
    while(fraction[fraction.length - 1] === "0")fraction = fraction.substring(0, fraction.length - 1);
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") fraction = "0";
    // Fully pad the string with zeros to get to wei
    while(fraction.length < multiplier.length - 1)fraction += "0";
    const wholeValue = (0, _bignumber.BigNumber).from(whole);
    const fractionValue = (0, _bignumber.BigNumber).from(fraction);
    let wei = wholeValue.mul(multiplier).add(fractionValue);
    if (negative) wei = wei.mul(NegativeOne);
    return wei;
}
class FixedFormat {
    constructor(constructorGuard, signed, width, decimals){
        if (constructorGuard !== _constructorGuard) logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
        });
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    static from(value) {
        if (value instanceof FixedFormat) return value;
        if (typeof value === "number") value = `fixed128x${value}`;
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
            if (value === "fixed") ;
            else if (value === "ufixed") signed = false;
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) logger.throwArgumentError("invalid fixed format", "format", value);
                signed = match[1] !== "u";
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        } else if (value) {
            const check = (key, type, defaultValue)=>{
                if (value[key] == null) return defaultValue;
                if (typeof value[key] !== type) logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        if (decimals > 80) logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        return new FixedFormat(_constructorGuard, signed, width, decimals);
    }
}
class FixedNumber {
    constructor(constructorGuard, hex, value, format){
        if (constructorGuard !== _constructorGuard) logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
        });
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    _checkFormat(other) {
        if (this.format.name !== other.format.name) logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
    addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) comps.push("0");
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) result = result.subUnsafe(ONE.toFormat(result.format));
        return result;
    }
    ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) comps.push("0");
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) result = result.addUnsafe(ONE.toFormat(result.format));
        return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
        if (decimals == null) decimals = 0;
        // If we are already in range, we're done
        const comps = this.toString().split(".");
        if (comps.length === 1) comps.push("0");
        if (decimals < 0 || decimals > 80 || decimals % 1) logger.throwArgumentError("invalid decimal count", "decimals", decimals);
        if (comps[1].length <= decimals) return this;
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
        return this._value === "0.0" || this._value === "0";
    }
    isNegative() {
        return this._value[0] === "-";
    }
    toString() {
        return this._value;
    }
    toHexString(width) {
        if (width == null) return this._hex;
        if (width % 8) logger.throwArgumentError("invalid byte width", "width", width);
        const hex = (0, _bignumber.BigNumber).from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return (0, _bytes.hexZeroPad)(hex, width / 8);
    }
    toUnsafeFloat() {
        return parseFloat(this.toString());
    }
    toFormat(format) {
        return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !(0, _bignumber.isBigNumberish)(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) decimals = 0;
        if (format == null) format = "fixed";
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
        if (format == null) format = "fixed";
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) throwFault("unsigned value cannot be negative", "overflow", "value", value);
        let hex = null;
        if (fixedFormat.signed) hex = numeric.toTwos(fixedFormat.width).toHexString();
        else {
            hex = numeric.toHexString();
            hex = (0, _bytes.hexZeroPad)(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
        if (format == null) format = "fixed";
        const fixedFormat = FixedFormat.from(format);
        if ((0, _bytes.arrayify)(value).length > fixedFormat.width / 8) throw new Error("overflow");
        let numeric = (0, _bignumber.BigNumber).from(value);
        if (fixedFormat.signed) numeric = numeric.fromTwos(fixedFormat.width);
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static from(value, format) {
        if (typeof value === "string") return FixedNumber.fromString(value, format);
        if ((0, _bytes.isBytes)(value)) return FixedNumber.fromBytes(value, format);
        try {
            return FixedNumber.fromValue(value, 0, format);
        } catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== (0, _logger.Logger).errors.INVALID_ARGUMENT) throw error;
        }
        return logger.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
    }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");

},{"@ethersproject/bytes":"htrqZ","@ethersproject/logger":"hLvB2","./_version":"gN5k0","./bignumber":"eCYd8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h3GJb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineReadOnly", ()=>defineReadOnly);
// Crawl up the constructor chain to find a static method
parcelHelpers.export(exports, "getStatic", ()=>getStatic);
parcelHelpers.export(exports, "resolveProperties", ()=>resolveProperties);
parcelHelpers.export(exports, "checkProperties", ()=>checkProperties);
parcelHelpers.export(exports, "shallowCopy", ()=>shallowCopy);
parcelHelpers.export(exports, "deepCopy", ()=>deepCopy);
parcelHelpers.export(exports, "Description", ()=>Description);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false
    });
}
function getStatic(ctor, key) {
    for(let i = 0; i < 32; i++){
        if (ctor[key]) return ctor[key];
        if (!ctor.prototype || typeof ctor.prototype !== "object") break;
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, function*() {
        const promises = Object.keys(object).map((key)=>{
            const value = object[key];
            return Promise.resolve(value).then((v)=>({
                    key: key,
                    value: v
                }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result)=>{
            accum[result.key] = result.value;
            return accum;
        }, {});
    });
}
function checkProperties(object, properties) {
    if (!object || typeof object !== "object") logger.throwArgumentError("invalid object", "object", object);
    Object.keys(object).forEach((key)=>{
        if (!properties[key]) logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
    });
}
function shallowCopy(object) {
    const result = {};
    for(const key in object)result[key] = object[key];
    return result;
}
const opaque = {
    bigint: true,
    boolean: true,
    "function": true,
    number: true,
    string: true
};
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof object]) return true;
    if (Array.isArray(object) || typeof object === "object") {
        if (!Object.isFrozen(object)) return false;
        const keys = Object.keys(object);
        for(let i = 0; i < keys.length; i++){
            let value = null;
            try {
                value = object[keys[i]];
            } catch (error) {
                continue;
            }
            if (!_isFrozen(value)) return false;
        }
        return true;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) return object;
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) return Object.freeze(object.map((item)=>deepCopy(item)));
    if (typeof object === "object") {
        const result = {};
        for(const key in object){
            const value = object[key];
            if (value === undefined) continue;
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info){
        for(const key in info)this[key] = deepCopy(info[key]);
    }
}

},{"@ethersproject/logger":"hLvB2","./_version":"5xVnM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xVnM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "properties/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9uxOS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "abi/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4pw2B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbiCoder", ()=>AbiCoder);
parcelHelpers.export(exports, "defaultAbiCoder", ()=>defaultAbiCoder);
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _abstractCoder = require("./coders/abstract-coder");
var _address = require("./coders/address");
var _array = require("./coders/array");
var _boolean = require("./coders/boolean");
var _bytes1 = require("./coders/bytes");
var _fixedBytes = require("./coders/fixed-bytes");
var _null = require("./coders/null");
var _number = require("./coders/number");
var _string = require("./coders/string");
var _tuple = require("./coders/tuple");
var _fragments = require("./fragments");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc){
        (0, _properties.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch(param.baseType){
            case "address":
                return new (0, _address.AddressCoder)(param.name);
            case "bool":
                return new (0, _boolean.BooleanCoder)(param.name);
            case "string":
                return new (0, _string.StringCoder)(param.name);
            case "bytes":
                return new (0, _bytes1.BytesCoder)(param.name);
            case "array":
                return new (0, _array.ArrayCoder)(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new (0, _tuple.TupleCoder)((param.components || []).map((component)=>{
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new (0, _null.NullCoder)(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || size % 8 !== 0) logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            return new (0, _number.NumberCoder)(size / 8, match[1] === "int", param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) logger.throwArgumentError("invalid bytes length", "param", param);
            return new (0, _fixedBytes.FixedBytesCoder)(size, param.name);
        }
        return logger.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() {
        return 32;
    }
    _getReader(data, allowLoose) {
        return new (0, _abstractCoder.Reader)(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new (0, _abstractCoder.Writer)(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type)=>this._getCoder((0, _fragments.ParamType).from(type)));
        const coder = new (0, _tuple.TupleCoder)(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) logger.throwError("types/values length mismatch", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
            count: {
                types: types.length,
                values: values.length
            },
            value: {
                types: types,
                values: values
            }
        });
        const coders = types.map((type)=>this._getCoder((0, _fragments.ParamType).from(type)));
        const coder = new (0, _tuple.TupleCoder)(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type)=>this._getCoder((0, _fragments.ParamType).from(type)));
        const coder = new (0, _tuple.TupleCoder)(coders, "_");
        return coder.decode(this._getReader((0, _bytes.arrayify)(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

},{"@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"9uxOS","./coders/abstract-coder":"hm9h5","./coders/address":"2Xx6r","./coders/array":"doYUW","./coders/boolean":"7U9tT","./coders/bytes":"i9ad0","./coders/fixed-bytes":"fMzsa","./coders/null":"8kB1r","./coders/number":"4eYqf","./coders/string":"bUJPj","./coders/tuple":"Cp2hA","./fragments":"jvsHr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hm9h5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkResultErrors", ()=>checkResultErrors);
parcelHelpers.export(exports, "Coder", ()=>Coder);
parcelHelpers.export(exports, "Writer", ()=>Writer);
parcelHelpers.export(exports, "Reader", ()=>Reader);
var _bytes = require("@ethersproject/bytes");
var _bignumber = require("@ethersproject/bignumber");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("../_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function(path, object) {
        if (!Array.isArray(object)) return;
        for(let key in object){
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            } catch (error) {
                errors.push({
                    path: childPath,
                    error: error
                });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic){
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize){
        (0, _properties.defineReadOnly)(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return (0, _bytes.hexConcat)(this._data);
    }
    get length() {
        return this._dataLength;
    }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData((0, _bytes.concat)(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = (0, _bytes.arrayify)(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) bytes = (0, _bytes.concat)([
            bytes,
            this._padding.slice(paddingOffset)
        ]);
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = (0, _bytes.arrayify)((0, _bignumber.BigNumber).from(value));
        if (bytes.length > this.wordSize) logger.throwError("value out-of-bounds", (0, _logger.Logger).errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes.length
        });
        if (bytes.length % this.wordSize) bytes = (0, _bytes.concat)([
            this._padding.slice(bytes.length % this.wordSize),
            bytes
        ]);
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value)=>{
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose){
        (0, _properties.defineReadOnly)(this, "_data", (0, _bytes.arrayify)(data));
        (0, _properties.defineReadOnly)(this, "wordSize", wordSize || 32);
        (0, _properties.defineReadOnly)(this, "_coerceFunc", coerceFunc);
        (0, _properties.defineReadOnly)(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() {
        return (0, _bytes.hexlify)(this._data);
    }
    get consumed() {
        return this._offset;
    }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) value = value.toNumber();
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) return this._coerceFunc(name, value);
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) alignedLength = length;
            else logger.throwError("data out-of-bounds", (0, _logger.Logger).errors.BUFFER_OVERRUN, {
                length: this._data.length,
                offset: this._offset + alignedLength
            });
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return (0, _bignumber.BigNumber).from(this.readBytes(this.wordSize));
    }
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/bignumber":"ckYYW","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","../_version":"9uxOS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Xx6r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AddressCoder", ()=>AddressCoder);
var _address = require("@ethersproject/address");
var _bytes = require("@ethersproject/bytes");
var _abstractCoder = require("./abstract-coder");
"use strict";
class AddressCoder extends (0, _abstractCoder.Coder) {
    constructor(localName){
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = (0, _address.getAddress)(value);
        } catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return (0, _address.getAddress)((0, _bytes.hexZeroPad)(reader.readValue().toHexString(), 20));
    }
}

},{"@ethersproject/address":"ggdAz","@ethersproject/bytes":"htrqZ","./abstract-coder":"hm9h5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ggdAz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAddress", ()=>getAddress);
parcelHelpers.export(exports, "isAddress", ()=>isAddress);
parcelHelpers.export(exports, "getIcapAddress", ()=>getIcapAddress);
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
parcelHelpers.export(exports, "getContractAddress", ()=>getContractAddress);
parcelHelpers.export(exports, "getCreate2Address", ()=>getCreate2Address);
var _bytes = require("@ethersproject/bytes");
var _bignumber = require("@ethersproject/bignumber");
var _keccak256 = require("@ethersproject/keccak256");
var _rlp = require("@ethersproject/rlp");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function getChecksumAddress(address) {
    if (!(0, _bytes.isHexString)(address, 20)) logger.throwArgumentError("invalid address", "address", address);
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for(let i = 0; i < 40; i++)expanded[i] = chars[i].charCodeAt(0);
    const hashed = (0, _bytes.arrayify)((0, _keccak256.keccak256)(expanded));
    for(let i = 0; i < 40; i += 2){
        if (hashed[i >> 1] >> 4 >= 8) chars[i] = chars[i].toUpperCase();
        if ((hashed[i >> 1] & 0x0f) >= 8) chars[i + 1] = chars[i + 1].toUpperCase();
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) return Math.log10(x);
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for(let i = 0; i < 10; i++)ibanLookup[String(i)] = String(i);
for(let i = 0; i < 26; i++)ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c)=>{
        return ibanLookup[c];
    }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while(expanded.length >= safeDigits){
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while(checksum.length < 2)checksum = "0" + checksum;
    return checksum;
}
function getAddress(address) {
    let result = null;
    if (typeof address !== "string") logger.throwArgumentError("invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") address = "0x" + address;
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) logger.throwArgumentError("bad address checksum", "address", address);
    // Maybe ICAP? (we only support direct mode)
    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) logger.throwArgumentError("bad icap checksum", "address", address);
        result = (0, _bignumber._base36To16)(address.substring(4));
        while(result.length < 40)result = "0" + result;
        result = getChecksumAddress("0x" + result);
    } else logger.throwArgumentError("invalid address", "address", address);
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    } catch (error) {}
    return false;
}
function getIcapAddress(address) {
    let base36 = (0, _bignumber._base16To36)(getAddress(address).substring(2)).toUpperCase();
    while(base36.length < 30)base36 = "0" + base36;
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    } catch (error) {
        logger.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = (0, _bytes.stripZeros)((0, _bytes.arrayify)((0, _bignumber.BigNumber).from(transaction.nonce).toHexString()));
    return getAddress((0, _bytes.hexDataSlice)((0, _keccak256.keccak256)((0, _rlp.encode)([
        from,
        nonce
    ])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
    if ((0, _bytes.hexDataLength)(salt) !== 32) logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
    if ((0, _bytes.hexDataLength)(initCodeHash) !== 32) logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    return getAddress((0, _bytes.hexDataSlice)((0, _keccak256.keccak256)((0, _bytes.concat)([
        "0xff",
        getAddress(from),
        salt,
        initCodeHash
    ])), 12));
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/bignumber":"ckYYW","@ethersproject/keccak256":"hXDEv","@ethersproject/rlp":"b2vlp","@ethersproject/logger":"hLvB2","./_version":"jWoM7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hXDEv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keccak256", ()=>keccak256);
var _jsSha3 = require("js-sha3");
var _jsSha3Default = parcelHelpers.interopDefault(_jsSha3);
var _bytes = require("@ethersproject/bytes");
"use strict";
function keccak256(data) {
    return "0x" + (0, _jsSha3Default.default).keccak_256((0, _bytes.arrayify)(data));
}

},{"js-sha3":"7x0z6","@ethersproject/bytes":"htrqZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7x0z6":[function(require,module,exports) {
var process = require("5defb539e98cbde3");
var global = arguments[3];
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */ /*jslint bitwise: true */ (function() {
    "use strict";
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) WINDOW = false;
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) root = global;
    else if (WEB_WORKER) root = self;
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var AMD = typeof define === "function" && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [
        31,
        7936,
        2031616,
        520093696
    ];
    var CSHAKE_PADDING = [
        4,
        1024,
        262144,
        67108864
    ];
    var KECCAK_PADDING = [
        1,
        256,
        65536,
        16777216
    ];
    var PADDING = [
        6,
        1536,
        393216,
        100663296
    ];
    var SHIFT = [
        0,
        8,
        16,
        24
    ];
    var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
    ];
    var BITS = [
        224,
        256,
        384,
        512
    ];
    var SHAKE_BITS = [
        128,
        256
    ];
    var OUTPUT_TYPES = [
        "hex",
        "buffer",
        "arrayBuffer",
        "array",
        "digest"
    ];
    var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
    var createOutputMethod = function(bits, padding, outputType) {
        return function(message) {
            return new Keccak(bits, padding, bits).update(message)[outputType]();
        };
    };
    var createShakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits) {
            return new Keccak(bits, padding, outputBits).update(message)[outputType]();
        };
    };
    var createCshakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits, n, s) {
            return methods["cshake" + bits].update(message, outputBits, n, s)[outputType]();
        };
    };
    var createKmacOutputMethod = function(bits, padding, outputType) {
        return function(key, message, outputBits, s) {
            return methods["kmac" + bits].update(key, message, outputBits, s)[outputType]();
        };
    };
    var createOutputMethods = function(method, createMethod, bits, padding) {
        for(var i = 0; i < OUTPUT_TYPES.length; ++i){
            var type = OUTPUT_TYPES[i];
            method[type] = createMethod(bits, padding, type);
        }
        return method;
    };
    var createMethod = function(bits, padding) {
        var method = createOutputMethod(bits, padding, "hex");
        method.create = function() {
            return new Keccak(bits, padding, bits);
        };
        method.update = function(message) {
            return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits, padding);
    };
    var createShakeMethod = function(bits, padding) {
        var method = createShakeOutputMethod(bits, padding, "hex");
        method.create = function(outputBits) {
            return new Keccak(bits, padding, outputBits);
        };
        method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    };
    var createCshakeMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createCshakeOutputMethod(bits, padding, "hex");
        method.create = function(outputBits, n, s) {
            if (!n && !s) return methods["shake" + bits].create(outputBits);
            else return new Keccak(bits, padding, outputBits).bytepad([
                n,
                s
            ], w);
        };
        method.update = function(message, outputBits, n, s) {
            return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    };
    var createKmacMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createKmacOutputMethod(bits, padding, "hex");
        method.create = function(key, outputBits, s) {
            return new Kmac(bits, padding, outputBits).bytepad([
                "KMAC",
                s
            ], w).bytepad([
                key
            ], w);
        };
        method.update = function(key, message, outputBits, s) {
            return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    };
    var algorithms = [
        {
            name: "keccak",
            padding: KECCAK_PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: "sha3",
            padding: PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: "shake",
            padding: SHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createShakeMethod
        },
        {
            name: "cshake",
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createCshakeMethod
        },
        {
            name: "kmac",
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createKmacMethod
        }
    ];
    var methods = {}, methodNames = [];
    for(var i = 0; i < algorithms.length; ++i){
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for(var j = 0; j < bits.length; ++j){
            var methodName = algorithm.name + "_" + bits[j];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
            if (algorithm.name !== "sha3") {
                var newMethodName = algorithm.name + bits[j];
                methodNames.push(newMethodName);
                methods[newMethodName] = methods[methodName];
            }
        }
    }
    function Keccak(bits, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for(var i = 0; i < 50; ++i)this.s[i] = 0;
    }
    Keccak.prototype.update = function(message) {
        if (this.finalized) throw new Error(FINALIZE_ERROR);
        var notString, type = typeof message;
        if (type !== "string") {
            if (type === "object") {
                if (message === null) throw new Error(INPUT_ERROR);
                else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) message = new Uint8Array(message);
                else if (!Array.isArray(message)) {
                    if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) throw new Error(INPUT_ERROR);
                }
            } else throw new Error(INPUT_ERROR);
            notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i, code;
        while(index < length){
            if (this.reset) {
                this.reset = false;
                blocks[0] = this.block;
                for(i = 1; i < blockCount + 1; ++i)blocks[i] = 0;
            }
            if (notString) for(i = this.start; index < length && i < byteCount; ++index)blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            else for(i = this.start; index < length && i < byteCount; ++index){
                code = message.charCodeAt(index);
                if (code < 0x80) blocks[i >> 2] |= code << SHIFT[i++ & 3];
                else if (code < 0x800) {
                    blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                } else if (code < 0xd800 || code >= 0xe000) {
                    blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                } else {
                    code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                    blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                }
            }
            this.lastByteIndex = i;
            if (i >= byteCount) {
                this.start = i - byteCount;
                this.block = blocks[blockCount];
                for(i = 0; i < blockCount; ++i)s[i] ^= blocks[i];
                f(s);
                this.reset = true;
            } else this.start = i;
        }
        return this;
    };
    Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [
            o
        ];
        x = x >> 8;
        o = x & 255;
        while(o > 0){
            bytes.unshift(o);
            x = x >> 8;
            o = x & 255;
            ++n;
        }
        if (right) bytes.push(n);
        else bytes.unshift(n);
        this.update(bytes);
        return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
            if (type === "object") {
                if (str === null) throw new Error(INPUT_ERROR);
                else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) str = new Uint8Array(str);
                else if (!Array.isArray(str)) {
                    if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) throw new Error(INPUT_ERROR);
                }
            } else throw new Error(INPUT_ERROR);
            notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) bytes = length;
        else for(var i = 0; i < str.length; ++i){
            var code = str.charCodeAt(i);
            if (code < 0x80) bytes += 1;
            else if (code < 0x800) bytes += 2;
            else if (code < 0xd800 || code >= 0xe000) bytes += 3;
            else {
                code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
                bytes += 4;
            }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for(var i = 0; i < strs.length; ++i)bytes += this.encodeString(strs[i]);
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
    };
    Keccak.prototype.finalize = function() {
        if (this.finalized) return;
        this.finalized = true;
        var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i >> 2] |= this.padding[i & 3];
        if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for(i = 1; i < blockCount + 1; ++i)blocks[i] = 0;
        }
        blocks[blockCount - 1] |= 0x80000000;
        for(i = 0; i < blockCount; ++i)s[i] ^= blocks[i];
        f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var hex = "", block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                block = s[i];
                hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
            }
            if (j % blockCount === 0) {
                f(s);
                i = 0;
            }
        }
        if (extraBytes) {
            block = s[i];
            hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];
            if (extraBytes > 1) hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
            if (extraBytes > 2) hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
        }
        return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        else buffer = new ArrayBuffer(bytes);
        var array = new Uint32Array(buffer);
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j)array[j] = s[i];
            if (j % blockCount === 0) f(s);
        }
        if (extraBytes) {
            array[i] = s[i];
            buffer = buffer.slice(0, bytes);
        }
        return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var array = [], offset, block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                offset = j << 2;
                block = s[i];
                array[offset] = block & 0xFF;
                array[offset + 1] = block >> 8 & 0xFF;
                array[offset + 2] = block >> 16 & 0xFF;
                array[offset + 3] = block >> 24 & 0xFF;
            }
            if (j % blockCount === 0) f(s);
        }
        if (extraBytes) {
            offset = j << 2;
            block = s[i];
            array[offset] = block & 0xFF;
            if (extraBytes > 1) array[offset + 1] = block >> 8 & 0xFF;
            if (extraBytes > 2) array[offset + 2] = block >> 16 & 0xFF;
        }
        return array;
    };
    function Kmac(bits, padding, outputBits) {
        Keccak.call(this, bits, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
    };
    var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for(n = 0; n < 48; n += 2){
            c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
            c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
            c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
            c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
            c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
            c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
            c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
            c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
            c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
            c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
            h = c8 ^ (c2 << 1 | c3 >>> 31);
            l = c9 ^ (c3 << 1 | c2 >>> 31);
            s[0] ^= h;
            s[1] ^= l;
            s[10] ^= h;
            s[11] ^= l;
            s[20] ^= h;
            s[21] ^= l;
            s[30] ^= h;
            s[31] ^= l;
            s[40] ^= h;
            s[41] ^= l;
            h = c0 ^ (c4 << 1 | c5 >>> 31);
            l = c1 ^ (c5 << 1 | c4 >>> 31);
            s[2] ^= h;
            s[3] ^= l;
            s[12] ^= h;
            s[13] ^= l;
            s[22] ^= h;
            s[23] ^= l;
            s[32] ^= h;
            s[33] ^= l;
            s[42] ^= h;
            s[43] ^= l;
            h = c2 ^ (c6 << 1 | c7 >>> 31);
            l = c3 ^ (c7 << 1 | c6 >>> 31);
            s[4] ^= h;
            s[5] ^= l;
            s[14] ^= h;
            s[15] ^= l;
            s[24] ^= h;
            s[25] ^= l;
            s[34] ^= h;
            s[35] ^= l;
            s[44] ^= h;
            s[45] ^= l;
            h = c4 ^ (c8 << 1 | c9 >>> 31);
            l = c5 ^ (c9 << 1 | c8 >>> 31);
            s[6] ^= h;
            s[7] ^= l;
            s[16] ^= h;
            s[17] ^= l;
            s[26] ^= h;
            s[27] ^= l;
            s[36] ^= h;
            s[37] ^= l;
            s[46] ^= h;
            s[47] ^= l;
            h = c6 ^ (c0 << 1 | c1 >>> 31);
            l = c7 ^ (c1 << 1 | c0 >>> 31);
            s[8] ^= h;
            s[9] ^= l;
            s[18] ^= h;
            s[19] ^= l;
            s[28] ^= h;
            s[29] ^= l;
            s[38] ^= h;
            s[39] ^= l;
            s[48] ^= h;
            s[49] ^= l;
            b0 = s[0];
            b1 = s[1];
            b32 = s[11] << 4 | s[10] >>> 28;
            b33 = s[10] << 4 | s[11] >>> 28;
            b14 = s[20] << 3 | s[21] >>> 29;
            b15 = s[21] << 3 | s[20] >>> 29;
            b46 = s[31] << 9 | s[30] >>> 23;
            b47 = s[30] << 9 | s[31] >>> 23;
            b28 = s[40] << 18 | s[41] >>> 14;
            b29 = s[41] << 18 | s[40] >>> 14;
            b20 = s[2] << 1 | s[3] >>> 31;
            b21 = s[3] << 1 | s[2] >>> 31;
            b2 = s[13] << 12 | s[12] >>> 20;
            b3 = s[12] << 12 | s[13] >>> 20;
            b34 = s[22] << 10 | s[23] >>> 22;
            b35 = s[23] << 10 | s[22] >>> 22;
            b16 = s[33] << 13 | s[32] >>> 19;
            b17 = s[32] << 13 | s[33] >>> 19;
            b48 = s[42] << 2 | s[43] >>> 30;
            b49 = s[43] << 2 | s[42] >>> 30;
            b40 = s[5] << 30 | s[4] >>> 2;
            b41 = s[4] << 30 | s[5] >>> 2;
            b22 = s[14] << 6 | s[15] >>> 26;
            b23 = s[15] << 6 | s[14] >>> 26;
            b4 = s[25] << 11 | s[24] >>> 21;
            b5 = s[24] << 11 | s[25] >>> 21;
            b36 = s[34] << 15 | s[35] >>> 17;
            b37 = s[35] << 15 | s[34] >>> 17;
            b18 = s[45] << 29 | s[44] >>> 3;
            b19 = s[44] << 29 | s[45] >>> 3;
            b10 = s[6] << 28 | s[7] >>> 4;
            b11 = s[7] << 28 | s[6] >>> 4;
            b42 = s[17] << 23 | s[16] >>> 9;
            b43 = s[16] << 23 | s[17] >>> 9;
            b24 = s[26] << 25 | s[27] >>> 7;
            b25 = s[27] << 25 | s[26] >>> 7;
            b6 = s[36] << 21 | s[37] >>> 11;
            b7 = s[37] << 21 | s[36] >>> 11;
            b38 = s[47] << 24 | s[46] >>> 8;
            b39 = s[46] << 24 | s[47] >>> 8;
            b30 = s[8] << 27 | s[9] >>> 5;
            b31 = s[9] << 27 | s[8] >>> 5;
            b12 = s[18] << 20 | s[19] >>> 12;
            b13 = s[19] << 20 | s[18] >>> 12;
            b44 = s[29] << 7 | s[28] >>> 25;
            b45 = s[28] << 7 | s[29] >>> 25;
            b26 = s[38] << 8 | s[39] >>> 24;
            b27 = s[39] << 8 | s[38] >>> 24;
            b8 = s[48] << 14 | s[49] >>> 18;
            b9 = s[49] << 14 | s[48] >>> 18;
            s[0] = b0 ^ ~b2 & b4;
            s[1] = b1 ^ ~b3 & b5;
            s[10] = b10 ^ ~b12 & b14;
            s[11] = b11 ^ ~b13 & b15;
            s[20] = b20 ^ ~b22 & b24;
            s[21] = b21 ^ ~b23 & b25;
            s[30] = b30 ^ ~b32 & b34;
            s[31] = b31 ^ ~b33 & b35;
            s[40] = b40 ^ ~b42 & b44;
            s[41] = b41 ^ ~b43 & b45;
            s[2] = b2 ^ ~b4 & b6;
            s[3] = b3 ^ ~b5 & b7;
            s[12] = b12 ^ ~b14 & b16;
            s[13] = b13 ^ ~b15 & b17;
            s[22] = b22 ^ ~b24 & b26;
            s[23] = b23 ^ ~b25 & b27;
            s[32] = b32 ^ ~b34 & b36;
            s[33] = b33 ^ ~b35 & b37;
            s[42] = b42 ^ ~b44 & b46;
            s[43] = b43 ^ ~b45 & b47;
            s[4] = b4 ^ ~b6 & b8;
            s[5] = b5 ^ ~b7 & b9;
            s[14] = b14 ^ ~b16 & b18;
            s[15] = b15 ^ ~b17 & b19;
            s[24] = b24 ^ ~b26 & b28;
            s[25] = b25 ^ ~b27 & b29;
            s[34] = b34 ^ ~b36 & b38;
            s[35] = b35 ^ ~b37 & b39;
            s[44] = b44 ^ ~b46 & b48;
            s[45] = b45 ^ ~b47 & b49;
            s[6] = b6 ^ ~b8 & b0;
            s[7] = b7 ^ ~b9 & b1;
            s[16] = b16 ^ ~b18 & b10;
            s[17] = b17 ^ ~b19 & b11;
            s[26] = b26 ^ ~b28 & b20;
            s[27] = b27 ^ ~b29 & b21;
            s[36] = b36 ^ ~b38 & b30;
            s[37] = b37 ^ ~b39 & b31;
            s[46] = b46 ^ ~b48 & b40;
            s[47] = b47 ^ ~b49 & b41;
            s[8] = b8 ^ ~b0 & b2;
            s[9] = b9 ^ ~b1 & b3;
            s[18] = b18 ^ ~b10 & b12;
            s[19] = b19 ^ ~b11 & b13;
            s[28] = b28 ^ ~b20 & b22;
            s[29] = b29 ^ ~b21 & b23;
            s[38] = b38 ^ ~b30 & b32;
            s[39] = b39 ^ ~b31 & b33;
            s[48] = b48 ^ ~b40 & b42;
            s[49] = b49 ^ ~b41 & b43;
            s[0] ^= RC[n];
            s[1] ^= RC[n + 1];
        }
    };
    if (COMMON_JS) module.exports = methods;
    else {
        for(i = 0; i < methodNames.length; ++i)root[methodNames[i]] = methods[methodNames[i]];
        if (AMD) define(function() {
            return methods;
        });
    }
})();

},{"5defb539e98cbde3":"d5jf4"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"b2vlp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
//See: https://github.com/ethereum/wiki/wiki/RLP
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function arrayifyInteger(value) {
    const result = [];
    while(value){
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for(let i = 0; i < length; i++)result = result * 256 + data[offset + i];
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function(child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!(0, _bytes.isBytesLike)(object)) logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    const data = Array.prototype.slice.call((0, _bytes.arrayify)(object));
    if (data.length === 1 && data[0] <= 0x7f) return data;
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return (0, _bytes.hexlify)(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while(childOffset < offset + 1 + length){
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) logger.throwError("child data too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
    }
    return {
        consumed: 1 + length,
        result: result
    };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) logger.throwError("data too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) logger.throwError("data short segment too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) logger.throwError("data long segment too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    } else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) logger.throwError("data array too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        return _decodeChildren(data, offset, offset + 1, length);
    } else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) logger.throwError("data array too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) logger.throwError("data array too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const result = (0, _bytes.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return {
            consumed: 1 + lengthLength + length,
            result: result
        };
    } else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) logger.throwError("data too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const result = (0, _bytes.hexlify)(data.slice(offset + 1, offset + 1 + length));
        return {
            consumed: 1 + length,
            result: result
        };
    }
    return {
        consumed: 1,
        result: (0, _bytes.hexlify)(data[offset])
    };
}
function decode(data) {
    const bytes = (0, _bytes.arrayify)(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) logger.throwArgumentError("invalid rlp data", "data", data);
    return decoded.result;
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/logger":"hLvB2","./_version":"9e0ao","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9e0ao":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "rlp/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jWoM7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "address/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"doYUW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pack", ()=>pack);
parcelHelpers.export(exports, "unpack", ()=>unpack);
parcelHelpers.export(exports, "ArrayCoder", ()=>ArrayCoder);
var _logger = require("@ethersproject/logger");
var _version = require("../_version");
var _abstractCoder = require("./abstract-coder");
var _anonymous = require("./anonymous");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) arrayValues = values;
    else if (values && typeof values === "object") {
        let unique = {};
        arrayValues = coders.map((coder)=>{
            const name = coder.localName;
            if (!name) logger.throwError("cannot encode object for signature with missing names", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: coder,
                value: values
            });
            if (unique[name]) logger.throwError("cannot encode object for signature with duplicate names", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: coder,
                value: values
            });
            unique[name] = true;
            return values[name];
        });
    } else logger.throwArgumentError("invalid tuple value", "tuple", values);
    if (coders.length !== arrayValues.length) logger.throwArgumentError("types/value length mismatch", "tuple", values);
    let staticWriter = new (0, _abstractCoder.Writer)(writer.wordSize);
    let dynamicWriter = new (0, _abstractCoder.Writer)(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index)=>{
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset)=>{
                updateFunc(baseOffset + dynamicOffset);
            });
        } else coder.encode(staticWriter, value);
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func)=>{
        func(staticWriter.length);
    });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder)=>{
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            } catch (error) {
                // Cannot recover from this
                if (error.code === (0, _logger.Logger).errors.BUFFER_OVERRUN) throw error;
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        } else try {
            value = coder.decode(reader);
        } catch (error) {
            // Cannot recover from this
            if (error.code === (0, _logger.Logger).errors.BUFFER_OVERRUN) throw error;
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
        }
        if (value != undefined) values.push(value);
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder)=>{
        const name = coder.localName;
        if (name) {
            if (!accum[name]) accum[name] = 0;
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index)=>{
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) return;
        if (name === "length") name = "_length";
        if (values[name] != null) return;
        const value = values[index];
        if (value instanceof Error) Object.defineProperty(values, name, {
            enumerable: true,
            get: ()=>{
                throw value;
            }
        });
        else values[name] = value;
    });
    for(let i = 0; i < values.length; i++){
        const value = values[i];
        if (value instanceof Error) Object.defineProperty(values, i, {
            enumerable: true,
            get: ()=>{
                throw value;
            }
        });
    }
    return Object.freeze(values);
}
class ArrayCoder extends (0, _abstractCoder.Coder) {
    constructor(coder, length, localName){
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for(let i = 0; i < this.length; i++)result.push(defaultChild);
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) this._throwError("expected array value", value);
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for(let i = 0; i < value.length; i++)coders.push(this.coder);
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) logger.throwError("insufficient data length", (0, _logger.Logger).errors.BUFFER_OVERRUN, {
                length: reader._data.length,
                count: count
            });
        }
        let coders = [];
        for(let i = 0; i < count; i++)coders.push(new (0, _anonymous.AnonymousCoder)(this.coder));
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

},{"@ethersproject/logger":"hLvB2","../_version":"9uxOS","./abstract-coder":"hm9h5","./anonymous":"bx81i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bx81i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Clones the functionality of an existing Coder, but without a localName
parcelHelpers.export(exports, "AnonymousCoder", ()=>AnonymousCoder);
var _abstractCoder = require("./abstract-coder");
"use strict";
class AnonymousCoder extends (0, _abstractCoder.Coder) {
    constructor(coder){
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

},{"./abstract-coder":"hm9h5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7U9tT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BooleanCoder", ()=>BooleanCoder);
var _abstractCoder = require("./abstract-coder");
"use strict";
class BooleanCoder extends (0, _abstractCoder.Coder) {
    constructor(localName){
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

},{"./abstract-coder":"hm9h5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i9ad0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DynamicBytesCoder", ()=>DynamicBytesCoder);
parcelHelpers.export(exports, "BytesCoder", ()=>BytesCoder);
var _bytes = require("@ethersproject/bytes");
var _abstractCoder = require("./abstract-coder");
"use strict";
class DynamicBytesCoder extends (0, _abstractCoder.Coder) {
    constructor(type, localName){
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = (0, _bytes.arrayify)(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName){
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, (0, _bytes.hexlify)(super.decode(reader)));
    }
}

},{"@ethersproject/bytes":"htrqZ","./abstract-coder":"hm9h5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fMzsa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// @TODO: Merge this with bytes
parcelHelpers.export(exports, "FixedBytesCoder", ()=>FixedBytesCoder);
var _bytes = require("@ethersproject/bytes");
var _abstractCoder = require("./abstract-coder");
"use strict";
class FixedBytesCoder extends (0, _abstractCoder.Coder) {
    constructor(size, localName){
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = (0, _bytes.arrayify)(value);
        if (data.length !== this.size) this._throwError("incorrect data length", value);
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, (0, _bytes.hexlify)(reader.readBytes(this.size)));
    }
}

},{"@ethersproject/bytes":"htrqZ","./abstract-coder":"hm9h5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8kB1r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NullCoder", ()=>NullCoder);
var _abstractCoder = require("./abstract-coder");
"use strict";
class NullCoder extends (0, _abstractCoder.Coder) {
    constructor(localName){
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) this._throwError("not null", value);
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

},{"./abstract-coder":"hm9h5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4eYqf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NumberCoder", ()=>NumberCoder);
var _bignumber = require("@ethersproject/bignumber");
var _constants = require("@ethersproject/constants");
var _abstractCoder = require("./abstract-coder");
"use strict";
class NumberCoder extends (0, _abstractCoder.Coder) {
    constructor(size, signed, localName){
        const name = (signed ? "int" : "uint") + size * 8;
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = (0, _bignumber.BigNumber).from(value);
        // Check bounds are safe for encoding
        let maxUintValue = (0, _constants.MaxUint256).mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add((0, _constants.One)).mul((0, _constants.NegativeOne)))) this._throwError("value out-of-bounds", value);
        } else if (v.lt((0, _constants.Zero)) || v.gt(maxUintValue.mask(this.size * 8))) this._throwError("value out-of-bounds", value);
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) value = value.fromTwos(this.size * 8);
        return reader.coerce(this.name, value);
    }
}

},{"@ethersproject/bignumber":"ckYYW","@ethersproject/constants":"gKbDE","./abstract-coder":"hm9h5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKbDE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AddressZero", ()=>(0, _addresses.AddressZero));
parcelHelpers.export(exports, "NegativeOne", ()=>(0, _bignumbers.NegativeOne));
parcelHelpers.export(exports, "Zero", ()=>(0, _bignumbers.Zero));
parcelHelpers.export(exports, "One", ()=>(0, _bignumbers.One));
parcelHelpers.export(exports, "Two", ()=>(0, _bignumbers.Two));
parcelHelpers.export(exports, "WeiPerEther", ()=>(0, _bignumbers.WeiPerEther));
parcelHelpers.export(exports, "MaxUint256", ()=>(0, _bignumbers.MaxUint256));
parcelHelpers.export(exports, "MinInt256", ()=>(0, _bignumbers.MinInt256));
parcelHelpers.export(exports, "MaxInt256", ()=>(0, _bignumbers.MaxInt256));
parcelHelpers.export(exports, "HashZero", ()=>(0, _hashes.HashZero));
parcelHelpers.export(exports, "EtherSymbol", ()=>(0, _strings.EtherSymbol));
var _addresses = require("./addresses");
var _bignumbers = require("./bignumbers");
var _hashes = require("./hashes");
var _strings = require("./strings");
"use strict";

},{"./addresses":"jR81H","./bignumbers":"dwozw","./hashes":"4Kb3P","./strings":"gdaUD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jR81H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AddressZero", ()=>AddressZero);
const AddressZero = "0x0000000000000000000000000000000000000000";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dwozw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NegativeOne", ()=>NegativeOne);
parcelHelpers.export(exports, "Zero", ()=>Zero);
parcelHelpers.export(exports, "One", ()=>One);
parcelHelpers.export(exports, "Two", ()=>Two);
parcelHelpers.export(exports, "WeiPerEther", ()=>WeiPerEther);
parcelHelpers.export(exports, "MaxUint256", ()=>MaxUint256);
parcelHelpers.export(exports, "MinInt256", ()=>MinInt256);
parcelHelpers.export(exports, "MaxInt256", ()=>MaxInt256);
var _bignumber = require("@ethersproject/bignumber");
const NegativeOne = /*#__PURE__*/ (0, _bignumber.BigNumber).from(-1);
const Zero = /*#__PURE__*/ (0, _bignumber.BigNumber).from(0);
const One = /*#__PURE__*/ (0, _bignumber.BigNumber).from(1);
const Two = /*#__PURE__*/ (0, _bignumber.BigNumber).from(2);
const WeiPerEther = /*#__PURE__*/ (0, _bignumber.BigNumber).from("1000000000000000000");
const MaxUint256 = /*#__PURE__*/ (0, _bignumber.BigNumber).from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const MinInt256 = /*#__PURE__*/ (0, _bignumber.BigNumber).from("-0x8000000000000000000000000000000000000000000000000000000000000000");
const MaxInt256 = /*#__PURE__*/ (0, _bignumber.BigNumber).from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

},{"@ethersproject/bignumber":"ckYYW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Kb3P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashZero", ()=>HashZero);
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gdaUD":[function(require,module,exports) {
// NFKC (composed)             // (decomposed)
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EtherSymbol", ()=>EtherSymbol);
const EtherSymbol = "\u039E"; // "\uD835\uDF63";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bUJPj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StringCoder", ()=>StringCoder);
var _strings = require("@ethersproject/strings");
var _bytes = require("./bytes");
"use strict";
class StringCoder extends (0, _bytes.DynamicBytesCoder) {
    constructor(localName){
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, (0, _strings.toUtf8Bytes)(value));
    }
    decode(reader) {
        return (0, _strings.toUtf8String)(super.decode(reader));
    }
}

},{"@ethersproject/strings":"5TGFZ","./bytes":"i9ad0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5TGFZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_toEscapedUtf8String", ()=>(0, _utf8._toEscapedUtf8String));
parcelHelpers.export(exports, "toUtf8Bytes", ()=>(0, _utf8.toUtf8Bytes));
parcelHelpers.export(exports, "toUtf8CodePoints", ()=>(0, _utf8.toUtf8CodePoints));
parcelHelpers.export(exports, "toUtf8String", ()=>(0, _utf8.toUtf8String));
parcelHelpers.export(exports, "Utf8ErrorFuncs", ()=>(0, _utf8.Utf8ErrorFuncs));
parcelHelpers.export(exports, "Utf8ErrorReason", ()=>(0, _utf8.Utf8ErrorReason));
parcelHelpers.export(exports, "UnicodeNormalizationForm", ()=>(0, _utf8.UnicodeNormalizationForm));
parcelHelpers.export(exports, "formatBytes32String", ()=>(0, _bytes32.formatBytes32String));
parcelHelpers.export(exports, "parseBytes32String", ()=>(0, _bytes32.parseBytes32String));
parcelHelpers.export(exports, "nameprep", ()=>(0, _idna.nameprep));
var _bytes32 = require("./bytes32");
var _idna = require("./idna");
var _utf8 = require("./utf8");
"use strict";

},{"./bytes32":"l8eOg","./idna":"9qcL7","./utf8":"dsMpR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l8eOg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatBytes32String", ()=>formatBytes32String);
parcelHelpers.export(exports, "parseBytes32String", ()=>parseBytes32String);
var _constants = require("@ethersproject/constants");
var _bytes = require("@ethersproject/bytes");
var _utf8 = require("./utf8");
"use strict";
function formatBytes32String(text) {
    // Get the bytes
    const bytes = (0, _utf8.toUtf8Bytes)(text);
    // Check we have room for null-termination
    if (bytes.length > 31) throw new Error("bytes32 string must be less than 32 bytes");
    // Zero-pad (implicitly null-terminates)
    return (0, _bytes.hexlify)((0, _bytes.concat)([
        bytes,
        (0, _constants.HashZero)
    ]).slice(0, 32));
}
function parseBytes32String(bytes) {
    const data = (0, _bytes.arrayify)(bytes);
    // Must be 32 bytes with a null-termination
    if (data.length !== 32) throw new Error("invalid bytes32 - not 32 bytes long");
    if (data[31] !== 0) throw new Error("invalid bytes32 string - no null terminator");
    // Find the null termination
    let length = 31;
    while(data[length - 1] === 0)length--;
    // Determine the string value
    return (0, _utf8.toUtf8String)(data.slice(0, length));
}

},{"@ethersproject/constants":"gKbDE","@ethersproject/bytes":"htrqZ","./utf8":"dsMpR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dsMpR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnicodeNormalizationForm", ()=>UnicodeNormalizationForm);
parcelHelpers.export(exports, "Utf8ErrorReason", ()=>Utf8ErrorReason);
parcelHelpers.export(exports, "Utf8ErrorFuncs", ()=>Utf8ErrorFuncs);
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
parcelHelpers.export(exports, "toUtf8Bytes", ()=>toUtf8Bytes);
parcelHelpers.export(exports, "_toEscapedUtf8String", ()=>_toEscapedUtf8String);
parcelHelpers.export(exports, "_toUtf8String", ()=>_toUtf8String);
parcelHelpers.export(exports, "toUtf8String", ()=>toUtf8String);
parcelHelpers.export(exports, "toUtf8CodePoints", ()=>toUtf8CodePoints);
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for(let o = offset + 1; o < bytes.length; o++){
            if (bytes[o] >> 6 !== 0x02) break;
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) return bytes.length - offset - 1;
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) onError = Utf8ErrorFuncs.error;
    bytes = (0, _bytes.arrayify)(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while(i < bytes.length){
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
        // 1110 xxxx 10xx xxxx 10xx xxxx
        } else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        } else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        } else {
            if ((c & 0xc0) === 0x80) i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            else i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & (1 << 8 - extraLength - 1) - 1;
        for(let j = 0; j < extraLength; j++){
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            res = res << 6 | nextChar & 0x3f;
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) continue;
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for(let i = 0; i < str.length; i++){
        const c = str.charCodeAt(i);
        if (c < 0x80) result.push(c);
        else if (c < 0x800) {
            result.push(c >> 6 | 0xc0);
            result.push(c & 0x3f | 0x80);
        } else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) throw new Error("invalid utf-8 string");
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push(pair >> 18 | 0xf0);
            result.push(pair >> 12 & 0x3f | 0x80);
            result.push(pair >> 6 & 0x3f | 0x80);
            result.push(pair & 0x3f | 0x80);
        } else {
            result.push(c >> 12 | 0xe0);
            result.push(c >> 6 & 0x3f | 0x80);
            result.push(c & 0x3f | 0x80);
        }
    }
    return (0, _bytes.arrayify)(result);
}
function escapeChar(value) {
    const hex = "0000" + value.toString(16);
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint)=>{
        if (codePoint < 256) {
            switch(codePoint){
                case 8:
                    return "\\b";
                case 9:
                    return "\\t";
                case 10:
                    return "\\n";
                case 13:
                    return "\\r";
                case 34:
                    return '\\"';
                case 92:
                    return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) return String.fromCharCode(codePoint);
        }
        if (codePoint <= 0xffff) return escapeChar(codePoint);
        codePoint -= 0x10000;
        return escapeChar((codePoint >> 10 & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint)=>{
        if (codePoint <= 0xffff) return String.fromCharCode(codePoint);
        codePoint -= 0x10000;
        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/logger":"hLvB2","./_version":"9NTd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9NTd9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "strings/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9qcL7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_nameprepTableA1", ()=>_nameprepTableA1);
parcelHelpers.export(exports, "_nameprepTableB2", ()=>_nameprepTableB2);
parcelHelpers.export(exports, "_nameprepTableC", ()=>_nameprepTableC);
parcelHelpers.export(exports, "nameprep", ()=>nameprep);
var _utf8 = require("./utf8");
"use strict";
function bytes2(data) {
    if (data.length % 4 !== 0) throw new Error("bad data");
    let result = [];
    for(let i = 0; i < data.length; i += 4)result.push(parseInt(data.substring(i, i + 4), 16));
    return result;
}
function createTable(data, func) {
    if (!func) func = function(value) {
        return [
            parseInt(value, 16)
        ];
    };
    let lo = 0;
    let result = {};
    data.split(",").forEach((pair)=>{
        let comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
    });
    return result;
}
function createRangeTable(data) {
    let hi = 0;
    return data.split(",").map((v)=>{
        let comps = v.split("-");
        if (comps.length === 1) comps[1] = "0";
        else if (comps[1] === "") comps[1] = "1";
        let lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return {
            l: lo,
            h: hi
        };
    });
}
function matchMap(value, ranges) {
    let lo = 0;
    for(let i = 0; i < ranges.length; i++){
        let range = ranges[i];
        lo += range.l;
        if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
            if (range.e && range.e.indexOf(value - lo) !== -1) continue;
            return range;
        }
    }
    return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v)=>parseInt(v, 16));
const Table_B_2_ranges = [
    {
        h: 25,
        s: 32,
        l: 65
    },
    {
        h: 30,
        s: 32,
        e: [
            23
        ],
        l: 127
    },
    {
        h: 54,
        s: 1,
        e: [
            48
        ],
        l: 64,
        d: 2
    },
    {
        h: 14,
        s: 1,
        l: 57,
        d: 2
    },
    {
        h: 44,
        s: 1,
        l: 17,
        d: 2
    },
    {
        h: 10,
        s: 1,
        e: [
            2,
            6,
            8
        ],
        l: 61,
        d: 2
    },
    {
        h: 16,
        s: 1,
        l: 68,
        d: 2
    },
    {
        h: 84,
        s: 1,
        e: [
            18,
            24,
            66
        ],
        l: 19,
        d: 2
    },
    {
        h: 26,
        s: 32,
        e: [
            17
        ],
        l: 435
    },
    {
        h: 22,
        s: 1,
        l: 71,
        d: 2
    },
    {
        h: 15,
        s: 80,
        l: 40
    },
    {
        h: 31,
        s: 32,
        l: 16
    },
    {
        h: 32,
        s: 1,
        l: 80,
        d: 2
    },
    {
        h: 52,
        s: 1,
        l: 42,
        d: 2
    },
    {
        h: 12,
        s: 1,
        l: 55,
        d: 2
    },
    {
        h: 40,
        s: 1,
        e: [
            38
        ],
        l: 15,
        d: 2
    },
    {
        h: 14,
        s: 1,
        l: 48,
        d: 2
    },
    {
        h: 37,
        s: 48,
        l: 49
    },
    {
        h: 148,
        s: 1,
        l: 6351,
        d: 2
    },
    {
        h: 88,
        s: 1,
        l: 160,
        d: 2
    },
    {
        h: 15,
        s: 16,
        l: 704
    },
    {
        h: 25,
        s: 26,
        l: 854
    },
    {
        h: 25,
        s: 32,
        l: 55915
    },
    {
        h: 37,
        s: 40,
        l: 1247
    },
    {
        h: 25,
        s: -119711,
        l: 53248
    },
    {
        h: 25,
        s: -119763,
        l: 52
    },
    {
        h: 25,
        s: -119815,
        l: 52
    },
    {
        h: 25,
        s: -119867,
        e: [
            1,
            4,
            5,
            7,
            8,
            11,
            12,
            17
        ],
        l: 52
    },
    {
        h: 25,
        s: -119919,
        l: 52
    },
    {
        h: 24,
        s: -119971,
        e: [
            2,
            7,
            8,
            17
        ],
        l: 52
    },
    {
        h: 24,
        s: -120023,
        e: [
            2,
            7,
            13,
            15,
            16,
            17
        ],
        l: 52
    },
    {
        h: 25,
        s: -120075,
        l: 52
    },
    {
        h: 25,
        s: -120127,
        l: 52
    },
    {
        h: 25,
        s: -120179,
        l: 52
    },
    {
        h: 25,
        s: -120231,
        l: 52
    },
    {
        h: 25,
        s: -120283,
        l: 52
    },
    {
        h: 25,
        s: -120335,
        l: 52
    },
    {
        h: 24,
        s: -119543,
        e: [
            17
        ],
        l: 56
    },
    {
        h: 24,
        s: -119601,
        e: [
            17
        ],
        l: 58
    },
    {
        h: 24,
        s: -119659,
        e: [
            17
        ],
        l: 58
    },
    {
        h: 24,
        s: -119717,
        e: [
            17
        ],
        l: 58
    },
    {
        h: 24,
        s: -119775,
        e: [
            17
        ],
        l: 58
    }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
    return values.reduce((accum, value)=>{
        value.forEach((value)=>{
            accum.push(value);
        });
        return accum;
    }, []);
}
function _nameprepTableA1(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
    let range = matchMap(codepoint, Table_B_2_ranges);
    if (range) return [
        codepoint + range.s
    ];
    let codes = Table_B_2_lut_abs[codepoint];
    if (codes) return codes;
    let shift = Table_B_2_lut_rel[codepoint];
    if (shift) return [
        codepoint + shift[0]
    ];
    let complex = Table_B_2_complex[codepoint];
    if (complex) return complex;
    return null;
}
function _nameprepTableC(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
    // This allows platforms with incomplete normalize to bypass
    // it for very basic names which the built-in toLowerCase
    // will certainly handle correctly
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) return value.toLowerCase();
    // Get the code points (keeping the current normalization)
    let codes = (0, _utf8.toUtf8CodePoints)(value);
    codes = flatten(codes.map((code)=>{
        // Substitute Table B.1 (Maps to Nothing)
        if (Table_B_1_flags.indexOf(code) >= 0) return [];
        if (code >= 0xfe00 && code <= 0xfe0f) return [];
        // Substitute Table B.2 (Case Folding)
        let codesTableB2 = _nameprepTableB2(code);
        if (codesTableB2) return codesTableB2;
        // No Substitution
        return [
            code
        ];
    }));
    // Normalize using form KC
    codes = (0, _utf8.toUtf8CodePoints)((0, _utf8._toUtf8String)(codes), (0, _utf8.UnicodeNormalizationForm).NFKC);
    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9
    codes.forEach((code)=>{
        if (_nameprepTableC(code)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    });
    // Prohibit Unassigned Code Points (Table A.1)
    codes.forEach((code)=>{
        if (_nameprepTableA1(code)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    });
    // IDNA extras
    let name = (0, _utf8._toUtf8String)(codes);
    // IDNA: 4.2.3.1
    if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") throw new Error("invalid hyphen");
    return name;
}

},{"./utf8":"dsMpR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Cp2hA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TupleCoder", ()=>TupleCoder);
var _abstractCoder = require("./abstract-coder");
var _array = require("./array");
"use strict";
class TupleCoder extends (0, _abstractCoder.Coder) {
    constructor(coders, localName){
        let dynamic = false;
        const types = [];
        coders.forEach((coder)=>{
            if (coder.dynamic) dynamic = true;
            types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder)=>{
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder)=>{
            const name = coder.localName;
            if (name) {
                if (!accum[name]) accum[name] = 0;
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index)=>{
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) return;
            if (name === "length") name = "_length";
            if (values[name] != null) return;
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return (0, _array.pack)(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, (0, _array.unpack)(reader, this.coders));
    }
}

},{"./abstract-coder":"hm9h5","./array":"doYUW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8nE5c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkResultErrors", ()=>(0, _abstractCoder.checkResultErrors));
parcelHelpers.export(exports, "LogDescription", ()=>LogDescription);
parcelHelpers.export(exports, "TransactionDescription", ()=>TransactionDescription);
parcelHelpers.export(exports, "ErrorDescription", ()=>ErrorDescription);
parcelHelpers.export(exports, "Indexed", ()=>Indexed);
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/ parcelHelpers.export(exports, "Interface", ()=>Interface);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _hash = require("@ethersproject/hash");
var _keccak256 = require("@ethersproject/keccak256");
var _properties = require("@ethersproject/properties");
var _abiCoder = require("./abi-coder");
var _abstractCoder = require("./coders/abstract-coder");
var _fragments = require("./fragments");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
class LogDescription extends (0, _properties.Description) {
}
class TransactionDescription extends (0, _properties.Description) {
}
class ErrorDescription extends (0, _properties.Description) {
}
class Indexed extends (0, _properties.Description) {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: [
            "string"
        ],
        reason: true
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: [
            "uint256"
        ]
    }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
class Interface {
    constructor(fragments){
        let abi = [];
        if (typeof fragments === "string") abi = JSON.parse(fragments);
        else abi = fragments;
        (0, _properties.defineReadOnly)(this, "fragments", abi.map((fragment)=>{
            return (0, _fragments.Fragment).from(fragment);
        }).filter((fragment)=>fragment != null));
        (0, _properties.defineReadOnly)(this, "_abiCoder", (0, _properties.getStatic)(new.target, "getAbiCoder")());
        (0, _properties.defineReadOnly)(this, "functions", {});
        (0, _properties.defineReadOnly)(this, "errors", {});
        (0, _properties.defineReadOnly)(this, "events", {});
        (0, _properties.defineReadOnly)(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment)=>{
            let bucket = null;
            switch(fragment.type){
                case "constructor":
                    if (this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    (0, _properties.defineReadOnly)(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) (0, _properties.defineReadOnly)(this, "deploy", (0, _fragments.ConstructorFragment).from({
            payable: false,
            type: "constructor"
        }));
        (0, _properties.defineReadOnly)(this, "_isInterface", true);
    }
    format(format) {
        if (!format) format = (0, _fragments.FormatTypes).full;
        if (format === (0, _fragments.FormatTypes).sighash) logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        const abi = this.fragments.map((fragment)=>fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === (0, _fragments.FormatTypes).json) return JSON.stringify(abi.map((j)=>JSON.parse(j)));
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return 0, _abiCoder.defaultAbiCoder;
    }
    static getAddress(address) {
        return (0, _address.getAddress)(address);
    }
    static getSighash(fragment) {
        return (0, _bytes.hexDataSlice)((0, _hash.id)(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return (0, _hash.id)(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if ((0, _bytes.isHexString)(nameOrSignatureOrSighash)) {
            for(const name in this.functions){
                if (nameOrSignatureOrSighash === this.getSighash(name)) return this.functions[name];
            }
            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f)=>f.split("(" /* fix:) */ )[0] === name);
            if (matching.length === 0) logger.throwArgumentError("no matching function", "name", name);
            else if (matching.length > 1) logger.throwArgumentError("multiple matching functions", "name", name);
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[(0, _fragments.FunctionFragment).fromString(nameOrSignatureOrSighash).format()];
        if (!result) logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if ((0, _bytes.isHexString)(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for(const name in this.events){
                if (topichash === this.getEventTopic(name)) return this.events[name];
            }
            logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f)=>f.split("(" /* fix:) */ )[0] === name);
            if (matching.length === 0) logger.throwArgumentError("no matching event", "name", name);
            else if (matching.length > 1) logger.throwArgumentError("multiple matching events", "name", name);
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[(0, _fragments.EventFragment).fromString(nameOrSignatureOrTopic).format()];
        if (!result) logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if ((0, _bytes.isHexString)(nameOrSignatureOrSighash)) {
            const getSighash = (0, _properties.getStatic)(this.constructor, "getSighash");
            for(const name in this.errors){
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) return this.errors[name];
            }
            logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f)=>f.split("(" /* fix:) */ )[0] === name);
            if (matching.length === 0) logger.throwArgumentError("no matching error", "name", name);
            else if (matching.length > 1) logger.throwArgumentError("multiple matching errors", "name", name);
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[(0, _fragments.FunctionFragment).fromString(nameOrSignatureOrSighash).format()];
        if (!result) logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof fragment === "string") try {
            fragment = this.getFunction(fragment);
        } catch (error) {
            try {
                fragment = this.getError(fragment);
            } catch (_) {
                throw error;
            }
        }
        return (0, _properties.getStatic)(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        return (0, _properties.getStatic)(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof fragment === "string") fragment = this.getError(fragment);
        const bytes = (0, _bytes.arrayify)(data);
        if ((0, _bytes.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", (0, _bytes.hexlify)(bytes));
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof fragment === "string") fragment = this.getError(fragment);
        return (0, _bytes.hexlify)((0, _bytes.concat)([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        const bytes = (0, _bytes.arrayify)(data);
        if ((0, _bytes.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", (0, _bytes.hexlify)(bytes));
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        return (0, _bytes.hexlify)((0, _bytes.concat)([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        let bytes = (0, _bytes.arrayify)(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch(bytes.length % this._abiCoder._getWordSize()){
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                } catch (error) {}
                break;
            case 4:
                {
                    const selector = (0, _bytes.hexlify)(bytes.slice(0, 4));
                    const builtin = BuiltinErrors[selector];
                    if (builtin) {
                        errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                        errorName = builtin.name;
                        errorSignature = builtin.signature;
                        if (builtin.reason) reason = errorArgs[0];
                        if (errorName === "Error") message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                        else if (errorName === "Panic") message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    } else try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    } catch (error) {}
                    break;
                }
        }
        return logger.throwError("call revert exception" + message, (0, _logger.Logger).errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: (0, _bytes.hexlify)(data),
            errorArgs,
            errorName,
            errorSignature,
            reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        return (0, _bytes.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        if (values.length > eventFragment.inputs.length) logger.throwError("too many arguments for " + eventFragment.format(), (0, _logger.Logger).errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
        });
        let topics = [];
        if (!eventFragment.anonymous) topics.push(this.getEventTopic(eventFragment));
        const encodeTopic = (param, value)=>{
            if (param.type === "string") return (0, _hash.id)(value);
            else if (param.type === "bytes") return (0, _keccak256.keccak256)((0, _bytes.hexlify)(value));
            if (param.type === "bool" && typeof value === "boolean") value = value ? "0x01" : "0x00";
            if (param.type.match(/^u?int/)) value = (0, _bignumber.BigNumber).from(value).toHexString();
            // Check addresses are valid
            if (param.type === "address") this._abiCoder.encode([
                "address"
            ], [
                value
            ]);
            return (0, _bytes.hexZeroPad)((0, _bytes.hexlify)(value), 32);
        };
        values.forEach((value, index)=>{
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) logger.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
                return;
            }
            if (value == null) topics.push(null);
            else if (param.baseType === "array" || param.baseType === "tuple") logger.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
            else if (Array.isArray(value)) topics.push(value.map((value)=>encodeTopic(param, value)));
            else topics.push(encodeTopic(param, value));
        });
        // Trim off trailing nulls
        while(topics.length && topics[topics.length - 1] === null)topics.pop();
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) topics.push(this.getEventTopic(eventFragment));
        if (values.length !== eventFragment.inputs.length) logger.throwArgumentError("event arguments/values mismatch", "values", values);
        eventFragment.inputs.forEach((param, index)=>{
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") topics.push((0, _hash.id)(value));
                else if (param.type === "bytes") topics.push((0, _keccak256.keccak256)(value));
                else if (param.baseType === "tuple" || param.baseType === "array") // @TODO
                throw new Error("not implemented");
                else topics.push(this._abiCoder.encode([
                    param.type
                ], [
                    value
                ]));
            } else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!(0, _bytes.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) logger.throwError("fragment/topic mismatch", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "topics[0]",
                expected: topicHash,
                value: topics[0]
            });
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index)=>{
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push((0, _fragments.ParamType).fromObject({
                        type: "bytes32",
                        name: param.name
                    }));
                    dynamic.push(true);
                } else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            } else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, _bytes.concat)(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index)=>{
            if (param.indexed) {
                if (resultIndexed == null) result[index] = new Indexed({
                    _isIndexed: true,
                    hash: null
                });
                else if (dynamic[index]) result[index] = new Indexed({
                    _isIndexed: true,
                    hash: resultIndexed[indexedIndex++]
                });
                else try {
                    result[index] = resultIndexed[indexedIndex++];
                } catch (error) {
                    result[index] = error;
                }
            } else try {
                result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
                result[index] = error;
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) Object.defineProperty(result, param.name, {
                    enumerable: true,
                    get: ()=>{
                        throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
                    }
                });
                else result[param.name] = value;
            }
        });
        // Make all error indexed values throw on access
        for(let i = 0; i < result.length; i++){
            const value = result[i];
            if (value instanceof Error) Object.defineProperty(result, i, {
                enumerable: true,
                get: ()=>{
                    throw wrapAccessError(`index ${i}`, value);
                }
            });
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) return null;
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: (0, _bignumber.BigNumber).from(tx.value || "0")
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) return null;
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = (0, _bytes.hexlify)(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) return null;
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment)
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */ static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

},{"@ethersproject/address":"ggdAz","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/hash":"7JYPm","@ethersproject/keccak256":"hXDEv","@ethersproject/properties":"h3GJb","./abi-coder":"4pw2B","./coders/abstract-coder":"hm9h5","./fragments":"jvsHr","@ethersproject/logger":"hLvB2","./_version":"9uxOS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7JYPm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "id", ()=>(0, _id.id));
parcelHelpers.export(exports, "dnsEncode", ()=>(0, _namehash.dnsEncode));
parcelHelpers.export(exports, "namehash", ()=>(0, _namehash.namehash));
parcelHelpers.export(exports, "isValidName", ()=>(0, _namehash.isValidName));
parcelHelpers.export(exports, "ensNormalize", ()=>(0, _namehash.ensNormalize));
parcelHelpers.export(exports, "messagePrefix", ()=>(0, _message.messagePrefix));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _message.hashMessage));
parcelHelpers.export(exports, "_TypedDataEncoder", ()=>(0, _typedData.TypedDataEncoder));
var _id = require("./id");
var _namehash = require("./namehash");
var _message = require("./message");
var _typedData = require("./typed-data");
"use strict";

},{"./id":"70HiZ","./namehash":"bSxC5","./message":"hJKk8","./typed-data":"lozox","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"70HiZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "id", ()=>id);
var _keccak256 = require("@ethersproject/keccak256");
var _strings = require("@ethersproject/strings");
function id(text) {
    return (0, _keccak256.keccak256)((0, _strings.toUtf8Bytes)(text));
}

},{"@ethersproject/keccak256":"hXDEv","@ethersproject/strings":"5TGFZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSxC5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensNormalize", ()=>ensNormalize);
parcelHelpers.export(exports, "isValidName", ()=>isValidName);
parcelHelpers.export(exports, "namehash", ()=>namehash);
parcelHelpers.export(exports, "dnsEncode", ()=>dnsEncode);
var _bytes = require("@ethersproject/bytes");
var _strings = require("@ethersproject/strings");
var _keccak256 = require("@ethersproject/keccak256");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _lib = require("./ens-normalize/lib");
const logger = new (0, _logger.Logger)((0, _version.version));
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
    if (comp.length === 0) throw new Error("invalid ENS name; empty component");
    return comp;
}
function ensNameSplit(name) {
    const bytes = (0, _strings.toUtf8Bytes)((0, _lib.ens_normalize)(name));
    const comps = [];
    if (name.length === 0) return comps;
    let last = 0;
    for(let i = 0; i < bytes.length; i++){
        const d = bytes[i];
        // A separator (i.e. "."); copy this component
        if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
        }
    }
    // There was a stray separator at the end of the name
    if (last >= bytes.length) throw new Error("invalid ENS name; empty component");
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
}
function ensNormalize(name) {
    return ensNameSplit(name).map((comp)=>(0, _strings.toUtf8String)(comp)).join(".");
}
function isValidName(name) {
    try {
        return ensNameSplit(name).length !== 0;
    } catch (error) {}
    return false;
}
function namehash(name) {
    /* istanbul ignore if */ if (typeof name !== "string") logger.throwArgumentError("invalid ENS name; not a string", "name", name);
    let result = Zeros;
    const comps = ensNameSplit(name);
    while(comps.length)result = (0, _keccak256.keccak256)((0, _bytes.concat)([
        result,
        (0, _keccak256.keccak256)(comps.pop())
    ]));
    return (0, _bytes.hexlify)(result);
}
function dnsEncode(name) {
    return (0, _bytes.hexlify)((0, _bytes.concat)(ensNameSplit(name).map((comp)=>{
        // DNS does not allow components over 63 bytes in length
        if (comp.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        const bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/strings":"5TGFZ","@ethersproject/keccak256":"hXDEv","@ethersproject/logger":"hLvB2","./_version":"kUuZu","./ens-normalize/lib":"f04Ft","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kUuZu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "hash/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f04Ft":[function(require,module,exports) {
/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ens_normalize_post_check", ()=>ens_normalize_post_check);
parcelHelpers.export(exports, "ens_normalize", ()=>ens_normalize);
var _strings = require("@ethersproject/strings");
var _includeJs = require("./include.js");
var _decoderJs = require("./decoder.js");
const r = (0, _includeJs.getData)();
// @TODO: This should be lazily loaded
const VALID = new Set((0, _decoderJs.read_member_array)(r));
const IGNORED = new Set((0, _decoderJs.read_member_array)(r));
const MAPPED = (0, _decoderJs.read_mapped_map)(r);
const EMOJI_ROOT = (0, _decoderJs.read_emoji_trie)(r);
//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));
//const STOP = 0x2E;
const HYPHEN = 0x2D;
const UNDERSCORE = 0x5F;
function explode_cp(name) {
    return (0, _strings.toUtf8CodePoints)(name);
}
function filter_fe0f(cps) {
    return cps.filter((cp)=>cp != 0xFE0F);
}
function ens_normalize_post_check(name) {
    for (let label of name.split(".")){
        let cps = explode_cp(label);
        try {
            for(let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--){
                if (cps[i] !== UNDERSCORE) throw new Error(`underscore only allowed at start`);
            }
            if (cps.length >= 4 && cps.every((cp)=>cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) throw new Error(`invalid label extension`);
        } catch (err) {
            throw new Error(`Invalid label "${label}": ${err.message}`);
        }
    }
    return name;
}
function ens_normalize(name) {
    return ens_normalize_post_check(normalize(name, filter_fe0f));
}
function normalize(name, emoji_filter) {
    let input = explode_cp(name).reverse(); // flip for pop
    let output = [];
    while(input.length){
        let emoji = consume_emoji_reversed(input);
        if (emoji) {
            output.push(...emoji_filter(emoji));
            continue;
        }
        let cp = input.pop();
        if (VALID.has(cp)) {
            output.push(cp);
            continue;
        }
        if (IGNORED.has(cp)) continue;
        let cps = MAPPED[cp];
        if (cps) {
            output.push(...cps);
            continue;
        }
        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
    }
    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s) {
    return s.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
    var _a;
    let node = EMOJI_ROOT;
    let emoji;
    let saved;
    let stack = [];
    let pos = cps.length;
    if (eaten) eaten.length = 0; // clear input buffer (if needed)
    while(pos){
        let cp = cps[--pos];
        node = (_a = node.branches.find((x)=>x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
        if (!node) break;
        if (node.save) saved = cp;
        else if (node.check) {
            if (cp === saved) break;
        }
        stack.push(cp);
        if (node.fe0f) {
            stack.push(0xFE0F);
            if (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F
        }
        if (node.valid) {
            emoji = stack.slice(); // copy stack
            if (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)
            if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)
            cps.length = pos; // truncate
        }
    }
    return emoji;
}

},{"@ethersproject/strings":"5TGFZ","./include.js":"fe7hh","./decoder.js":"k3KbO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fe7hh":[function(require,module,exports) {
/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getData", ()=>getData);
var _base64 = require("@ethersproject/base64");
var _decoderJs = require("./decoder.js");
function getData() {
    return (0, _decoderJs.read_compressed_payload)((0, _base64.decode)("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}

},{"@ethersproject/base64":"329Wu","./decoder.js":"k3KbO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"329Wu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>(0, _base64.decode));
parcelHelpers.export(exports, "encode", ()=>(0, _base64.encode));
var _base64 = require("./base64");
"use strict";

},{"./base64":"cgzIg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgzIg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "encode", ()=>encode);
var _bytes = require("@ethersproject/bytes");
"use strict";
function decode(textData) {
    textData = atob(textData);
    const data = [];
    for(let i = 0; i < textData.length; i++)data.push(textData.charCodeAt(i));
    return (0, _bytes.arrayify)(data);
}
function encode(data) {
    data = (0, _bytes.arrayify)(data);
    let textData = "";
    for(let i = 0; i < data.length; i++)textData += String.fromCharCode(data[i]);
    return btoa(textData);
}

},{"@ethersproject/bytes":"htrqZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k3KbO":[function(require,module,exports) {
/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */ // https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode_arithmetic", ()=>decode_arithmetic);
// returns an iterator which returns the next symbol
parcelHelpers.export(exports, "read_payload", ()=>read_payload);
parcelHelpers.export(exports, "read_compressed_payload", ()=>read_compressed_payload);
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
parcelHelpers.export(exports, "signed", ()=>signed);
parcelHelpers.export(exports, "read_member_array", ()=>read_member_array);
// returns array of 
// [x, ys] => single replacement rule
// [x, ys, n, dx, dx] => linear map
parcelHelpers.export(exports, "read_mapped_map", ()=>read_mapped_map);
parcelHelpers.export(exports, "read_zero_terminated_array", ()=>read_zero_terminated_array);
parcelHelpers.export(exports, "read_emoji_trie", ()=>read_emoji_trie);
function flat(array, depth) {
    if (depth == null) depth = 1;
    const result = [];
    const forEach = result.forEach;
    const flatDeep = function(arr, depth) {
        forEach.call(arr, function(val) {
            if (depth > 0 && Array.isArray(val)) flatDeep(val, depth - 1);
            else result.push(val);
        });
    };
    flatDeep(array, depth);
    return result;
}
function fromEntries(array) {
    const result = {};
    for(let i = 0; i < array.length; i++){
        const value = array[i];
        result[value[0]] = value[1];
    }
    return result;
}
function decode_arithmetic(bytes) {
    let pos = 0;
    function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
    }
    // decode the frequency table
    let symbol_count = u16();
    let total = 1;
    let acc = [
        0,
        1
    ]; // first symbol has frequency 1
    for(let i = 1; i < symbol_count; i++)acc.push(total += u16());
    // skip the sized-payload that the last 3 symbols index into
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
        if (read_width == 0) {
            // this will read beyond end of buffer
            // but (undefined|0) => zero pad
            read_buffer = read_buffer << 8 | bytes[pos++];
            read_width = 8;
        }
        return read_buffer >> --read_width & 1;
    }
    const N = 31;
    const FULL = Math.pow(2, N);
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    // fill register
    let register = 0;
    for(let i = 0; i < N; i++)register = register << 1 | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL; // treat like a float
    while(true){
        let value = Math.floor(((register - low + 1) * total - 1) / range);
        let start = 0;
        let end = symbol_count;
        while(end - start > 1){
            let mid = start + end >>> 1;
            if (value < acc[mid]) end = mid;
            else start = mid;
        }
        if (start == 0) break; // first symbol is end mark
        symbols.push(start);
        let a = low + Math.floor(range * acc[start] / total);
        let b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while(((a ^ b) & HALF) == 0){
            register = register << 1 & MASK | read_bit();
            a = a << 1 & MASK;
            b = b << 1 & MASK | 1;
        }
        while(a & ~b & QRTR){
            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
            a = a << 1 ^ HALF;
            b = (b ^ HALF) << 1 | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
    }
    let offset = symbol_count - 4;
    return symbols.map((x)=>{
        switch(x - offset){
            case 3:
                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 2:
                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 1:
                return offset + bytes[pos_payload++];
            default:
                return x - 1;
        }
    });
}
function read_payload(v) {
    let pos = 0;
    return ()=>v[pos++];
}
function read_compressed_payload(bytes) {
    return read_payload(decode_arithmetic(bytes));
}
function signed(i) {
    return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n, next) {
    let v = Array(n);
    for(let i = 0; i < n; i++)v[i] = 1 + next();
    return v;
}
function read_ascending(n, next) {
    let v = Array(n);
    for(let i = 0, x = -1; i < n; i++)v[i] = x += 1 + next();
    return v;
}
function read_deltas(n, next) {
    let v = Array(n);
    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());
    return v;
}
function read_member_array(next, lookup) {
    let v = read_ascending(next(), next);
    let n = next();
    let vX = read_ascending(n, next);
    let vN = read_counts(n, next);
    for(let i = 0; i < n; i++)for(let j = 0; j < vN[i]; j++)v.push(vX[i] + j);
    return lookup ? v.map((x)=>lookup[x]) : v;
}
function read_mapped_map(next) {
    let ret = [];
    while(true){
        let w = next();
        if (w == 0) break;
        ret.push(read_linear_table(w, next));
    }
    while(true){
        let w = next() - 1;
        if (w < 0) break;
        ret.push(read_replacement_table(w, next));
    }
    return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
    let v = [];
    while(true){
        let i = next();
        if (i == 0) break;
        v.push(i);
    }
    return v;
}
function read_transposed(n, w, next) {
    let m = Array(n).fill(undefined).map(()=>[]);
    for(let i = 0; i < w; i++)read_deltas(n, next).forEach((x, j)=>m[j].push(x));
    return m;
}
function read_linear_table(w, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_zero_terminated_array(next);
    let m = read_transposed(vN.length, 1 + w, next);
    return flat(m.map((v, i)=>{
        const x = v[0], ys = v.slice(1);
        //let [x, ...ys] = v;
        //return Array(vN[i]).fill().map((_, j) => {
        return Array(vN[i]).fill(undefined).map((_, j)=>{
            let j_dy = j * dy;
            return [
                x + j * dx,
                ys.map((y)=>y + j_dy)
            ];
        });
    }));
}
function read_replacement_table(w, next) {
    let n = 1 + next();
    let m = read_transposed(n, 1 + w, next);
    return m.map((v)=>[
            v[0],
            v.slice(1)
        ]);
}
function read_emoji_trie(next) {
    let sorted = read_member_array(next).sort((a, b)=>a - b);
    return read();
    function read() {
        let branches = [];
        while(true){
            let keys = read_member_array(next, sorted);
            if (keys.length == 0) break;
            branches.push({
                set: new Set(keys),
                node: read()
            });
        }
        branches.sort((a, b)=>b.set.size - a.set.size); // sort by likelihood
        let temp = next();
        let valid = temp % 3;
        temp = temp / 3 | 0;
        let fe0f = !!(temp & 1);
        temp >>= 1;
        let save = temp == 1;
        let check = temp == 2;
        return {
            branches,
            valid,
            fe0f,
            save,
            check
        };
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hJKk8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messagePrefix", ()=>messagePrefix);
parcelHelpers.export(exports, "hashMessage", ()=>hashMessage);
var _bytes = require("@ethersproject/bytes");
var _keccak256 = require("@ethersproject/keccak256");
var _strings = require("@ethersproject/strings");
const messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
    if (typeof message === "string") message = (0, _strings.toUtf8Bytes)(message);
    return (0, _keccak256.keccak256)((0, _bytes.concat)([
        (0, _strings.toUtf8Bytes)(messagePrefix),
        (0, _strings.toUtf8Bytes)(String(message.length)),
        message
    ]));
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/keccak256":"hXDEv","@ethersproject/strings":"5TGFZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lozox":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypedDataEncoder", ()=>TypedDataEncoder);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _keccak256 = require("@ethersproject/keccak256");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _id = require("./id");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = (0, _bignumber.BigNumber).from(-1);
const Zero = (0, _bignumber.BigNumber).from(0);
const One = (0, _bignumber.BigNumber).from(1);
const MaxUint256 = (0, _bignumber.BigNumber).from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    const bytes = (0, _bytes.arrayify)(value);
    const padOffset = bytes.length % 32;
    if (padOffset) return (0, _bytes.hexConcat)([
        bytes,
        padding.slice(padOffset)
    ]);
    return (0, _bytes.hexlify)(bytes);
}
const hexTrue = (0, _bytes.hexZeroPad)(One.toHexString(), 32);
const hexFalse = (0, _bytes.hexZeroPad)(Zero.toHexString(), 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
];
function checkString(key) {
    return function(value) {
        if (typeof value !== "string") logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function(value) {
        try {
            return (0, _bignumber.BigNumber).from(value).toString();
        } catch (error) {}
        return logger.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function(value) {
        try {
            return (0, _address.getAddress)(value).toLowerCase();
        } catch (error) {}
        return logger.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function(value) {
        try {
            const bytes = (0, _bytes.arrayify)(value);
            if (bytes.length !== 32) throw new Error("bad length");
            return (0, _bytes.hexlify)(bytes);
        } catch (error) {}
        return logger.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d*)$/);
        if (match) {
            const signed = match[1] === "";
            const width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) logger.throwArgumentError("invalid numeric width", "type", type);
            const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);
            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
            return function(value) {
                const v = (0, _bignumber.BigNumber).from(value);
                if (v.lt(boundsLower) || v.gt(boundsUpper)) logger.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
                return (0, _bytes.hexZeroPad)(v.toTwos(256).toHexString(), 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            if (width === 0 || width > 32 || match[1] !== String(width)) logger.throwArgumentError("invalid bytes width", "type", type);
            return function(value) {
                const bytes = (0, _bytes.arrayify)(value);
                if (bytes.length !== width) logger.throwArgumentError(`invalid length for ${type}`, "value", value);
                return hexPadRight(value);
            };
        }
    }
    switch(type){
        case "address":
            return function(value) {
                return (0, _bytes.hexZeroPad)((0, _address.getAddress)(value), 32);
            };
        case "bool":
            return function(value) {
                return !value ? hexFalse : hexTrue;
            };
        case "bytes":
            return function(value) {
                return (0, _keccak256.keccak256)(value);
            };
        case "string":
            return function(value) {
                return (0, _id.id)(value);
            };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type })=>type + " " + name).join(",")})`;
}
class TypedDataEncoder {
    constructor(types){
        (0, _properties.defineReadOnly)(this, "types", Object.freeze((0, _properties.deepCopy)(types)));
        (0, _properties.defineReadOnly)(this, "_encoderCache", {});
        (0, _properties.defineReadOnly)(this, "_types", {});
        // Link struct types to their direct child structs
        const links = {};
        // Link structs to structs which contain them as a child
        const parents = {};
        // Link all subtypes within a given struct
        const subtypes = {};
        Object.keys(types).forEach((type)=>{
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
        });
        for(const name in types){
            const uniqueNames = {};
            types[name].forEach((field)=>{
                // Check each field has a unique name
                if (uniqueNames[field.name]) logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
                uniqueNames[field.name] = true;
                // Get the base type (drop any array specifiers)
                const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name) logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) return;
                if (!parents[baseType]) logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
                // Add linkage
                parents[baseType].push(name);
                links[name][baseType] = true;
            });
        }
        // Deduce the primary type
        const primaryTypes = Object.keys(parents).filter((n)=>parents[n].length === 0);
        if (primaryTypes.length === 0) logger.throwArgumentError("missing primary type", "types", types);
        else if (primaryTypes.length > 1) logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(", ")}`, "types", types);
        (0, _properties.defineReadOnly)(this, "primaryType", primaryTypes[0]);
        // Check for circular type references
        function checkCircular(type, found) {
            if (found[type]) logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
            found[type] = true;
            Object.keys(links[type]).forEach((child)=>{
                if (!parents[child]) return;
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                Object.keys(found).forEach((subtype)=>{
                    subtypes[subtype][child] = true;
                });
            });
            delete found[type];
        }
        checkCircular(this.primaryType, {});
        // Compute each fully describe type
        for(const name in subtypes){
            const st = Object.keys(subtypes[name]);
            st.sort();
            this._types[name] = encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join("");
        }
    }
    getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) encoder = this._encoderCache[type] = this._getEncoder(type);
        return encoder;
    }
    _getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) return encoder;
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const subEncoder = this.getEncoder(subtype);
            const length = parseInt(match[3]);
            return (value)=>{
                if (length >= 0 && value.length !== length) logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                let result = value.map(subEncoder);
                if (this._types[subtype]) result = result.map((0, _keccak256.keccak256));
                return (0, _keccak256.keccak256)((0, _bytes.hexConcat)(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = (0, _id.id)(this._types[type]);
            return (value)=>{
                const values = fields.map(({ name, type })=>{
                    const result = this.getEncoder(type)(value[name]);
                    if (this._types[type]) return (0, _keccak256.keccak256)(result);
                    return result;
                });
                values.unshift(encodedType);
                return (0, _bytes.hexConcat)(values);
            };
        }
        return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name) {
        const result = this._types[name];
        if (!result) logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        return result;
    }
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    hashStruct(name, value) {
        return (0, _keccak256.keccak256)(this.encodeData(name, value));
    }
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) return callback(type, value);
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const length = parseInt(match[3]);
            if (length >= 0 && value.length !== length) logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            return value.map((v)=>this._visit(subtype, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) return fields.reduce((accum, { name, type })=>{
            accum[name] = this._visit(type, value[name], callback);
            return accum;
        }, {});
        return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
        return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    static hashDomain(domain) {
        const domainFields = [];
        for(const name in domain){
            const type = domainFieldTypes[name];
            if (!type) logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            domainFields.push({
                name,
                type
            });
        }
        domainFields.sort((a, b)=>{
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", {
            EIP712Domain: domainFields
        }, domain);
    }
    static encode(domain, types, value) {
        return (0, _bytes.hexConcat)([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    static hash(domain, types, value) {
        return (0, _keccak256.keccak256)(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    static resolveNames(domain, types, value, resolveName) {
        return __awaiter(this, void 0, void 0, function*() {
            // Make a copy to isolate it from the object passed in
            domain = (0, _properties.shallowCopy)(domain);
            // Look up all ENS names
            const ensCache = {};
            // Do we need to look up the domain's verifyingContract?
            if (domain.verifyingContract && !(0, _bytes.isHexString)(domain.verifyingContract, 20)) ensCache[domain.verifyingContract] = "0x";
            // We are going to use the encoder to visit all the base values
            const encoder = TypedDataEncoder.from(types);
            // Get a list of all the addresses
            encoder.visit(value, (type, value)=>{
                if (type === "address" && !(0, _bytes.isHexString)(value, 20)) ensCache[value] = "0x";
                return value;
            });
            // Lookup each name
            for(const name in ensCache)ensCache[name] = yield resolveName(name);
            // Replace the domain verifyingContract if needed
            if (domain.verifyingContract && ensCache[domain.verifyingContract]) domain.verifyingContract = ensCache[domain.verifyingContract];
            // Replace all ENS names with their address
            value = encoder.visit(value, (type, value)=>{
                if (type === "address" && ensCache[value]) return ensCache[value];
                return value;
            });
            return {
                domain,
                value
            };
        });
    }
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name)=>{
            const value = domain[name];
            if (value == null) return;
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({
                name,
                type: domainFieldTypes[name]
            });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = (0, _properties.shallowCopy)(types);
        if (typesWithDomain.EIP712Domain) logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        else typesWithDomain.EIP712Domain = domainTypes;
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value)=>{
                // bytes
                if (type.match(/^bytes(\d*)/)) return (0, _bytes.hexlify)((0, _bytes.arrayify)(value));
                // uint or int
                if (type.match(/^u?int/)) return (0, _bignumber.BigNumber).from(value).toString();
                switch(type){
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        if (typeof value !== "string") logger.throwArgumentError(`invalid string`, "value", value);
                        return value;
                }
                return logger.throwArgumentError("unsupported type", "type", type);
            })
        };
    }
}

},{"@ethersproject/address":"ggdAz","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/keccak256":"hXDEv","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"kUuZu","./id":"70HiZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g1jr1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
//export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};
parcelHelpers.export(exports, "ForkEvent", ()=>ForkEvent);
parcelHelpers.export(exports, "BlockForkEvent", ()=>BlockForkEvent);
parcelHelpers.export(exports, "TransactionForkEvent", ()=>TransactionForkEvent);
parcelHelpers.export(exports, "TransactionOrderForkEvent", ()=>TransactionOrderForkEvent);
///////////////////////////////
// Exported Abstracts
parcelHelpers.export(exports, "Provider", ()=>Provider);
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
class ForkEvent extends (0, _properties.Description) {
    static isForkEvent(value) {
        return !!(value && value._isForkEvent);
    }
}
class BlockForkEvent extends ForkEvent {
    constructor(blockHash, expiry){
        if (!(0, _bytes.isHexString)(blockHash, 32)) logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        super({
            _isForkEvent: true,
            _isBlockForkEvent: true,
            expiry: expiry || 0,
            blockHash: blockHash
        });
    }
}
class TransactionForkEvent extends ForkEvent {
    constructor(hash, expiry){
        if (!(0, _bytes.isHexString)(hash, 32)) logger.throwArgumentError("invalid transaction hash", "hash", hash);
        super({
            _isForkEvent: true,
            _isTransactionForkEvent: true,
            expiry: expiry || 0,
            hash: hash
        });
    }
}
class TransactionOrderForkEvent extends ForkEvent {
    constructor(beforeHash, afterHash, expiry){
        if (!(0, _bytes.isHexString)(beforeHash, 32)) logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        if (!(0, _bytes.isHexString)(afterHash, 32)) logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        super({
            _isForkEvent: true,
            _isTransactionOrderForkEvent: true,
            expiry: expiry || 0,
            beforeHash: beforeHash,
            afterHash: afterHash
        });
    }
}
class Provider {
    constructor(){
        logger.checkAbstract(new.target, Provider);
        (0, _properties.defineReadOnly)(this, "_isProvider", true);
    }
    getFeeData() {
        return __awaiter(this, void 0, void 0, function*() {
            const { block, gasPrice } = yield (0, _properties.resolveProperties)({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((error)=>{
                    // @TODO: Why is this now failing on Calaveras?
                    //console.log(error);
                    return null;
                })
            });
            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
            if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                lastBaseFeePerGas = block.baseFeePerGas;
                maxPriorityFeePerGas = (0, _bignumber.BigNumber).from("1500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
            }
            return {
                lastBaseFeePerGas,
                maxFeePerGas,
                maxPriorityFeePerGas,
                gasPrice
            };
        });
    }
    // Alias for "on"
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}

},{"@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"7ahSC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ahSC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "abstract-provider/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g9Ey5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Signer", ()=>Signer);
parcelHelpers.export(exports, "VoidSigner", ()=>VoidSigner);
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const allowedTransactionKeys = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value"
];
const forwardErrors = [
    (0, _logger.Logger).errors.INSUFFICIENT_FUNDS,
    (0, _logger.Logger).errors.NONCE_EXPIRED,
    (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED
];
class Signer {
    ///////////////////
    // Sub-classes MUST call super
    constructor(){
        logger.checkAbstract(new.target, Signer);
        (0, _properties.defineReadOnly)(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getBalance");
            return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
    }
    getTransactionCount(blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getTransactionCount");
            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("estimateGas");
            const tx = yield (0, _properties.resolveProperties)(this.checkTransaction(transaction));
            return yield this.provider.estimateGas(tx);
        });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("call");
            const tx = yield (0, _properties.resolveProperties)(this.checkTransaction(transaction));
            return yield this.provider.call(tx, blockTag);
        });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("sendTransaction");
            const tx = yield this.populateTransaction(transaction);
            const signedTx = yield this.signTransaction(tx);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
    getChainId() {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getChainId");
            const network = yield this.provider.getNetwork();
            return network.chainId;
        });
    }
    getGasPrice() {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getGasPrice");
            return yield this.provider.getGasPrice();
        });
    }
    getFeeData() {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getFeeData");
            return yield this.provider.getFeeData();
        });
    }
    resolveName(name) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("resolveName");
            return yield this.provider.resolveName(name);
        });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
        for(const key in transaction)if (allowedTransactionKeys.indexOf(key) === -1) logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
        const tx = (0, _properties.shallowCopy)(transaction);
        if (tx.from == null) tx.from = this.getAddress();
        else // Make sure any provided address matches this signer
        tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
        ]).then((result)=>{
            if (result[0].toLowerCase() !== result[1].toLowerCase()) logger.throwArgumentError("from address mismatch", "transaction", transaction);
            return result[0];
        });
        return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            const tx = yield (0, _properties.resolveProperties)(this.checkTransaction(transaction));
            if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then((to)=>__awaiter(this, void 0, void 0, function*() {
                        if (to == null) return null;
                        const address = yield this.resolveName(to);
                        if (address == null) logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                        return address;
                    }));
                // Prevent this error from causing an UnhandledPromiseException
                tx.to.catch((error)=>{});
            }
            // Do not allow mixing pre-eip-1559 and eip-1559 properties
            const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
            if ((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null) // Fully-formed EIP-1559 transaction (skip getFeeData)
            tx.type = 2;
            else if (tx.type === 0 || tx.type === 1) // Explicit Legacy or EIP-2930 transaction
            // Populate missing gasPrice
            {
                if (tx.gasPrice == null) tx.gasPrice = this.getGasPrice();
            } else {
                // We need to get fee data to determine things
                const feeData = yield this.getFeeData();
                if (tx.type == null) {
                    // We need to auto-detect the intended type of this transaction...
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        // The network supports EIP-1559!
                        // Upgrade transaction from null to eip-1559
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                            // Using legacy gasPrice property on an eip-1559 network,
                            // so use gasPrice as both fee properties
                            const gasPrice = tx.gasPrice;
                            delete tx.gasPrice;
                            tx.maxFeePerGas = gasPrice;
                            tx.maxPriorityFeePerGas = gasPrice;
                        } else {
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) tx.maxFeePerGas = feeData.maxFeePerGas;
                            if (tx.maxPriorityFeePerGas == null) tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                        }
                    } else if (feeData.gasPrice != null) {
                        // Network doesn't support EIP-1559...
                        // ...but they are trying to use EIP-1559 properties
                        if (hasEip1559) logger.throwError("network does not support EIP-1559", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                            operation: "populateTransaction"
                        });
                        // Populate missing fee data
                        if (tx.gasPrice == null) tx.gasPrice = feeData.gasPrice;
                        // Explicitly set untyped transaction to legacy
                        tx.type = 0;
                    } else // getFeeData has failed us.
                    logger.throwError("failed to get consistent fee data", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                        operation: "signer.getFeeData"
                    });
                } else if (tx.type === 2) {
                    // Explicitly using EIP-1559
                    // Populate missing fee data
                    if (tx.maxFeePerGas == null) tx.maxFeePerGas = feeData.maxFeePerGas;
                    if (tx.maxPriorityFeePerGas == null) tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
            }
            if (tx.nonce == null) tx.nonce = this.getTransactionCount("pending");
            if (tx.gasLimit == null) tx.gasLimit = this.estimateGas(tx).catch((error)=>{
                if (forwardErrors.indexOf(error.code) >= 0) throw error;
                return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: error,
                    tx: tx
                });
            });
            if (tx.chainId == null) tx.chainId = this.getChainId();
            else tx.chainId = Promise.all([
                Promise.resolve(tx.chainId),
                this.getChainId()
            ]).then((results)=>{
                if (results[1] !== 0 && results[0] !== results[1]) logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                return results[0];
            });
            return yield (0, _properties.resolveProperties)(tx);
        });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
        if (!this.provider) logger.throwError("missing provider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
        });
    }
    static isSigner(value) {
        return !!(value && value._isSigner);
    }
}
class VoidSigner extends Signer {
    constructor(address, provider){
        super();
        (0, _properties.defineReadOnly)(this, "address", address);
        (0, _properties.defineReadOnly)(this, "provider", provider || null);
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    _fail(message, operation) {
        return Promise.resolve().then(()=>{
            logger.throwError(message, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: operation
            });
        });
    }
    signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
}

},{"@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"jstYZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jstYZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "abstract-signer/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1ust":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TransactionTypes", ()=>TransactionTypes);
parcelHelpers.export(exports, "computeAddress", ()=>computeAddress);
parcelHelpers.export(exports, "recoverAddress", ()=>recoverAddress);
parcelHelpers.export(exports, "accessListify", ()=>accessListify);
parcelHelpers.export(exports, "serialize", ()=>serialize);
parcelHelpers.export(exports, "parse", ()=>parse);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _constants = require("@ethersproject/constants");
var _keccak256 = require("@ethersproject/keccak256");
var _properties = require("@ethersproject/properties");
var _rlp = require("@ethersproject/rlp");
var _signingKey = require("@ethersproject/signing-key");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
var TransactionTypes;
(function(TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
///////////////////////////////
function handleAddress(value) {
    if (value === "0x") return null;
    return (0, _address.getAddress)(value);
}
function handleNumber(value) {
    if (value === "0x") return 0, _constants.Zero;
    return (0, _bignumber.BigNumber).from(value);
}
// Legacy Transaction Fields
const transactionFields = [
    {
        name: "nonce",
        maxLength: 32,
        numeric: true
    },
    {
        name: "gasPrice",
        maxLength: 32,
        numeric: true
    },
    {
        name: "gasLimit",
        maxLength: 32,
        numeric: true
    },
    {
        name: "to",
        length: 20
    },
    {
        name: "value",
        maxLength: 32,
        numeric: true
    },
    {
        name: "data"
    }
];
const allowedTransactionKeys = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    type: true,
    value: true
};
function computeAddress(key) {
    const publicKey = (0, _signingKey.computePublicKey)(key);
    return (0, _address.getAddress)((0, _bytes.hexDataSlice)((0, _keccak256.keccak256)((0, _bytes.hexDataSlice)(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
    return computeAddress((0, _signingKey.recoverPublicKey)((0, _bytes.arrayify)(digest), signature));
}
function formatNumber(value, name) {
    const result = (0, _bytes.stripZeros)((0, _bignumber.BigNumber).from(value).toHexString());
    if (result.length > 32) logger.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
    return result;
}
function accessSetify(addr, storageKeys) {
    return {
        address: (0, _address.getAddress)(addr),
        storageKeys: (storageKeys || []).map((storageKey, index)=>{
            if ((0, _bytes.hexDataLength)(storageKey) !== 32) logger.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) return value.map((set, index)=>{
        if (Array.isArray(set)) {
            if (set.length > 2) logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
            return accessSetify(set[0], set[1]);
        }
        return accessSetify(set.address, set.storageKeys);
    });
    const result = Object.keys(value).map((addr)=>{
        const storageKeys = value[addr].reduce((accum, storageKey)=>{
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b)=>a.address.localeCompare(b.address));
    return result;
}
function formatAccessList(value) {
    return accessListify(value).map((set)=>[
            set.address,
            set.storageKeys
        ]);
}
function _serializeEip1559(transaction, signature) {
    // If there is an explicit gasPrice, make sure it matches the
    // EIP-1559 fees; otherwise they may not understand what they
    // think they are setting in terms of fee.
    if (transaction.gasPrice != null) {
        const gasPrice = (0, _bignumber.BigNumber).from(transaction.gasPrice);
        const maxFeePerGas = (0, _bignumber.BigNumber).from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice,
            maxFeePerGas
        });
    }
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, _address.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
    ];
    if (signature) {
        const sig = (0, _bytes.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, _bytes.stripZeros)(sig.r));
        fields.push((0, _bytes.stripZeros)(sig.s));
    }
    return (0, _bytes.hexConcat)([
        "0x02",
        _rlp.encode(fields)
    ]);
}
function _serializeEip2930(transaction, signature) {
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, _address.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
    ];
    if (signature) {
        const sig = (0, _bytes.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, _bytes.stripZeros)(sig.r));
        fields.push((0, _bytes.stripZeros)(sig.s));
    }
    return (0, _bytes.hexConcat)([
        "0x01",
        _rlp.encode(fields)
    ]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
    (0, _properties.checkProperties)(transaction, allowedTransactionKeys);
    const raw = [];
    transactionFields.forEach(function(fieldInfo) {
        let value = transaction[fieldInfo.name] || [];
        const options = {};
        if (fieldInfo.numeric) options.hexPad = "left";
        value = (0, _bytes.arrayify)((0, _bytes.hexlify)(value, options));
        // Fixed-width field
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        // Variable-width (with a maximum)
        if (fieldInfo.maxLength) {
            value = (0, _bytes.stripZeros)(value);
            if (value.length > fieldInfo.maxLength) logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
        raw.push((0, _bytes.hexlify)(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = transaction.chainId;
        if (typeof chainId !== "number") logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    } else if (signature && !(0, _bytes.isBytesLike)(signature) && signature.v > 28) // No chainId provided, but the signature is signing with EIP-155; derive chainId
    chainId = Math.floor((signature.v - 35) / 2);
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== 0) {
        raw.push((0, _bytes.hexlify)(chainId)); // @TODO: hexValue?
        raw.push("0x");
        raw.push("0x");
    }
    // Requesting an unsigned transaction
    if (!signature) return _rlp.encode(raw);
    // The splitSignature will ensure the transaction has a recoveryParam in the
    // case that the signTransaction function only adds a v.
    const sig = (0, _bytes.splitSignature)(signature);
    // We pushed a chainId and null r, s on for hashing only; remove those
    let v = 27 + sig.recoveryParam;
    if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
        if (sig.v > 28 && sig.v !== v) logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    } else if (sig.v !== v) logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    raw.push((0, _bytes.hexlify)(v));
    raw.push((0, _bytes.stripZeros)((0, _bytes.arrayify)(sig.r)));
    raw.push((0, _bytes.stripZeros)((0, _bytes.arrayify)(sig.s)));
    return _rlp.encode(raw);
}
function serialize(transaction, signature) {
    // Legacy and EIP-155 Transactions
    if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        return _serialize(transaction, signature);
    }
    // Typed Transactions (EIP-2718)
    switch(transaction.type){
        case 1:
            return _serializeEip2930(transaction, signature);
        case 2:
            return _serializeEip1559(transaction, signature);
        default:
            break;
    }
    return logger.throwError(`unsupported transaction type: ${transaction.type}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
    });
}
function _parseEipSignature(tx, fields, serialize) {
    try {
        const recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) throw new Error("bad recid");
        tx.v = recid;
    } catch (error) {
        logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = (0, _bytes.hexZeroPad)(fields[1], 32);
    tx.s = (0, _bytes.hexZeroPad)(fields[2], 32);
    try {
        const digest = (0, _keccak256.keccak256)(serialize(tx));
        tx.from = recoverAddress(digest, {
            r: tx.r,
            s: tx.s,
            recoveryParam: tx.v
        });
    } catch (error) {}
}
function _parseEip1559(payload) {
    const transaction = _rlp.decode(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) logger.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, _bytes.hexlify)(payload));
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        maxFeePerGas: maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8])
    };
    // Unsigned EIP-1559 Transaction
    if (transaction.length === 9) return tx;
    tx.hash = (0, _keccak256.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
}
function _parseEip2930(payload) {
    const transaction = _rlp.decode(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) logger.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, _bytes.hexlify)(payload));
    const tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
    };
    // Unsigned EIP-2930 Transaction
    if (transaction.length === 8) return tx;
    tx.hash = (0, _keccak256.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
    const transaction = _rlp.decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    const tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) return tx;
    try {
        tx.v = (0, _bignumber.BigNumber).from(transaction[6]).toNumber();
    } catch (error) {
        // @TODO: What makes snese to do? The v is too big
        return tx;
    }
    tx.r = (0, _bytes.hexZeroPad)(transaction[7], 32);
    tx.s = (0, _bytes.hexZeroPad)(transaction[8], 32);
    if ((0, _bignumber.BigNumber).from(tx.r).isZero() && (0, _bignumber.BigNumber).from(tx.s).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.v;
        tx.v = 0;
    } else {
        // Signed Transaction
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) tx.chainId = 0;
        let recoveryParam = tx.v - 27;
        const raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push((0, _bytes.hexlify)(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
        }
        const digest = (0, _keccak256.keccak256)(_rlp.encode(raw));
        try {
            tx.from = recoverAddress(digest, {
                r: (0, _bytes.hexlify)(tx.r),
                s: (0, _bytes.hexlify)(tx.s),
                recoveryParam: recoveryParam
            });
        } catch (error) {}
        tx.hash = (0, _keccak256.keccak256)(rawTransaction);
    }
    tx.type = null;
    return tx;
}
function parse(rawTransaction) {
    const payload = (0, _bytes.arrayify)(rawTransaction);
    // Legacy and EIP-155 Transactions
    if (payload[0] > 0x7f) return _parse(payload);
    // Typed Transaction (EIP-2718)
    switch(payload[0]){
        case 1:
            return _parseEip2930(payload);
        case 2:
            return _parseEip1559(payload);
        default:
            break;
    }
    return logger.throwError(`unsupported transaction type: ${payload[0]}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
    });
}

},{"@ethersproject/address":"ggdAz","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/constants":"gKbDE","@ethersproject/keccak256":"hXDEv","@ethersproject/properties":"h3GJb","@ethersproject/rlp":"b2vlp","@ethersproject/signing-key":"krGB2","@ethersproject/logger":"hLvB2","./_version":"7piXV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"krGB2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SigningKey", ()=>SigningKey);
parcelHelpers.export(exports, "recoverPublicKey", ()=>recoverPublicKey);
parcelHelpers.export(exports, "computePublicKey", ()=>computePublicKey);
var _elliptic = require("./elliptic");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
let _curve = null;
function getCurve() {
    if (!_curve) _curve = new (0, _elliptic.EC)("secp256k1");
    return _curve;
}
class SigningKey {
    constructor(privateKey){
        (0, _properties.defineReadOnly)(this, "curve", "secp256k1");
        (0, _properties.defineReadOnly)(this, "privateKey", (0, _bytes.hexlify)(privateKey));
        if ((0, _bytes.hexDataLength)(this.privateKey) !== 32) logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        const keyPair = getCurve().keyFromPrivate((0, _bytes.arrayify)(this.privateKey));
        (0, _properties.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        (0, _properties.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        (0, _properties.defineReadOnly)(this, "_isSigningKey", true);
    }
    _addPoint(other) {
        const p0 = getCurve().keyFromPublic((0, _bytes.arrayify)(this.publicKey));
        const p1 = getCurve().keyFromPublic((0, _bytes.arrayify)(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest) {
        const keyPair = getCurve().keyFromPrivate((0, _bytes.arrayify)(this.privateKey));
        const digestBytes = (0, _bytes.arrayify)(digest);
        if (digestBytes.length !== 32) logger.throwArgumentError("bad digest length", "digest", digest);
        const signature = keyPair.sign(digestBytes, {
            canonical: true
        });
        return (0, _bytes.splitSignature)({
            recoveryParam: signature.recoveryParam,
            r: (0, _bytes.hexZeroPad)("0x" + signature.r.toString(16), 32),
            s: (0, _bytes.hexZeroPad)("0x" + signature.s.toString(16), 32)
        });
    }
    computeSharedSecret(otherKey) {
        const keyPair = getCurve().keyFromPrivate((0, _bytes.arrayify)(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic((0, _bytes.arrayify)(computePublicKey(otherKey)));
        return (0, _bytes.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
        return !!(value && value._isSigningKey);
    }
}
function recoverPublicKey(digest, signature) {
    const sig = (0, _bytes.splitSignature)(signature);
    const rs = {
        r: (0, _bytes.arrayify)(sig.r),
        s: (0, _bytes.arrayify)(sig.s)
    };
    return "0x" + getCurve().recoverPubKey((0, _bytes.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
    const bytes = (0, _bytes.arrayify)(key);
    if (bytes.length === 32) {
        const signingKey = new SigningKey(bytes);
        if (compressed) return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        return signingKey.publicKey;
    } else if (bytes.length === 33) {
        if (compressed) return (0, _bytes.hexlify)(bytes);
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    } else if (bytes.length === 65) {
        if (!compressed) return (0, _bytes.hexlify)(bytes);
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

},{"./elliptic":"iqlLr","@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"dHyc2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iqlLr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EC", ()=>EC$1);
var _bnJs = require("bn.js");
var _bnJsDefault = parcelHelpers.interopDefault(_bnJs);
var _hashJs = require("hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
var global = arguments[3];
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createCommonjsModule(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire(path, base === undefined || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function getDefaultExportFromNamespaceIfPresent(n) {
    return n && Object.prototype.hasOwnProperty.call(n, "default") ? n["default"] : n;
}
function getDefaultExportFromNamespaceIfNotNamed(n) {
    return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
}
function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var a = Object.defineProperty({}, "__esModule", {
        value: true
    });
    Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
            enumerable: true,
            get: function() {
                return n[k];
            }
        });
    });
    return a;
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
};
var utils_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
        if (Array.isArray(msg)) return msg.slice();
        if (!msg) return [];
        var res = [];
        if (typeof msg !== "string") {
            for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
            return res;
        }
        if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else for(var i = 0; i < msg.length; i++){
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 0xff;
            if (hi) res.push(hi, lo);
            else res.push(lo);
        }
        return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
        if (word.length === 1) return "0" + word;
        else return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
        var res = "";
        for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
        return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
        if (enc === "hex") return toHex(arr);
        else return arr;
    };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var utils = exports;
    utils.assert = minimalisticAssert;
    utils.toArray = utils_1.toArray;
    utils.zero2 = utils_1.zero2;
    utils.toHex = utils_1.toHex;
    utils.encode = utils_1.encode;
    // Represent num in a w-NAF form
    function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for(var i = 0; i < naf.length; i++){
            var z;
            var mod = k.andln(ws - 1);
            if (k.isOdd()) {
                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
                else z = mod;
                k.isubn(z);
            } else z = 0;
            naf[i] = z;
            k.iushrn(1);
        }
        return naf;
    }
    utils.getNAF = getNAF;
    // Represent k1, k2 in a Joint Sparse Form
    function getJSF(k1, k2) {
        var jsf = [
            [],
            []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){
            // First phase
            var m14 = k1.andln(3) + d1 & 3;
            var m24 = k2.andln(3) + d2 & 3;
            if (m14 === 3) m14 = -1;
            if (m24 === 3) m24 = -1;
            var u1;
            if ((m14 & 1) === 0) u1 = 0;
            else {
                m8 = k1.andln(7) + d1 & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
                else u1 = m14;
            }
            jsf[0].push(u1);
            var u2;
            if ((m24 & 1) === 0) u2 = 0;
            else {
                m8 = k2.andln(7) + d2 & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
                else u2 = m24;
            }
            jsf[1].push(u2);
            // Second phase
            if (2 * d1 === u1 + 1) d1 = 1 - d1;
            if (2 * d2 === u2 + 1) d2 = 1 - d2;
            k1.iushrn(1);
            k2.iushrn(1);
        }
        return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty() {
            return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
        };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
        return new (0, _bnJsDefault.default)(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
});
"use strict";
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
    this.type = type;
    this.p = new (0, _bnJsDefault.default)(conf.p, 16);
    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? (0, _bnJsDefault.default).red(conf.prime) : (0, _bnJsDefault.default).mont(this.p);
    // Useful for many curves
    this.zero = new (0, _bnJsDefault.default)(0).toRed(this.red);
    this.one = new (0, _bnJsDefault.default)(1).toRed(this.red);
    this.two = new (0, _bnJsDefault.default)(2).toRed(this.red);
    // Curve configuration, optional
    this.n = conf.n && new (0, _bnJsDefault.default)(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) this.redN = null;
    else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
    }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert$1(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    // Translate into more windowed form
    var repr = [];
    var j;
    var nafW;
    for(j = 0; j < naf.length; j += doubles.step){
        nafW = 0;
        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for(var i = I; i > 0; i--){
        for(j = 0; j < repr.length; j++){
            nafW = repr[j];
            if (nafW === i) b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
    }
    return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    // Get NAF form
    var naf = getNAF(k, w, this._bitLength);
    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for(var i = naf.length - 1; i >= 0; i--){
        // Count zeroes
        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;
        if (i >= 0) l++;
        acc = acc.dblp(l);
        if (i < 0) break;
        var z = naf[i];
        assert$1(z !== 0);
        if (p.type === "affine") {
            // J +- P
            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else // J +- J
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);
        else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
    return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    // Fill all arrays
    var max = 0;
    var i;
    var j;
    var p;
    for(i = 0; i < len; i++){
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
    }
    // Comb small window NAFs
    for(i = len - 1; i >= 1; i -= 2){
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
        }
        var comb = [
            points[a],
            /* 1 */ null,
            /* 3 */ null,
            /* 5 */ points[b]
        ];
        // Try to avoid Projective points, if possible
        if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
        } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
            -3,
            /* -1 -1 */ -1,
            /* -1 0 */ -5,
            /* -1 1 */ -7,
            /* 0 -1 */ 0,
            /* 0 0 */ 7,
            /* 0 1 */ 5,
            /* 1 -1 */ 1,
            /* 1 0 */ 3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for(j = 0; j < max; j++){
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
        }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for(i = max; i >= 0; i--){
        var k = 0;
        while(i >= 0){
            var zero = true;
            for(j = 0; j < len; j++){
                tmp[j] = naf[j][i] | 0;
                if (tmp[j] !== 0) zero = false;
            }
            if (!zero) break;
            k++;
            i--;
        }
        if (i >= 0) k++;
        acc = acc.dblp(k);
        if (i < 0) break;
        for(j = 0; j < len; j++){
            var z = tmp[j];
            p;
            if (z === 0) continue;
            else if (z > 0) p = wnd[j][z - 1 >> 1];
            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine") acc = acc.mixedAdd(p);
            else acc = acc.add(p);
        }
    }
    // Zeroify references
    for(i = 0; i < len; i++)wnd[i] = null;
    if (jacobianResult) return acc;
    else return acc.toP();
};
function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils_1$1.toArray(bytes, enc);
    var len = this.p.byteLength();
    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 0x06) assert$1(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 0x07) assert$1(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact) return [
        this.getY().isEven() ? 0x02 : 0x03
    ].concat(x);
    return [
        0x04
    ].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
    return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
        doubles: null,
        naf: null,
        beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [
        this
    ];
    var acc = this;
    for(var i = 0; i < power; i += step){
        for(var j = 0; j < step; j++)acc = acc.dbl();
        doubles.push(acc);
    }
    return {
        step: step,
        points: doubles
    };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [
        this
    ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);
    return {
        wnd: wnd,
        points: res
    };
};
BasePoint.prototype._getBeta = function _getBeta() {
    return null;
};
BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for(var i = 0; i < k; i++)r = r.dbl();
    return r;
};
var inherits_browser = createCommonjsModule(function(module) {
    if (typeof Object.create === "function") // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
    else // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
});
"use strict";
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
    base.call(this, "short", conf);
    this.a = new (0, _bnJsDefault.default)(conf.a, 16).toRed(this.red);
    this.b = new (0, _bnJsDefault.default)(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) beta = new (0, _bnJsDefault.default)(conf.beta, 16).toRed(this.red);
    else {
        var betas = this._getEndoRoots(this.p);
        // Choose the smallest beta
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
    }
    if (conf.lambda) lambda = new (0, _bnJsDefault.default)(conf.lambda, 16);
    else {
        // Choose the lambda that is matching selected beta
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) lambda = lambdas[0];
        else {
            lambda = lambdas[1];
            assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
    }
    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) basis = conf.basis.map(function(vec) {
        return {
            a: new (0, _bnJsDefault.default)(vec.a, 16),
            b: new (0, _bnJsDefault.default)(vec.b, 16)
        };
    });
    else basis = this._getEndoBasis(lambda);
    return {
        beta: beta,
        lambda: lambda,
        basis: basis
    };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : (0, _bnJsDefault.default).mont(num);
    var tinv = new (0, _bnJsDefault.default)(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new (0, _bnJsDefault.default)(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [
        l1,
        l2
    ];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new (0, _bnJsDefault.default)(1);
    var y1 = new (0, _bnJsDefault.default)(0);
    var x2 = new (0, _bnJsDefault.default)(0);
    var y2 = new (0, _bnJsDefault.default)(1);
    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while(u.cmpn(0) !== 0){
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
        } else if (a1 && ++i === 2) break;
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
    }
    // Normalize signs
    if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
    }
    if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
    }
    return [
        {
            a: a1,
            b: b1
        },
        {
            a: a2,
            b: b2
        }
    ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
        k1: k1,
        k2: k2
    };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new (0, _bnJsDefault.default)(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for(var i = 0; i < points.length; i++){
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
        }
        if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    // Clean-up references to points and coefficients
    for(var j = 0; j < i * 2; j++){
        npoints[j] = null;
        ncoeffs[j] = null;
    }
    return res;
};
function Point(curve, x, y, isRed) {
    base.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
    } else {
        this.x = new (0, _bnJsDefault.default)(x, 16);
        this.y = new (0, _bnJsDefault.default)(y, 16);
        // Force redgomery representation when loading from JSON
        if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
    }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
            beta: null,
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(endoMul)
            }
        };
    }
    return beta;
};
Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [
        this.x,
        this.y
    ];
    return [
        this.x,
        this.y,
        this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }
    ];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string") obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;
    function obj2point(obj) {
        return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [
                res
            ].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [
                res
            ].concat(pre.naf.points.map(obj2point))
        }
    };
    return res;
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
};
Point.prototype.add = function add(p) {
    // O + P = P
    if (this.inf) return p;
    // P + O = P
    if (p.inf) return this;
    // P + P = 2P
    if (this.eq(p)) return this.dbl();
    // P + (-P) = O
    if (this.neg().eq(p)) return this.curve.point(null, null);
    // P + Q = O
    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
    if (this.inf) return this;
    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
    k = new (0, _bnJsDefault.default)(k, 16);
    if (this.isInfinity()) return this;
    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo) return this.curve._endoWnafMulAdd([
        this
    ], [
        k
    ]);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
            return p.neg();
        };
        res.precomputed = {
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(negate)
            }
        };
    }
    return res;
};
Point.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
};
function JPoint(curve, x, y, z) {
    base.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new (0, _bnJsDefault.default)(0);
    } else {
        this.x = new (0, _bnJsDefault.default)(x, 16);
        this.y = new (0, _bnJsDefault.default)(y, 16);
        this.z = new (0, _bnJsDefault.default)(z, 16);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity()) return p;
    // P + O = P
    if (p.isInfinity()) return this;
    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity()) return p.toJ();
    // P + O = P
    if (p.isInfinity()) return this;
    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for(i = 0; i < pow; i++)r = r.dbl();
        return r;
    }
    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    // Reuse results
    var jyd = jy.redAdd(jy);
    for(i = 0; i < pow; i++){
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();
    else if (this.curve.threeA) return this._threeDbl();
    else return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 14A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a; a = 0
        var m = xx.redAdd(xx).redIAdd(xx);
        // T = M ^ 2 - 2*S
        var t = m.redSqr().redISub(s).redISub(s);
        // 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2*Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-dbl-2009-l
        // 2M + 5S + 13A
        // A = X1^2
        var a = this.x.redSqr();
        // B = Y1^2
        var b = this.y.redSqr();
        // C = B^2
        var c = b.redSqr();
        // D = 2 * ((X1 + B)^2 - A - C)
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        // E = 3 * A
        var e = a.redAdd(a).redIAdd(a);
        // F = E^2
        var f = e.redSqr();
        // 8 * C
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        // X3 = F - 2 * D
        nx = f.redISub(d).redISub(d);
        // Y3 = E * (D - X3) - 8 * C
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        // Z3 = 2 * Y1 * Z1
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 15A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        // T = M^2 - 2 * S
        var t = m.redSqr().redISub(s).redISub(s);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2 * Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
        // 3M + 5S
        // delta = Z1^2
        var delta = this.z.redSqr();
        // gamma = Y1^2
        var gamma = this.y.redSqr();
        // beta = X1 * gamma
        var beta = this.x.redMul(gamma);
        // alpha = 3 * (X1 - delta) * (X1 + delta)
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        // X3 = alpha^2 - 8 * beta
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        // Z3 = (Y1 + Z1)^2 - gamma - delta
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul(k, kbase) {
    k = new (0, _bnJsDefault.default)(k, kbase);
    return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine") return this.eq(p.toJ());
    if (this === p) return true;
    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var curve = exports;
    curve.base = base;
    curve.short = short_1;
    curve.mont = /*RicMoo:ethers:require(./mont)*/ null;
    curve.edwards = /*RicMoo:ethers:require(./edwards)*/ null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var curves = exports;
    var assert = utils_1$1.assert;
    function PresetCurve(options) {
        if (options.type === "short") this.curve = new curve_1.short(options);
        else if (options.type === "edwards") this.curve = new curve_1.edwards(options);
        else this.curve = new curve_1.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            get: function() {
                var curve = new PresetCurve(options);
                Object.defineProperty(curves, name, {
                    configurable: true,
                    enumerable: true,
                    value: curve
                });
                return curve;
            }
        });
    }
    defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
            "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
    });
    defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
            "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
    });
    defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
    });
    defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: (0, _hashJsDefault.default).sha384,
        gRed: false,
        g: [
            "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
            "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
    });
    defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: (0, _hashJsDefault.default).sha512,
        gRed: false,
        g: [
            "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
            "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
    });
    defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            "9"
        ]
    });
    defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
            // 4/5
            "6666666666666666666666666666666666666666666666666666666666666658"
        ]
    });
    var pre;
    try {
        pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/ null.crash();
    } catch (e) {
        pre = undefined;
    }
    defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: (0, _hashJsDefault.default).sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
            {
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }
        ],
        gRed: false,
        g: [
            "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
            pre
        ]
    });
});
"use strict";
function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
    minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for(var i = 0; i < this.V.length; i++){
        this.K[i] = 0x00;
        this.V[i] = 0x01;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000; // 2^48
};
HmacDRBG.prototype._hmac = function hmac() {
    return new (0, _hashJsDefault.default).hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([
        0x00
    ]);
    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([
        0x01
    ]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
    }
    entropy = utils_1.toArray(entropy, entropyEnc);
    add = utils_1.toArray(add, addEnc);
    minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add || []));
    this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    // Optional encoding
    if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
    }
    // Optional additional data
    if (add) {
        add = utils_1.toArray(add, addEnc || "hex");
        this._update(add);
    }
    var temp = [];
    while(temp.length < len){
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils_1.encode(res, enc);
};
"use strict";
var assert$3 = utils_1$1.assert;
function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(ec, {
        pub: pub,
        pubEnc: enc
    });
};
KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair) return priv;
    return new KeyPair(ec, {
        priv: priv,
        privEnc: enc
    });
};
KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity()) return {
        result: false,
        reason: "Invalid public key"
    };
    if (!pub.validate()) return {
        result: false,
        reason: "Public key is not a point"
    };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return {
        result: false,
        reason: "Public key * N != O"
    };
    return {
        result: true,
        reason: null
    };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === "string") {
        enc = compact;
        compact = null;
    }
    if (!this.pub) this.pub = this.ec.g.mul(this.priv);
    if (!enc) return this.pub;
    return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex") return this.priv.toString(16, 2);
    else return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new (0, _bnJsDefault.default)(key, enc || 16);
    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
        // Montgomery points only have an `x` coordinate.
        // Weierstrass/Edwards points on the other hand have both `x` and
        // `y` coordinates.
        if (this.ec.curve.type === "mont") assert$3(key.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") assert$3(key.x && key.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
};
// ECDH
KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) assert$3(pub.validate(), "public point not validated");
    return pub.mul(this.priv).getX();
};
// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
};
KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
"use strict";
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
    if (options instanceof Signature) return options;
    if (this._importDER(options, enc)) return;
    assert$4(options.r && options.s, "Signature without r or s");
    this.r = new (0, _bnJsDefault.default)(options.r, 16);
    this.s = new (0, _bnJsDefault.default)(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;
    else this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
    this.place = 0;
}
function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) return initial;
    var octetLen = initial & 0xf;
    // Indefinite length or overflow
    if (octetLen === 0 || octetLen > 4) return false;
    var val = 0;
    for(var i = 0, off = p.place; i < octetLen; i++, off++){
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
    }
    // Leading zeroes
    if (val <= 0x7f) return false;
    p.place = off;
    return val;
}
function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len)i++;
    if (i === 0) return buf;
    return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils_1$1.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) return false;
    var len = getLength(data, p);
    if (len === false) return false;
    if (len + p.place !== data.length) return false;
    if (data[p.place++] !== 0x02) return false;
    var rlen = getLength(data, p);
    if (rlen === false) return false;
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) return false;
    var slen = getLength(data, p);
    if (slen === false) return false;
    if (data.length !== slen + p.place) return false;
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
        if (r[1] & 0x80) r = r.slice(1);
        else // Leading zeroes
        return false;
    }
    if (s[0] === 0) {
        if (s[1] & 0x80) s = s.slice(1);
        else // Leading zeroes
        return false;
    }
    this.r = new (0, _bnJsDefault.default)(r);
    this.s = new (0, _bnJsDefault.default)(s);
    this.recoveryParam = null;
    return true;
};
function constructLength(arr, len) {
    if (len < 0x80) {
        arr.push(len);
        return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while(--octets)arr.push(len >>> (octets << 3) & 0xff);
    arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    // Pad values
    if (r[0] & 0x80) r = [
        0
    ].concat(r);
    // Pad values
    if (s[0] & 0x80) s = [
        0
    ].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while(!s[0] && !(s[1] & 0x80))s = s.slice(1);
    var arr = [
        0x02
    ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [
        0x30
    ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils_1$1.encode(res, enc);
};
"use strict";
var rand = /*RicMoo:ethers:require(brorand)*/ function() {
    throw new Error("unsupported");
};
var assert$5 = utils_1$1.assert;
function EC(options) {
    if (!(this instanceof EC)) return new EC(options);
    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === "string") {
        assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
        options = curves_1[options];
    }
    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof curves_1.PresetCurve) options = {
        curve: options
    };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
    return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {};
    // Instantiate Hmac_DRBG
    var drbg = new hmacDrbg({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new (0, _bnJsDefault.default)(2));
    for(;;){
        var priv = new (0, _bnJsDefault.default)(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0) continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
    }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
    else return msg;
};
EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
        options = enc;
        enc = null;
    }
    if (!options) options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new (0, _bnJsDefault.default)(msg, 16));
    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray("be", bytes);
    // Instantiate Hmac_DRBG
    var drbg = new hmacDrbg({
        hash: this.hash,
        entropy: bkey,
        nonce: nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
    });
    // Number of bytes to generate
    var ns1 = this.n.sub(new (0, _bnJsDefault.default)(1));
    for(var iter = 0;; iter++){
        var k = options.k ? options.k(iter) : new (0, _bnJsDefault.default)(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity()) continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0) continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0) continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        // Use complement of `s`, if it is > `n / 2`
        if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
        }
        return new signature({
            r: r,
            s: s,
            recoveryParam: recoveryParam
        });
    }
};
EC.prototype.verify = function verify(msg, signature$1, key, enc) {
    msg = this._truncateToN(new (0, _bnJsDefault.default)(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature$1 = new signature(signature$1, "hex");
    // Perform primitive values validation
    var r = signature$1.r;
    var s = signature$1.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.getX().umod(this.n).cmp(r) === 0;
    }
    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
    assert$5((3 & j) === j, "The recovery param is more than two bits");
    signature$1 = new signature(signature$1, enc);
    var n = this.n;
    var e = new (0, _bnJsDefault.default)(msg);
    var r = signature$1.r;
    var s = signature$1.s;
    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
    // 1.1. Let x = r + jn.
    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature$1.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
    signature$1 = new signature(signature$1, enc);
    if (signature$1.recoveryParam !== null) return signature$1.recoveryParam;
    for(var i = 0; i < 4; i++){
        var Qprime;
        try {
            Qprime = this.recoverPubKey(e, signature$1, i);
        } catch (e) {
            continue;
        }
        if (Qprime.eq(Q)) return i;
    }
    throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = "6.5.4";
    elliptic.utils = utils_1$1;
    elliptic.rand = /*RicMoo:ethers:require(brorand)*/ function() {
        throw new Error("unsupported");
    };
    elliptic.curve = curve_1;
    elliptic.curves = curves_1;
    // Protocols
    elliptic.ec = ec;
    elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/ null;
});
var EC$1 = elliptic_1.ec;

},{"bn.js":"VopIn","hash.js":"gOEGU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gOEGU":[function(require,module,exports) {
var hash = exports;
hash.utils = require("38593959f18bd562");
hash.common = require("31a457752237e8ad");
hash.sha = require("3e37816d2a2fd68d");
hash.ripemd = require("ce5a13b5bd10f171");
hash.hmac = require("c32fbac97a361580");
// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"38593959f18bd562":"kfzn2","31a457752237e8ad":"ecAfF","3e37816d2a2fd68d":"8nbee","ce5a13b5bd10f171":"9kyRQ","c32fbac97a361580":"5KrrE"}],"kfzn2":[function(require,module,exports) {
"use strict";
var assert = require("6002b0feade022a4");
var inherits = require("d4826c9d0ff1b1f");
exports.inherits = inherits;
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) return false;
    if (i < 0 || i + 1 >= msg.length) return false;
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === "string") {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for(var i = 0; i < msg.length; i++){
                var c = msg.charCodeAt(i);
                if (c < 128) res[p++] = c;
                else if (c < 2048) {
                    res[p++] = c >> 6 | 192;
                    res[p++] = c & 63 | 128;
                } else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = c >> 18 | 240;
                    res[p++] = c >> 12 & 63 | 128;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                } else {
                    res[p++] = c >> 12 | 224;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                }
            }
        } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for(i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    } else for(i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
    return res;
}
exports.toArray = toArray;
function toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
exports.toHex = toHex;
function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
}
exports.htonl = htonl;
function toHex32(msg, endian) {
    var res = "";
    for(var i = 0; i < msg.length; i++){
        var w = msg[i];
        if (endian === "little") w = htonl(w);
        res += zero8(w.toString(16));
    }
    return res;
}
exports.toHex32 = toHex32;
function zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
exports.zero2 = zero2;
function zero8(word) {
    if (word.length === 7) return "0" + word;
    else if (word.length === 6) return "00" + word;
    else if (word.length === 5) return "000" + word;
    else if (word.length === 4) return "0000" + word;
    else if (word.length === 3) return "00000" + word;
    else if (word.length === 2) return "000000" + word;
    else if (word.length === 1) return "0000000" + word;
    else return word;
}
exports.zero8 = zero8;
function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for(var i = 0, k = start; i < res.length; i++, k += 4){
        var w;
        if (endian === "big") w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
exports.join32 = join32;
function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for(var i = 0, k = 0; i < msg.length; i++, k += 4){
        var m = msg[i];
        if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 0xff;
            res[k + 2] = m >>> 8 & 0xff;
            res[k + 3] = m & 0xff;
        } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 0xff;
            res[k + 1] = m >>> 8 & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
exports.split32 = split32;
function rotr32(w, b) {
    return w >>> b | w << 32 - b;
}
exports.rotr32 = rotr32;
function rotl32(w, b) {
    return w << b | w >>> 32 - b;
}
exports.rotl32 = rotl32;
function sum32(a, b) {
    return a + b >>> 0;
}
exports.sum32 = sum32;
function sum32_3(a, b, c) {
    return a + b + c >>> 0;
}
exports.sum32_3 = sum32_3;
function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
}
exports.sum32_4 = sum32_4;
function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
}
exports.sum32_5 = sum32_5;
function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
exports.sum64 = sum64;
function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
exports.sum64_hi = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
exports.sum64_lo = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;
function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;
function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;
function shr64_hi(ah, al, num) {
    return ah >>> num;
}
exports.shr64_hi = shr64_hi;
function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"6002b0feade022a4":"8OvWh","d4826c9d0ff1b1f":"bRL3M"}],"8OvWh":[function(require,module,exports) {
module.exports = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
};

},{}],"bRL3M":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"ecAfF":[function(require,module,exports) {
"use strict";
var utils = require("e9291abdfb47ee4f");
var assert = require("ea8841b701712638");
function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending) this.pending = msg;
    else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
    }
    return this;
};
BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for(var i = 1; i < k; i++)res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === "big") {
        for(var t = 8; t < this.padLength; t++)res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
    } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for(t = 8; t < this.padLength; t++)res[i++] = 0;
    }
    return res;
};

},{"e9291abdfb47ee4f":"kfzn2","ea8841b701712638":"8OvWh"}],"8nbee":[function(require,module,exports) {
"use strict";
exports.sha1 = require("3835379564860fd7");
exports.sha224 = require("bb9f72f042233648");
exports.sha256 = require("20a3b0fa42e37dfe");
exports.sha384 = require("ad4827efa7d953c2");
exports.sha512 = require("301292595a944c1d");

},{"3835379564860fd7":"fnjyb","bb9f72f042233648":"9x7tY","20a3b0fa42e37dfe":"9bCbT","ad4827efa7d953c2":"lJMiS","301292595a944c1d":"8y482"}],"fnjyb":[function(require,module,exports) {
"use strict";
var utils = require("b75f3c1442bf9100");
var common = require("a29e68029e4c48f8");
var shaCommon = require("1be62f90a237cba5");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [
    0x5A827999,
    0x6ED9EBA1,
    0x8F1BBCDC,
    0xCA62C1D6
];
function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.W = new Array(80);
}
utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for(i = 0; i < W.length; i++){
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"b75f3c1442bf9100":"kfzn2","a29e68029e4c48f8":"ecAfF","1be62f90a237cba5":"gzrNi"}],"gzrNi":[function(require,module,exports) {
"use strict";
var utils = require("f0fb61f828bacd0f");
var rotr32 = utils.rotr32;
function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
}
exports.ft_1 = ft_1;
function ch32(x, y, z) {
    return x & y ^ ~x & z;
}
exports.ch32 = ch32;
function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
}
exports.maj32 = maj32;
function p32(x, y, z) {
    return x ^ y ^ z;
}
exports.p32 = p32;
function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;
function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;
function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
exports.g0_256 = g0_256;
function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
exports.g1_256 = g1_256;

},{"f0fb61f828bacd0f":"kfzn2"}],"9x7tY":[function(require,module,exports) {
"use strict";
var utils = require("fe5acd040463c159");
var SHA256 = require("fa3503eda3738d05");
function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [
        0xc1059ed8,
        0x367cd507,
        0x3070dd17,
        0xf70e5939,
        0xffc00b31,
        0x68581511,
        0x64f98fa7,
        0xbefa4fa4
    ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 7), "big");
    else return utils.split32(this.h.slice(0, 7), "big");
};

},{"fe5acd040463c159":"kfzn2","fa3503eda3738d05":"9bCbT"}],"9bCbT":[function(require,module,exports) {
"use strict";
var utils = require("32ad3e510bd41f2a");
var common = require("469ad88ad505772a");
var shaCommon = require("fffa7d1ddf1f0b43");
var assert = require("126369f57b5225ed");
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function SHA256() {
    if (!(this instanceof SHA256)) return new SHA256();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for(i = 0; i < W.length; i++){
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"32ad3e510bd41f2a":"kfzn2","469ad88ad505772a":"ecAfF","fffa7d1ddf1f0b43":"gzrNi","126369f57b5225ed":"8OvWh"}],"lJMiS":[function(require,module,exports) {
"use strict";
var utils = require("a696ee34c45713da");
var SHA512 = require("fff95253fdaa49ea");
function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512.call(this);
    this.h = [
        0xcbbb9d5d,
        0xc1059ed8,
        0x629a292a,
        0x367cd507,
        0x9159015a,
        0x3070dd17,
        0x152fecd8,
        0xf70e5939,
        0x67332667,
        0xffc00b31,
        0x8eb44a87,
        0x68581511,
        0xdb0c2e0d,
        0x64f98fa7,
        0x47b5481d,
        0xbefa4fa4
    ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 12), "big");
    else return utils.split32(this.h.slice(0, 12), "big");
};

},{"a696ee34c45713da":"kfzn2","fff95253fdaa49ea":"8y482"}],"8y482":[function(require,module,exports) {
"use strict";
var utils = require("7753b1fa702fbb54");
var common = require("81b6970d75627ce1");
var assert = require("f660976cede694e2");
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function SHA512() {
    if (!(this instanceof SHA512)) return new SHA512();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xf3bcc908,
        0xbb67ae85,
        0x84caa73b,
        0x3c6ef372,
        0xfe94f82b,
        0xa54ff53a,
        0x5f1d36f1,
        0x510e527f,
        0xade682d1,
        0x9b05688c,
        0x2b3e6c1f,
        0x1f83d9ab,
        0xfb41bd6b,
        0x5be0cd19,
        0x137e2179
    ];
    this.k = sha512_K;
    this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;
SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    // 32 x 32bit words
    for(var i = 0; i < 32; i++)W[i] = msg[start + i];
    for(; i < W.length; i += 2){
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
};
SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for(var i = 0; i < W.length; i += 2){
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
};
SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34
    var c2_hi = rotr64_hi(xl, xh, 7); // 39
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34
    var c2_lo = rotr64_lo(xl, xh, 7); // 39
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}

},{"7753b1fa702fbb54":"kfzn2","81b6970d75627ce1":"ecAfF","f660976cede694e2":"8OvWh"}],"9kyRQ":[function(require,module,exports) {
"use strict";
var utils = require("36495272d446418f");
var common = require("ad8cf0490e28e8d7");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.endian = "little";
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for(var j = 0; j < 80; j++){
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "little");
    else return utils.split32(this.h, "little");
};
function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    else if (j <= 31) return x & y | ~x & z;
    else if (j <= 47) return (x | ~y) ^ z;
    else if (j <= 63) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
function K(j) {
    if (j <= 15) return 0x00000000;
    else if (j <= 31) return 0x5a827999;
    else if (j <= 47) return 0x6ed9eba1;
    else if (j <= 63) return 0x8f1bbcdc;
    else return 0xa953fd4e;
}
function Kh(j) {
    if (j <= 15) return 0x50a28be6;
    else if (j <= 31) return 0x5c4dd124;
    else if (j <= 47) return 0x6d703ef3;
    else if (j <= 63) return 0x7a6d76e9;
    else return 0x00000000;
}
var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];

},{"36495272d446418f":"kfzn2","ad8cf0490e28e8d7":"ecAfF"}],"5KrrE":[function(require,module,exports) {
"use strict";
var utils = require("596c08b6835a6e2d");
var assert = require("be527907d4f06808");
function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
}
module.exports = Hmac;
Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    // Add padding to key
    for(var i = key.length; i < this.blockSize; i++)key.push(0);
    for(i = 0; i < key.length; i++)key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    // 0x36 ^ 0x5c = 0x6a
    for(i = 0; i < key.length; i++)key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
};
Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
};

},{"596c08b6835a6e2d":"kfzn2","be527907d4f06808":"8OvWh"}],"dHyc2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "signing-key/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7piXV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "transactions/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6ewae":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "contracts/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2DfhD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Wallet", ()=>Wallet);
parcelHelpers.export(exports, "verifyMessage", ()=>verifyMessage);
parcelHelpers.export(exports, "verifyTypedData", ()=>verifyTypedData);
var _address = require("@ethersproject/address");
var _abstractProvider = require("@ethersproject/abstract-provider");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _bytes = require("@ethersproject/bytes");
var _hash = require("@ethersproject/hash");
var _hdnode = require("@ethersproject/hdnode");
var _keccak256 = require("@ethersproject/keccak256");
var _properties = require("@ethersproject/properties");
var _random = require("@ethersproject/random");
var _signingKey = require("@ethersproject/signing-key");
var _jsonWallets = require("@ethersproject/json-wallets");
var _transactions = require("@ethersproject/transactions");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
function isAccount(value) {
    return value != null && (0, _bytes.isHexString)(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
    const mnemonic = value.mnemonic;
    return mnemonic && mnemonic.phrase;
}
class Wallet extends (0, _abstractSigner.Signer) {
    constructor(privateKey, provider){
        super();
        if (isAccount(privateKey)) {
            const signingKey = new (0, _signingKey.SigningKey)(privateKey.privateKey);
            (0, _properties.defineReadOnly)(this, "_signingKey", ()=>signingKey);
            (0, _properties.defineReadOnly)(this, "address", (0, _transactions.computeAddress)(this.publicKey));
            if (this.address !== (0, _address.getAddress)(privateKey.address)) logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
            if (hasMnemonic(privateKey)) {
                const srcMnemonic = privateKey.mnemonic;
                (0, _properties.defineReadOnly)(this, "_mnemonic", ()=>({
                        phrase: srcMnemonic.phrase,
                        path: srcMnemonic.path || (0, _hdnode.defaultPath),
                        locale: srcMnemonic.locale || "en"
                    }));
                const mnemonic = this.mnemonic;
                const node = (0, _hdnode.HDNode).fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
                if ((0, _transactions.computeAddress)(node.privateKey) !== this.address) logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            } else (0, _properties.defineReadOnly)(this, "_mnemonic", ()=>null);
        } else {
            if ((0, _signingKey.SigningKey).isSigningKey(privateKey)) {
                /* istanbul ignore if */ if (privateKey.curve !== "secp256k1") logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
                (0, _properties.defineReadOnly)(this, "_signingKey", ()=>privateKey);
            } else {
                // A lot of common tools do not prefix private keys with a 0x (see: #1166)
                if (typeof privateKey === "string") {
                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) privateKey = "0x" + privateKey;
                }
                const signingKey = new (0, _signingKey.SigningKey)(privateKey);
                (0, _properties.defineReadOnly)(this, "_signingKey", ()=>signingKey);
            }
            (0, _properties.defineReadOnly)(this, "_mnemonic", ()=>null);
            (0, _properties.defineReadOnly)(this, "address", (0, _transactions.computeAddress)(this.publicKey));
        }
        /* istanbul ignore if */ if (provider && !(0, _abstractProvider.Provider).isProvider(provider)) logger.throwArgumentError("invalid provider", "provider", provider);
        (0, _properties.defineReadOnly)(this, "provider", provider || null);
    }
    get mnemonic() {
        return this._mnemonic();
    }
    get privateKey() {
        return this._signingKey().privateKey;
    }
    get publicKey() {
        return this._signingKey().publicKey;
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    connect(provider) {
        return new Wallet(this, provider);
    }
    signTransaction(transaction) {
        return (0, _properties.resolveProperties)(transaction).then((tx)=>{
            if (tx.from != null) {
                if ((0, _address.getAddress)(tx.from) !== this.address) logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
                delete tx.from;
            }
            const signature = this._signingKey().signDigest((0, _keccak256.keccak256)((0, _transactions.serialize)(tx)));
            return (0, _transactions.serialize)(tx, signature);
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function*() {
            return (0, _bytes.joinSignature)(this._signingKey().signDigest((0, _hash.hashMessage)(message)));
        });
    }
    _signTypedData(domain, types, value) {
        return __awaiter(this, void 0, void 0, function*() {
            // Populate any ENS names
            const populated = yield (0, _hash._TypedDataEncoder).resolveNames(domain, types, value, (name)=>{
                if (this.provider == null) logger.throwError("cannot resolve ENS names without a provider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                    operation: "resolveName",
                    value: name
                });
                return this.provider.resolveName(name);
            });
            return (0, _bytes.joinSignature)(this._signingKey().signDigest((0, _hash._TypedDataEncoder).hash(populated.domain, types, populated.value)));
        });
    }
    encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
            progressCallback = options;
            options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") throw new Error("invalid callback");
        if (!options) options = {};
        return (0, _jsonWallets.encryptKeystore)(this, password, options, progressCallback);
    }
    /**
     *  Static methods to create Wallet instances.
     */ static createRandom(options) {
        let entropy = (0, _random.randomBytes)(16);
        if (!options) options = {};
        if (options.extraEntropy) entropy = (0, _bytes.arrayify)((0, _bytes.hexDataSlice)((0, _keccak256.keccak256)((0, _bytes.concat)([
            entropy,
            options.extraEntropy
        ])), 0, 16));
        const mnemonic = (0, _hdnode.entropyToMnemonic)(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
        return (0, _jsonWallets.decryptJsonWallet)(json, password, progressCallback).then((account)=>{
            return new Wallet(account);
        });
    }
    static fromEncryptedJsonSync(json, password) {
        return new Wallet((0, _jsonWallets.decryptJsonWalletSync)(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) path = (0, _hdnode.defaultPath);
        return new Wallet((0, _hdnode.HDNode).fromMnemonic(mnemonic, null, wordlist).derivePath(path));
    }
}
function verifyMessage(message, signature) {
    return (0, _transactions.recoverAddress)((0, _hash.hashMessage)(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
    return (0, _transactions.recoverAddress)((0, _hash._TypedDataEncoder).hash(domain, types, value), signature);
}

},{"@ethersproject/address":"ggdAz","@ethersproject/abstract-provider":"g1jr1","@ethersproject/abstract-signer":"g9Ey5","@ethersproject/bytes":"htrqZ","@ethersproject/hash":"7JYPm","@ethersproject/hdnode":"8PpMD","@ethersproject/keccak256":"hXDEv","@ethersproject/properties":"h3GJb","@ethersproject/random":"7myQM","@ethersproject/signing-key":"krGB2","@ethersproject/json-wallets":"1qqTy","@ethersproject/transactions":"d1ust","@ethersproject/logger":"hLvB2","./_version":"ej99N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8PpMD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultPath", ()=>defaultPath);
parcelHelpers.export(exports, "HDNode", ()=>HDNode);
parcelHelpers.export(exports, "mnemonicToSeed", ()=>mnemonicToSeed);
parcelHelpers.export(exports, "mnemonicToEntropy", ()=>mnemonicToEntropy);
parcelHelpers.export(exports, "entropyToMnemonic", ()=>entropyToMnemonic);
parcelHelpers.export(exports, "isValidMnemonic", ()=>isValidMnemonic);
parcelHelpers.export(exports, "getAccountPath", ()=>getAccountPath);
var _basex = require("@ethersproject/basex");
var _bytes = require("@ethersproject/bytes");
var _bignumber = require("@ethersproject/bignumber");
var _strings = require("@ethersproject/strings");
var _pbkdf2 = require("@ethersproject/pbkdf2");
var _properties = require("@ethersproject/properties");
var _signingKey = require("@ethersproject/signing-key");
var _sha2 = require("@ethersproject/sha2");
var _transactions = require("@ethersproject/transactions");
var _wordlists = require("@ethersproject/wordlists");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const N = (0, _bignumber.BigNumber).from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
// "Bitcoin seed"
const MasterSecret = (0, _strings.toUtf8Bytes)("Bitcoin seed");
const HardenedBit = 0x80000000;
// Returns a byte with the MSB bits set
function getUpperMask(bits) {
    return (1 << bits) - 1 << 8 - bits;
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
    return (1 << bits) - 1;
}
function bytes32(value) {
    return (0, _bytes.hexZeroPad)((0, _bytes.hexlify)(value), 32);
}
function base58check(data) {
    return (0, _basex.Base58).encode((0, _bytes.concat)([
        data,
        (0, _bytes.hexDataSlice)((0, _sha2.sha256)((0, _sha2.sha256)(data)), 0, 4)
    ]));
}
function getWordlist(wordlist) {
    if (wordlist == null) return (0, _wordlists.wordlists)["en"];
    if (typeof wordlist === "string") {
        const words = (0, _wordlists.wordlists)[wordlist];
        if (words == null) logger.throwArgumentError("unknown locale", "wordlist", wordlist);
        return words;
    }
    return wordlist;
}
const _constructorGuard = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
    /**
     *  This constructor should not be called directly.
     *
     *  Please use:
     *   - fromMnemonic
     *   - fromSeed
     */ constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath){
        /* istanbul ignore if */ if (constructorGuard !== _constructorGuard) throw new Error("HDNode constructor cannot be called directly");
        if (privateKey) {
            const signingKey = new (0, _signingKey.SigningKey)(privateKey);
            (0, _properties.defineReadOnly)(this, "privateKey", signingKey.privateKey);
            (0, _properties.defineReadOnly)(this, "publicKey", signingKey.compressedPublicKey);
        } else {
            (0, _properties.defineReadOnly)(this, "privateKey", null);
            (0, _properties.defineReadOnly)(this, "publicKey", (0, _bytes.hexlify)(publicKey));
        }
        (0, _properties.defineReadOnly)(this, "parentFingerprint", parentFingerprint);
        (0, _properties.defineReadOnly)(this, "fingerprint", (0, _bytes.hexDataSlice)((0, _sha2.ripemd160)((0, _sha2.sha256)(this.publicKey)), 0, 4));
        (0, _properties.defineReadOnly)(this, "address", (0, _transactions.computeAddress)(this.publicKey));
        (0, _properties.defineReadOnly)(this, "chainCode", chainCode);
        (0, _properties.defineReadOnly)(this, "index", index);
        (0, _properties.defineReadOnly)(this, "depth", depth);
        if (mnemonicOrPath == null) {
            // From a source that does not preserve the path (e.g. extended keys)
            (0, _properties.defineReadOnly)(this, "mnemonic", null);
            (0, _properties.defineReadOnly)(this, "path", null);
        } else if (typeof mnemonicOrPath === "string") {
            // From a source that does not preserve the mnemonic (e.g. neutered)
            (0, _properties.defineReadOnly)(this, "mnemonic", null);
            (0, _properties.defineReadOnly)(this, "path", mnemonicOrPath);
        } else {
            // From a fully qualified source
            (0, _properties.defineReadOnly)(this, "mnemonic", mnemonicOrPath);
            (0, _properties.defineReadOnly)(this, "path", mnemonicOrPath.path);
        }
    }
    get extendedKey() {
        // We only support the mainnet values for now, but if anyone needs
        // testnet values, let me know. I believe current sentiment is that
        // we should always use mainnet, and use BIP-44 to derive the network
        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
        //   - Testnet: public=0x043587CF, private=0x04358394
        if (this.depth >= 256) throw new Error("Depth too large!");
        return base58check((0, _bytes.concat)([
            this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
            (0, _bytes.hexlify)(this.depth),
            this.parentFingerprint,
            (0, _bytes.hexZeroPad)((0, _bytes.hexlify)(this.index), 4),
            this.chainCode,
            this.privateKey != null ? (0, _bytes.concat)([
                "0x00",
                this.privateKey
            ]) : this.publicKey
        ]));
    }
    neuter() {
        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    }
    _derive(index) {
        if (index > 0xffffffff) throw new Error("invalid index - " + String(index));
        // Base path
        let path = this.path;
        if (path) path += "/" + (index & ~HardenedBit);
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
            if (!this.privateKey) throw new Error("cannot derive child of neutered node");
            // Data = 0x00 || ser_256(k_par)
            data.set((0, _bytes.arrayify)(this.privateKey), 1);
            // Hardened path
            if (path) path += "'";
        } else // Data = ser_p(point(k_par))
        data.set((0, _bytes.arrayify)(this.publicKey));
        // Data += ser_32(i)
        for(let i = 24; i >= 0; i -= 8)data[33 + (i >> 3)] = index >> 24 - i & 0xff;
        const I = (0, _bytes.arrayify)((0, _sha2.computeHmac)((0, _sha2.SupportedAlgorithm).sha512, this.chainCode, data));
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        // The private key
        let ki = null;
        // The public key
        let Ki = null;
        if (this.privateKey) ki = bytes32((0, _bignumber.BigNumber).from(IL).add(this.privateKey).mod(N));
        else {
            const ek = new (0, _signingKey.SigningKey)((0, _bytes.hexlify)(IL));
            Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) mnemonicOrPath = Object.freeze({
            phrase: srcMnemonic.phrase,
            path: path,
            locale: srcMnemonic.locale || "en"
        });
        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
    }
    derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || components[0] === "m" && this.depth !== 0) throw new Error("invalid path - " + path);
        if (components[0] === "m") components.shift();
        let result = this;
        for(let i = 0; i < components.length; i++){
            const component = components[i];
            if (component.match(/^[0-9]+'$/)) {
                const index = parseInt(component.substring(0, component.length - 1));
                if (index >= HardenedBit) throw new Error("invalid path index - " + component);
                result = result._derive(HardenedBit + index);
            } else if (component.match(/^[0-9]+$/)) {
                const index = parseInt(component);
                if (index >= HardenedBit) throw new Error("invalid path index - " + component);
                result = result._derive(index);
            } else throw new Error("invalid path component - " + component);
        }
        return result;
    }
    static _fromSeed(seed, mnemonic) {
        const seedArray = (0, _bytes.arrayify)(seed);
        if (seedArray.length < 16 || seedArray.length > 64) throw new Error("invalid seed");
        const I = (0, _bytes.arrayify)((0, _sha2.computeHmac)((0, _sha2.SupportedAlgorithm).sha512, MasterSecret, seedArray));
        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
    }
    static fromMnemonic(mnemonic, password, wordlist) {
        // If a locale name was passed in, find the associated wordlist
        wordlist = getWordlist(wordlist);
        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
            phrase: mnemonic,
            path: "m",
            locale: wordlist.locale
        });
    }
    static fromSeed(seed) {
        return HDNode._fromSeed(seed, null);
    }
    static fromExtendedKey(extendedKey) {
        const bytes = (0, _basex.Base58).decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        const depth = bytes[4];
        const parentFingerprint = (0, _bytes.hexlify)(bytes.slice(5, 9));
        const index = parseInt((0, _bytes.hexlify)(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = (0, _bytes.hexlify)(bytes.slice(13, 45));
        const key = bytes.slice(45, 78);
        switch((0, _bytes.hexlify)(bytes.slice(0, 4))){
            // Public Key
            case "0x0488b21e":
            case "0x043587cf":
                return new HDNode(_constructorGuard, null, (0, _bytes.hexlify)(key), parentFingerprint, chainCode, index, depth, null);
            // Private Key
            case "0x0488ade4":
            case "0x04358394 ":
                if (key[0] !== 0) break;
                return new HDNode(_constructorGuard, (0, _bytes.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
}
function mnemonicToSeed(mnemonic, password) {
    if (!password) password = "";
    const salt = (0, _strings.toUtf8Bytes)("mnemonic" + password, (0, _strings.UnicodeNormalizationForm).NFKD);
    return (0, _pbkdf2.pbkdf2)((0, _strings.toUtf8Bytes)(mnemonic, (0, _strings.UnicodeNormalizationForm).NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = getWordlist(wordlist);
    logger.checkNormalize();
    const words = wordlist.split(mnemonic);
    if (words.length % 3 !== 0) throw new Error("invalid mnemonic");
    const entropy = (0, _bytes.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));
    let offset = 0;
    for(let i = 0; i < words.length; i++){
        let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
        if (index === -1) throw new Error("invalid mnemonic");
        for(let bit = 0; bit < 11; bit++){
            if (index & 1 << 10 - bit) entropy[offset >> 3] |= 1 << 7 - offset % 8;
            offset++;
        }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = (0, _bytes.arrayify)((0, _sha2.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) throw new Error("invalid checksum");
    return (0, _bytes.hexlify)(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
    wordlist = getWordlist(wordlist);
    entropy = (0, _bytes.arrayify)(entropy);
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) throw new Error("invalid entropy");
    const indices = [
        0
    ];
    let remainingBits = 11;
    for(let i = 0; i < entropy.length; i++)// Consume the whole byte (with still more to go)
    if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
    // This byte will complete an 11-bit index
    } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        // Start the next word
        indices.push(entropy[i] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
    }
    // Compute the checksum bits
    const checksumBits = entropy.length / 4;
    const checksum = (0, _bytes.arrayify)((0, _sha2.sha256)(entropy))[0] & getUpperMask(checksumBits);
    // Shift the checksum into the word indices
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return wordlist.join(indices.map((index)=>wordlist.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
        return true;
    } catch (error) {}
    return false;
}
function getAccountPath(index) {
    if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) logger.throwArgumentError("invalid account index", "index", index);
    return `m/44'/60'/${index}'/0/0`;
}

},{"@ethersproject/basex":"dm2o4","@ethersproject/bytes":"htrqZ","@ethersproject/bignumber":"ckYYW","@ethersproject/strings":"5TGFZ","@ethersproject/pbkdf2":"ityKl","@ethersproject/properties":"h3GJb","@ethersproject/signing-key":"krGB2","@ethersproject/sha2":"k4R8k","@ethersproject/transactions":"d1ust","@ethersproject/wordlists":"czmoZ","@ethersproject/logger":"hLvB2","./_version":"7Gslh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dm2o4":[function(require,module,exports) {
/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseX", ()=>BaseX);
parcelHelpers.export(exports, "Base32", ()=>Base32) //console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
 //console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))
;
parcelHelpers.export(exports, "Base58", ()=>Base58);
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
class BaseX {
    constructor(alphabet){
        (0, _properties.defineReadOnly)(this, "alphabet", alphabet);
        (0, _properties.defineReadOnly)(this, "base", alphabet.length);
        (0, _properties.defineReadOnly)(this, "_alphabetMap", {});
        (0, _properties.defineReadOnly)(this, "_leader", alphabet.charAt(0));
        // pre-compute lookup table
        for(let i = 0; i < alphabet.length; i++)this._alphabetMap[alphabet.charAt(i)] = i;
    }
    encode(value) {
        let source = (0, _bytes.arrayify)(value);
        if (source.length === 0) return "";
        let digits = [
            0
        ];
        for(let i = 0; i < source.length; ++i){
            let carry = source[i];
            for(let j = 0; j < digits.length; ++j){
                carry += digits[j] << 8;
                digits[j] = carry % this.base;
                carry = carry / this.base | 0;
            }
            while(carry > 0){
                digits.push(carry % this.base);
                carry = carry / this.base | 0;
            }
        }
        let string = "";
        // deal with leading zeros
        for(let k = 0; source[k] === 0 && k < source.length - 1; ++k)string += this._leader;
        // convert digits to a string
        for(let q = digits.length - 1; q >= 0; --q)string += this.alphabet[digits[q]];
        return string;
    }
    decode(value) {
        if (typeof value !== "string") throw new TypeError("Expected String");
        let bytes = [];
        if (value.length === 0) return new Uint8Array(bytes);
        bytes.push(0);
        for(let i = 0; i < value.length; i++){
            let byte = this._alphabetMap[value[i]];
            if (byte === undefined) throw new Error("Non-base" + this.base + " character");
            let carry = byte;
            for(let j = 0; j < bytes.length; ++j){
                carry += bytes[j] * this.base;
                bytes[j] = carry & 0xff;
                carry >>= 8;
            }
            while(carry > 0){
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        // deal with leading zeros
        for(let k = 0; value[k] === this._leader && k < value.length - 1; ++k)bytes.push(0);
        return (0, _bytes.arrayify)(new Uint8Array(bytes.reverse()));
    }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

},{"@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ityKl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pbkdf2", ()=>(0, _pbkdf2.pbkdf2));
var _pbkdf2 = require("./pbkdf2");

},{"./pbkdf2":"143Uh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"143Uh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pbkdf2", ()=>pbkdf2);
var _bytes = require("@ethersproject/bytes");
var _sha2 = require("@ethersproject/sha2");
"use strict";
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
    password = (0, _bytes.arrayify)(password);
    salt = (0, _bytes.arrayify)(salt);
    let hLen;
    let l = 1;
    const DK = new Uint8Array(keylen);
    const block1 = new Uint8Array(salt.length + 4);
    block1.set(salt);
    //salt.copy(block1, 0, 0, salt.length)
    let r;
    let T;
    for(let i = 1; i <= l; i++){
        //block1.writeUInt32BE(i, salt.length)
        block1[salt.length] = i >> 24 & 0xff;
        block1[salt.length + 1] = i >> 16 & 0xff;
        block1[salt.length + 2] = i >> 8 & 0xff;
        block1[salt.length + 3] = i & 0xff;
        //let U = createHmac(password).update(block1).digest();
        let U = (0, _bytes.arrayify)((0, _sha2.computeHmac)(hashAlgorithm, password, block1));
        if (!hLen) {
            hLen = U.length;
            T = new Uint8Array(hLen);
            l = Math.ceil(keylen / hLen);
            r = keylen - (l - 1) * hLen;
        }
        //U.copy(T, 0, 0, hLen)
        T.set(U);
        for(let j = 1; j < iterations; j++){
            //U = createHmac(password).update(U).digest();
            U = (0, _bytes.arrayify)((0, _sha2.computeHmac)(hashAlgorithm, password, U));
            for(let k = 0; k < hLen; k++)T[k] ^= U[k];
        }
        const destPos = (i - 1) * hLen;
        const len = i === l ? r : hLen;
        //T.copy(DK, destPos, 0, len)
        DK.set((0, _bytes.arrayify)(T).slice(0, len), destPos);
    }
    return (0, _bytes.hexlify)(DK);
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/sha2":"k4R8k","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k4R8k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "computeHmac", ()=>(0, _sha2.computeHmac));
parcelHelpers.export(exports, "ripemd160", ()=>(0, _sha2.ripemd160));
parcelHelpers.export(exports, "sha256", ()=>(0, _sha2.sha256));
parcelHelpers.export(exports, "sha512", ()=>(0, _sha2.sha512));
parcelHelpers.export(exports, "SupportedAlgorithm", ()=>(0, _types.SupportedAlgorithm));
var _sha2 = require("./sha2");
var _types = require("./types");

},{"./sha2":"gqduC","./types":"gUbat","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gqduC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ripemd160", ()=>ripemd160);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha512", ()=>sha512);
parcelHelpers.export(exports, "computeHmac", ()=>computeHmac);
var _hashJs = require("hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
//const _ripemd160 = _hash.ripemd160;
var _bytes = require("@ethersproject/bytes");
var _types = require("./types");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function ripemd160(data) {
    return "0x" + (0, _hashJsDefault.default).ripemd160().update((0, _bytes.arrayify)(data)).digest("hex");
}
function sha256(data) {
    return "0x" + (0, _hashJsDefault.default).sha256().update((0, _bytes.arrayify)(data)).digest("hex");
}
function sha512(data) {
    return "0x" + (0, _hashJsDefault.default).sha512().update((0, _bytes.arrayify)(data)).digest("hex");
}
function computeHmac(algorithm, key, data) {
    if (!(0, _types.SupportedAlgorithm)[algorithm]) logger.throwError("unsupported algorithm " + algorithm, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        operation: "hmac",
        algorithm: algorithm
    });
    return "0x" + (0, _hashJsDefault.default).hmac((0, _hashJsDefault.default)[algorithm], (0, _bytes.arrayify)(key)).update((0, _bytes.arrayify)(data)).digest("hex");
}

},{"hash.js":"gOEGU","@ethersproject/bytes":"htrqZ","./types":"gUbat","@ethersproject/logger":"hLvB2","./_version":"c9Q6D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gUbat":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SupportedAlgorithm", ()=>SupportedAlgorithm);
var SupportedAlgorithm;
(function(SupportedAlgorithm) {
    SupportedAlgorithm["sha256"] = "sha256";
    SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c9Q6D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "sha2/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czmoZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logger", ()=>(0, _wordlist.logger));
parcelHelpers.export(exports, "Wordlist", ()=>(0, _wordlist.Wordlist));
parcelHelpers.export(exports, "wordlists", ()=>(0, _wordlists.wordlists));
// Wordlists
// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md
var _wordlist = require("./wordlist");
var _wordlists = require("./wordlists");
"use strict";

},{"./wordlist":"kXObs","./wordlists":"86SLu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXObs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logger", ()=>logger);
parcelHelpers.export(exports, "Wordlist", ()=>Wordlist);
var _hash = require("@ethersproject/hash");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
// This gets overridden by rollup
const exportWordlist = false;
const logger = new (0, _logger.Logger)((0, _version.version));
class Wordlist {
    constructor(locale){
        logger.checkAbstract(new.target, Wordlist);
        (0, _properties.defineReadOnly)(this, "locale", locale);
    }
    // Subclasses may override this
    split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
    }
    // Subclasses may override this
    join(words) {
        return words.join(" ");
    }
    static check(wordlist) {
        const words = [];
        for(let i = 0; i < 2048; i++){
            const word = wordlist.getWord(i);
            /* istanbul ignore if */ if (i !== wordlist.getWordIndex(word)) return "0x";
            words.push(word);
        }
        return (0, _hash.id)(words.join("\n") + "\n");
    }
    static register(lang, name) {
        if (!name) name = lang.locale;
        /* istanbul ignore if */ if (exportWordlist) try {
            const anyGlobal = window;
            if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
                if (!anyGlobal._ethers.wordlists[name]) (0, _properties.defineReadOnly)(anyGlobal._ethers.wordlists, name, lang);
            }
        } catch (error) {}
    }
}

},{"@ethersproject/hash":"7JYPm","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"7t5y5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7t5y5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "wordlists/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"86SLu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wordlists", ()=>wordlists);
var _langEn = require("./lang-en");
"use strict";
const wordlists = {
    en: (0, _langEn.langEn)
};

},{"./lang-en":"hahYq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hahYq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "langEn", ()=>langEn);
var _wordlist = require("./wordlist");
"use strict";
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
    if (wordlist != null) return;
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    // Verify the computed list matches the official list
    /* istanbul ignore if */ if ((0, _wordlist.Wordlist).check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
}
class LangEn extends (0, _wordlist.Wordlist) {
    constructor(){
        super("en");
    }
    getWord(index) {
        loadWords(this);
        return wordlist[index];
    }
    getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
    }
}
const langEn = new LangEn();
(0, _wordlist.Wordlist).register(langEn);

},{"./wordlist":"kXObs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Gslh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "hdnode/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7myQM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomBytes", ()=>(0, _random.randomBytes));
parcelHelpers.export(exports, "shuffled", ()=>(0, _shuffle.shuffled));
var _random = require("./random");
var _shuffle = require("./shuffle");
"use strict";

},{"./random":"h26nx","./shuffle":"aDkFd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h26nx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomBytes", ()=>randomBytes);
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var global = arguments[3];
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
// Debugging line for testing browser lib in node
//const window = { crypto: { getRandomValues: () => { } } };
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
function getGlobal() {
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto || !crypto.getRandomValues) {
    logger.warn("WARNING: Missing strong random number source");
    crypto = {
        getRandomValues: function(buffer) {
            return logger.throwError("no secure random source avaialble", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "crypto.getRandomValues"
            });
        }
    };
}
function randomBytes(length) {
    if (length <= 0 || length > 1024 || length % 1 || length != length) logger.throwArgumentError("invalid length", "length", length);
    const result = new Uint8Array(length);
    crypto.getRandomValues(result);
    return (0, _bytes.arrayify)(result);
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/logger":"hLvB2","./_version":"dxTsA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dxTsA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "random/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aDkFd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shuffled", ()=>shuffled);
"use strict";
function shuffled(array) {
    array = array.slice();
    for(let i = array.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    return array;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1qqTy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decryptCrowdsale", ()=>(0, _crowdsale.decrypt));
parcelHelpers.export(exports, "decryptKeystore", ()=>(0, _keystore.decrypt));
parcelHelpers.export(exports, "decryptKeystoreSync", ()=>(0, _keystore.decryptSync));
parcelHelpers.export(exports, "encryptKeystore", ()=>(0, _keystore.encrypt));
parcelHelpers.export(exports, "isCrowdsaleWallet", ()=>(0, _inspect.isCrowdsaleWallet));
parcelHelpers.export(exports, "isKeystoreWallet", ()=>(0, _inspect.isKeystoreWallet));
parcelHelpers.export(exports, "getJsonWalletAddress", ()=>(0, _inspect.getJsonWalletAddress));
parcelHelpers.export(exports, "decryptJsonWallet", ()=>decryptJsonWallet);
parcelHelpers.export(exports, "decryptJsonWalletSync", ()=>decryptJsonWalletSync);
var _crowdsale = require("./crowdsale");
var _inspect = require("./inspect");
var _keystore = require("./keystore");
"use strict";
function decryptJsonWallet(json, password, progressCallback) {
    if ((0, _inspect.isCrowdsaleWallet)(json)) {
        if (progressCallback) progressCallback(0);
        const account = (0, _crowdsale.decrypt)(json, password);
        if (progressCallback) progressCallback(1);
        return Promise.resolve(account);
    }
    if ((0, _inspect.isKeystoreWallet)(json)) return (0, _keystore.decrypt)(json, password, progressCallback);
    return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
    if ((0, _inspect.isCrowdsaleWallet)(json)) return (0, _crowdsale.decrypt)(json, password);
    if ((0, _inspect.isKeystoreWallet)(json)) return (0, _keystore.decryptSync)(json, password);
    throw new Error("invalid JSON wallet");
}

},{"./crowdsale":"61FHg","./inspect":"1ZcmH","./keystore":"cTqKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"61FHg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CrowdsaleAccount", ()=>CrowdsaleAccount);
// See: https://github.com/ethereum/pyethsaletool
parcelHelpers.export(exports, "decrypt", ()=>decrypt);
var _aesJs = require("aes-js");
var _aesJsDefault = parcelHelpers.interopDefault(_aesJs);
var _address = require("@ethersproject/address");
var _bytes = require("@ethersproject/bytes");
var _keccak256 = require("@ethersproject/keccak256");
var _pbkdf2 = require("@ethersproject/pbkdf2");
var _strings = require("@ethersproject/strings");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _utils = require("./utils");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
class CrowdsaleAccount extends (0, _properties.Description) {
    isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
    }
}
function decrypt(json, password) {
    const data = JSON.parse(json);
    password = (0, _utils.getPassword)(password);
    // Ethereum Address
    const ethaddr = (0, _address.getAddress)((0, _utils.searchPath)(data, "ethaddr"));
    // Encrypted Seed
    const encseed = (0, _utils.looseArrayify)((0, _utils.searchPath)(data, "encseed"));
    if (!encseed || encseed.length % 16 !== 0) logger.throwArgumentError("invalid encseed", "json", json);
    const key = (0, _bytes.arrayify)((0, _pbkdf2.pbkdf2)(password, password, 2000, 32, "sha256")).slice(0, 16);
    const iv = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    // Decrypt the seed
    const aesCbc = new (0, _aesJsDefault.default).ModeOfOperation.cbc(key, iv);
    const seed = (0, _aesJsDefault.default).padding.pkcs7.strip((0, _bytes.arrayify)(aesCbc.decrypt(encryptedSeed)));
    // This wallet format is weird... Convert the binary encoded hex to a string.
    let seedHex = "";
    for(let i = 0; i < seed.length; i++)seedHex += String.fromCharCode(seed[i]);
    const seedHexBytes = (0, _strings.toUtf8Bytes)(seedHex);
    const privateKey = (0, _keccak256.keccak256)(seedHexBytes);
    return new CrowdsaleAccount({
        _isCrowdsaleAccount: true,
        address: ethaddr,
        privateKey: privateKey
    });
}

},{"aes-js":"6m1U5","@ethersproject/address":"ggdAz","@ethersproject/bytes":"htrqZ","@ethersproject/keccak256":"hXDEv","@ethersproject/pbkdf2":"ityKl","@ethersproject/strings":"5TGFZ","@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"ijo9y","./utils":"d3wDI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6m1U5":[function(require,module,exports) {
"use strict";
(function(root) {
    function checkInt(value) {
        return parseInt(value) === value;
    }
    function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) return false;
        for(var i = 0; i < arrayish.length; i++){
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) return false;
        }
        return true;
    }
    function coerceArray(arg, copy) {
        // ArrayBuffer view
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
            if (copy) {
                if (arg.slice) arg = arg.slice();
                else arg = Array.prototype.slice.call(arg);
            }
            return arg;
        }
        // It's an array; check it is a valid representation of a byte
        if (Array.isArray(arg)) {
            if (!checkInts(arg)) throw new Error("Array contains invalid value: " + arg);
            return new Uint8Array(arg);
        }
        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
        if (checkInt(arg.length) && checkInts(arg)) return new Uint8Array(arg);
        throw new Error("unsupported array-like object");
    }
    function createArray(length) {
        return new Uint8Array(length);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            else sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
        targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function() {
        function toBytes(text) {
            var result = [], i = 0;
            text = encodeURI(text);
            while(i < text.length){
                var c = text.charCodeAt(i++);
                // if it is a % sign, encode the following 2 bytes as a hex value
                if (c === 37) {
                    result.push(parseInt(text.substr(i, 2), 16));
                    i += 2;
                // otherwise, just the actual byte
                } else result.push(c);
            }
            return coerceArray(result);
        }
        function fromBytes(bytes) {
            var result = [], i = 0;
            while(i < bytes.length){
                var c = bytes[i];
                if (c < 128) {
                    result.push(String.fromCharCode(c));
                    i++;
                } else if (c > 191 && c < 224) {
                    result.push(String.fromCharCode((c & 0x1f) << 6 | bytes[i + 1] & 0x3f));
                    i += 2;
                } else {
                    result.push(String.fromCharCode((c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f));
                    i += 3;
                }
            }
            return result.join("");
        }
        return {
            toBytes: toBytes,
            fromBytes: fromBytes
        };
    }();
    var convertHex = function() {
        function toBytes(text) {
            var result = [];
            for(var i = 0; i < text.length; i += 2)result.push(parseInt(text.substr(i, 2), 16));
            return result;
        }
        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
            var result = [];
            for(var i = 0; i < bytes.length; i++){
                var v = bytes[i];
                result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
            }
            return result.join("");
        }
        return {
            toBytes: toBytes,
            fromBytes: fromBytes
        };
    }();
    // Number of rounds by keysize
    var numberOfRounds = {
        16: 10,
        24: 12,
        32: 14
    };
    // Round constant words
    var rcon = [
        0x01,
        0x02,
        0x04,
        0x08,
        0x10,
        0x20,
        0x40,
        0x80,
        0x1b,
        0x36,
        0x6c,
        0xd8,
        0xab,
        0x4d,
        0x9a,
        0x2f,
        0x5e,
        0xbc,
        0x63,
        0xc6,
        0x97,
        0x35,
        0x6a,
        0xd4,
        0xb3,
        0x7d,
        0xfa,
        0xef,
        0xc5,
        0x91
    ];
    // S-box and Inverse S-box (S is for Substitution)
    var S = [
        0x63,
        0x7c,
        0x77,
        0x7b,
        0xf2,
        0x6b,
        0x6f,
        0xc5,
        0x30,
        0x01,
        0x67,
        0x2b,
        0xfe,
        0xd7,
        0xab,
        0x76,
        0xca,
        0x82,
        0xc9,
        0x7d,
        0xfa,
        0x59,
        0x47,
        0xf0,
        0xad,
        0xd4,
        0xa2,
        0xaf,
        0x9c,
        0xa4,
        0x72,
        0xc0,
        0xb7,
        0xfd,
        0x93,
        0x26,
        0x36,
        0x3f,
        0xf7,
        0xcc,
        0x34,
        0xa5,
        0xe5,
        0xf1,
        0x71,
        0xd8,
        0x31,
        0x15,
        0x04,
        0xc7,
        0x23,
        0xc3,
        0x18,
        0x96,
        0x05,
        0x9a,
        0x07,
        0x12,
        0x80,
        0xe2,
        0xeb,
        0x27,
        0xb2,
        0x75,
        0x09,
        0x83,
        0x2c,
        0x1a,
        0x1b,
        0x6e,
        0x5a,
        0xa0,
        0x52,
        0x3b,
        0xd6,
        0xb3,
        0x29,
        0xe3,
        0x2f,
        0x84,
        0x53,
        0xd1,
        0x00,
        0xed,
        0x20,
        0xfc,
        0xb1,
        0x5b,
        0x6a,
        0xcb,
        0xbe,
        0x39,
        0x4a,
        0x4c,
        0x58,
        0xcf,
        0xd0,
        0xef,
        0xaa,
        0xfb,
        0x43,
        0x4d,
        0x33,
        0x85,
        0x45,
        0xf9,
        0x02,
        0x7f,
        0x50,
        0x3c,
        0x9f,
        0xa8,
        0x51,
        0xa3,
        0x40,
        0x8f,
        0x92,
        0x9d,
        0x38,
        0xf5,
        0xbc,
        0xb6,
        0xda,
        0x21,
        0x10,
        0xff,
        0xf3,
        0xd2,
        0xcd,
        0x0c,
        0x13,
        0xec,
        0x5f,
        0x97,
        0x44,
        0x17,
        0xc4,
        0xa7,
        0x7e,
        0x3d,
        0x64,
        0x5d,
        0x19,
        0x73,
        0x60,
        0x81,
        0x4f,
        0xdc,
        0x22,
        0x2a,
        0x90,
        0x88,
        0x46,
        0xee,
        0xb8,
        0x14,
        0xde,
        0x5e,
        0x0b,
        0xdb,
        0xe0,
        0x32,
        0x3a,
        0x0a,
        0x49,
        0x06,
        0x24,
        0x5c,
        0xc2,
        0xd3,
        0xac,
        0x62,
        0x91,
        0x95,
        0xe4,
        0x79,
        0xe7,
        0xc8,
        0x37,
        0x6d,
        0x8d,
        0xd5,
        0x4e,
        0xa9,
        0x6c,
        0x56,
        0xf4,
        0xea,
        0x65,
        0x7a,
        0xae,
        0x08,
        0xba,
        0x78,
        0x25,
        0x2e,
        0x1c,
        0xa6,
        0xb4,
        0xc6,
        0xe8,
        0xdd,
        0x74,
        0x1f,
        0x4b,
        0xbd,
        0x8b,
        0x8a,
        0x70,
        0x3e,
        0xb5,
        0x66,
        0x48,
        0x03,
        0xf6,
        0x0e,
        0x61,
        0x35,
        0x57,
        0xb9,
        0x86,
        0xc1,
        0x1d,
        0x9e,
        0xe1,
        0xf8,
        0x98,
        0x11,
        0x69,
        0xd9,
        0x8e,
        0x94,
        0x9b,
        0x1e,
        0x87,
        0xe9,
        0xce,
        0x55,
        0x28,
        0xdf,
        0x8c,
        0xa1,
        0x89,
        0x0d,
        0xbf,
        0xe6,
        0x42,
        0x68,
        0x41,
        0x99,
        0x2d,
        0x0f,
        0xb0,
        0x54,
        0xbb,
        0x16
    ];
    var Si = [
        0x52,
        0x09,
        0x6a,
        0xd5,
        0x30,
        0x36,
        0xa5,
        0x38,
        0xbf,
        0x40,
        0xa3,
        0x9e,
        0x81,
        0xf3,
        0xd7,
        0xfb,
        0x7c,
        0xe3,
        0x39,
        0x82,
        0x9b,
        0x2f,
        0xff,
        0x87,
        0x34,
        0x8e,
        0x43,
        0x44,
        0xc4,
        0xde,
        0xe9,
        0xcb,
        0x54,
        0x7b,
        0x94,
        0x32,
        0xa6,
        0xc2,
        0x23,
        0x3d,
        0xee,
        0x4c,
        0x95,
        0x0b,
        0x42,
        0xfa,
        0xc3,
        0x4e,
        0x08,
        0x2e,
        0xa1,
        0x66,
        0x28,
        0xd9,
        0x24,
        0xb2,
        0x76,
        0x5b,
        0xa2,
        0x49,
        0x6d,
        0x8b,
        0xd1,
        0x25,
        0x72,
        0xf8,
        0xf6,
        0x64,
        0x86,
        0x68,
        0x98,
        0x16,
        0xd4,
        0xa4,
        0x5c,
        0xcc,
        0x5d,
        0x65,
        0xb6,
        0x92,
        0x6c,
        0x70,
        0x48,
        0x50,
        0xfd,
        0xed,
        0xb9,
        0xda,
        0x5e,
        0x15,
        0x46,
        0x57,
        0xa7,
        0x8d,
        0x9d,
        0x84,
        0x90,
        0xd8,
        0xab,
        0x00,
        0x8c,
        0xbc,
        0xd3,
        0x0a,
        0xf7,
        0xe4,
        0x58,
        0x05,
        0xb8,
        0xb3,
        0x45,
        0x06,
        0xd0,
        0x2c,
        0x1e,
        0x8f,
        0xca,
        0x3f,
        0x0f,
        0x02,
        0xc1,
        0xaf,
        0xbd,
        0x03,
        0x01,
        0x13,
        0x8a,
        0x6b,
        0x3a,
        0x91,
        0x11,
        0x41,
        0x4f,
        0x67,
        0xdc,
        0xea,
        0x97,
        0xf2,
        0xcf,
        0xce,
        0xf0,
        0xb4,
        0xe6,
        0x73,
        0x96,
        0xac,
        0x74,
        0x22,
        0xe7,
        0xad,
        0x35,
        0x85,
        0xe2,
        0xf9,
        0x37,
        0xe8,
        0x1c,
        0x75,
        0xdf,
        0x6e,
        0x47,
        0xf1,
        0x1a,
        0x71,
        0x1d,
        0x29,
        0xc5,
        0x89,
        0x6f,
        0xb7,
        0x62,
        0x0e,
        0xaa,
        0x18,
        0xbe,
        0x1b,
        0xfc,
        0x56,
        0x3e,
        0x4b,
        0xc6,
        0xd2,
        0x79,
        0x20,
        0x9a,
        0xdb,
        0xc0,
        0xfe,
        0x78,
        0xcd,
        0x5a,
        0xf4,
        0x1f,
        0xdd,
        0xa8,
        0x33,
        0x88,
        0x07,
        0xc7,
        0x31,
        0xb1,
        0x12,
        0x10,
        0x59,
        0x27,
        0x80,
        0xec,
        0x5f,
        0x60,
        0x51,
        0x7f,
        0xa9,
        0x19,
        0xb5,
        0x4a,
        0x0d,
        0x2d,
        0xe5,
        0x7a,
        0x9f,
        0x93,
        0xc9,
        0x9c,
        0xef,
        0xa0,
        0xe0,
        0x3b,
        0x4d,
        0xae,
        0x2a,
        0xf5,
        0xb0,
        0xc8,
        0xeb,
        0xbb,
        0x3c,
        0x83,
        0x53,
        0x99,
        0x61,
        0x17,
        0x2b,
        0x04,
        0x7e,
        0xba,
        0x77,
        0xd6,
        0x26,
        0xe1,
        0x69,
        0x14,
        0x63,
        0x55,
        0x21,
        0x0c,
        0x7d
    ];
    // Transformations for encryption
    var T1 = [
        0xc66363a5,
        0xf87c7c84,
        0xee777799,
        0xf67b7b8d,
        0xfff2f20d,
        0xd66b6bbd,
        0xde6f6fb1,
        0x91c5c554,
        0x60303050,
        0x02010103,
        0xce6767a9,
        0x562b2b7d,
        0xe7fefe19,
        0xb5d7d762,
        0x4dababe6,
        0xec76769a,
        0x8fcaca45,
        0x1f82829d,
        0x89c9c940,
        0xfa7d7d87,
        0xeffafa15,
        0xb25959eb,
        0x8e4747c9,
        0xfbf0f00b,
        0x41adadec,
        0xb3d4d467,
        0x5fa2a2fd,
        0x45afafea,
        0x239c9cbf,
        0x53a4a4f7,
        0xe4727296,
        0x9bc0c05b,
        0x75b7b7c2,
        0xe1fdfd1c,
        0x3d9393ae,
        0x4c26266a,
        0x6c36365a,
        0x7e3f3f41,
        0xf5f7f702,
        0x83cccc4f,
        0x6834345c,
        0x51a5a5f4,
        0xd1e5e534,
        0xf9f1f108,
        0xe2717193,
        0xabd8d873,
        0x62313153,
        0x2a15153f,
        0x0804040c,
        0x95c7c752,
        0x46232365,
        0x9dc3c35e,
        0x30181828,
        0x379696a1,
        0x0a05050f,
        0x2f9a9ab5,
        0x0e070709,
        0x24121236,
        0x1b80809b,
        0xdfe2e23d,
        0xcdebeb26,
        0x4e272769,
        0x7fb2b2cd,
        0xea75759f,
        0x1209091b,
        0x1d83839e,
        0x582c2c74,
        0x341a1a2e,
        0x361b1b2d,
        0xdc6e6eb2,
        0xb45a5aee,
        0x5ba0a0fb,
        0xa45252f6,
        0x763b3b4d,
        0xb7d6d661,
        0x7db3b3ce,
        0x5229297b,
        0xdde3e33e,
        0x5e2f2f71,
        0x13848497,
        0xa65353f5,
        0xb9d1d168,
        0x00000000,
        0xc1eded2c,
        0x40202060,
        0xe3fcfc1f,
        0x79b1b1c8,
        0xb65b5bed,
        0xd46a6abe,
        0x8dcbcb46,
        0x67bebed9,
        0x7239394b,
        0x944a4ade,
        0x984c4cd4,
        0xb05858e8,
        0x85cfcf4a,
        0xbbd0d06b,
        0xc5efef2a,
        0x4faaaae5,
        0xedfbfb16,
        0x864343c5,
        0x9a4d4dd7,
        0x66333355,
        0x11858594,
        0x8a4545cf,
        0xe9f9f910,
        0x04020206,
        0xfe7f7f81,
        0xa05050f0,
        0x783c3c44,
        0x259f9fba,
        0x4ba8a8e3,
        0xa25151f3,
        0x5da3a3fe,
        0x804040c0,
        0x058f8f8a,
        0x3f9292ad,
        0x219d9dbc,
        0x70383848,
        0xf1f5f504,
        0x63bcbcdf,
        0x77b6b6c1,
        0xafdada75,
        0x42212163,
        0x20101030,
        0xe5ffff1a,
        0xfdf3f30e,
        0xbfd2d26d,
        0x81cdcd4c,
        0x180c0c14,
        0x26131335,
        0xc3ecec2f,
        0xbe5f5fe1,
        0x359797a2,
        0x884444cc,
        0x2e171739,
        0x93c4c457,
        0x55a7a7f2,
        0xfc7e7e82,
        0x7a3d3d47,
        0xc86464ac,
        0xba5d5de7,
        0x3219192b,
        0xe6737395,
        0xc06060a0,
        0x19818198,
        0x9e4f4fd1,
        0xa3dcdc7f,
        0x44222266,
        0x542a2a7e,
        0x3b9090ab,
        0x0b888883,
        0x8c4646ca,
        0xc7eeee29,
        0x6bb8b8d3,
        0x2814143c,
        0xa7dede79,
        0xbc5e5ee2,
        0x160b0b1d,
        0xaddbdb76,
        0xdbe0e03b,
        0x64323256,
        0x743a3a4e,
        0x140a0a1e,
        0x924949db,
        0x0c06060a,
        0x4824246c,
        0xb85c5ce4,
        0x9fc2c25d,
        0xbdd3d36e,
        0x43acacef,
        0xc46262a6,
        0x399191a8,
        0x319595a4,
        0xd3e4e437,
        0xf279798b,
        0xd5e7e732,
        0x8bc8c843,
        0x6e373759,
        0xda6d6db7,
        0x018d8d8c,
        0xb1d5d564,
        0x9c4e4ed2,
        0x49a9a9e0,
        0xd86c6cb4,
        0xac5656fa,
        0xf3f4f407,
        0xcfeaea25,
        0xca6565af,
        0xf47a7a8e,
        0x47aeaee9,
        0x10080818,
        0x6fbabad5,
        0xf0787888,
        0x4a25256f,
        0x5c2e2e72,
        0x381c1c24,
        0x57a6a6f1,
        0x73b4b4c7,
        0x97c6c651,
        0xcbe8e823,
        0xa1dddd7c,
        0xe874749c,
        0x3e1f1f21,
        0x964b4bdd,
        0x61bdbddc,
        0x0d8b8b86,
        0x0f8a8a85,
        0xe0707090,
        0x7c3e3e42,
        0x71b5b5c4,
        0xcc6666aa,
        0x904848d8,
        0x06030305,
        0xf7f6f601,
        0x1c0e0e12,
        0xc26161a3,
        0x6a35355f,
        0xae5757f9,
        0x69b9b9d0,
        0x17868691,
        0x99c1c158,
        0x3a1d1d27,
        0x279e9eb9,
        0xd9e1e138,
        0xebf8f813,
        0x2b9898b3,
        0x22111133,
        0xd26969bb,
        0xa9d9d970,
        0x078e8e89,
        0x339494a7,
        0x2d9b9bb6,
        0x3c1e1e22,
        0x15878792,
        0xc9e9e920,
        0x87cece49,
        0xaa5555ff,
        0x50282878,
        0xa5dfdf7a,
        0x038c8c8f,
        0x59a1a1f8,
        0x09898980,
        0x1a0d0d17,
        0x65bfbfda,
        0xd7e6e631,
        0x844242c6,
        0xd06868b8,
        0x824141c3,
        0x299999b0,
        0x5a2d2d77,
        0x1e0f0f11,
        0x7bb0b0cb,
        0xa85454fc,
        0x6dbbbbd6,
        0x2c16163a
    ];
    var T2 = [
        0xa5c66363,
        0x84f87c7c,
        0x99ee7777,
        0x8df67b7b,
        0x0dfff2f2,
        0xbdd66b6b,
        0xb1de6f6f,
        0x5491c5c5,
        0x50603030,
        0x03020101,
        0xa9ce6767,
        0x7d562b2b,
        0x19e7fefe,
        0x62b5d7d7,
        0xe64dabab,
        0x9aec7676,
        0x458fcaca,
        0x9d1f8282,
        0x4089c9c9,
        0x87fa7d7d,
        0x15effafa,
        0xebb25959,
        0xc98e4747,
        0x0bfbf0f0,
        0xec41adad,
        0x67b3d4d4,
        0xfd5fa2a2,
        0xea45afaf,
        0xbf239c9c,
        0xf753a4a4,
        0x96e47272,
        0x5b9bc0c0,
        0xc275b7b7,
        0x1ce1fdfd,
        0xae3d9393,
        0x6a4c2626,
        0x5a6c3636,
        0x417e3f3f,
        0x02f5f7f7,
        0x4f83cccc,
        0x5c683434,
        0xf451a5a5,
        0x34d1e5e5,
        0x08f9f1f1,
        0x93e27171,
        0x73abd8d8,
        0x53623131,
        0x3f2a1515,
        0x0c080404,
        0x5295c7c7,
        0x65462323,
        0x5e9dc3c3,
        0x28301818,
        0xa1379696,
        0x0f0a0505,
        0xb52f9a9a,
        0x090e0707,
        0x36241212,
        0x9b1b8080,
        0x3ddfe2e2,
        0x26cdebeb,
        0x694e2727,
        0xcd7fb2b2,
        0x9fea7575,
        0x1b120909,
        0x9e1d8383,
        0x74582c2c,
        0x2e341a1a,
        0x2d361b1b,
        0xb2dc6e6e,
        0xeeb45a5a,
        0xfb5ba0a0,
        0xf6a45252,
        0x4d763b3b,
        0x61b7d6d6,
        0xce7db3b3,
        0x7b522929,
        0x3edde3e3,
        0x715e2f2f,
        0x97138484,
        0xf5a65353,
        0x68b9d1d1,
        0x00000000,
        0x2cc1eded,
        0x60402020,
        0x1fe3fcfc,
        0xc879b1b1,
        0xedb65b5b,
        0xbed46a6a,
        0x468dcbcb,
        0xd967bebe,
        0x4b723939,
        0xde944a4a,
        0xd4984c4c,
        0xe8b05858,
        0x4a85cfcf,
        0x6bbbd0d0,
        0x2ac5efef,
        0xe54faaaa,
        0x16edfbfb,
        0xc5864343,
        0xd79a4d4d,
        0x55663333,
        0x94118585,
        0xcf8a4545,
        0x10e9f9f9,
        0x06040202,
        0x81fe7f7f,
        0xf0a05050,
        0x44783c3c,
        0xba259f9f,
        0xe34ba8a8,
        0xf3a25151,
        0xfe5da3a3,
        0xc0804040,
        0x8a058f8f,
        0xad3f9292,
        0xbc219d9d,
        0x48703838,
        0x04f1f5f5,
        0xdf63bcbc,
        0xc177b6b6,
        0x75afdada,
        0x63422121,
        0x30201010,
        0x1ae5ffff,
        0x0efdf3f3,
        0x6dbfd2d2,
        0x4c81cdcd,
        0x14180c0c,
        0x35261313,
        0x2fc3ecec,
        0xe1be5f5f,
        0xa2359797,
        0xcc884444,
        0x392e1717,
        0x5793c4c4,
        0xf255a7a7,
        0x82fc7e7e,
        0x477a3d3d,
        0xacc86464,
        0xe7ba5d5d,
        0x2b321919,
        0x95e67373,
        0xa0c06060,
        0x98198181,
        0xd19e4f4f,
        0x7fa3dcdc,
        0x66442222,
        0x7e542a2a,
        0xab3b9090,
        0x830b8888,
        0xca8c4646,
        0x29c7eeee,
        0xd36bb8b8,
        0x3c281414,
        0x79a7dede,
        0xe2bc5e5e,
        0x1d160b0b,
        0x76addbdb,
        0x3bdbe0e0,
        0x56643232,
        0x4e743a3a,
        0x1e140a0a,
        0xdb924949,
        0x0a0c0606,
        0x6c482424,
        0xe4b85c5c,
        0x5d9fc2c2,
        0x6ebdd3d3,
        0xef43acac,
        0xa6c46262,
        0xa8399191,
        0xa4319595,
        0x37d3e4e4,
        0x8bf27979,
        0x32d5e7e7,
        0x438bc8c8,
        0x596e3737,
        0xb7da6d6d,
        0x8c018d8d,
        0x64b1d5d5,
        0xd29c4e4e,
        0xe049a9a9,
        0xb4d86c6c,
        0xfaac5656,
        0x07f3f4f4,
        0x25cfeaea,
        0xafca6565,
        0x8ef47a7a,
        0xe947aeae,
        0x18100808,
        0xd56fbaba,
        0x88f07878,
        0x6f4a2525,
        0x725c2e2e,
        0x24381c1c,
        0xf157a6a6,
        0xc773b4b4,
        0x5197c6c6,
        0x23cbe8e8,
        0x7ca1dddd,
        0x9ce87474,
        0x213e1f1f,
        0xdd964b4b,
        0xdc61bdbd,
        0x860d8b8b,
        0x850f8a8a,
        0x90e07070,
        0x427c3e3e,
        0xc471b5b5,
        0xaacc6666,
        0xd8904848,
        0x05060303,
        0x01f7f6f6,
        0x121c0e0e,
        0xa3c26161,
        0x5f6a3535,
        0xf9ae5757,
        0xd069b9b9,
        0x91178686,
        0x5899c1c1,
        0x273a1d1d,
        0xb9279e9e,
        0x38d9e1e1,
        0x13ebf8f8,
        0xb32b9898,
        0x33221111,
        0xbbd26969,
        0x70a9d9d9,
        0x89078e8e,
        0xa7339494,
        0xb62d9b9b,
        0x223c1e1e,
        0x92158787,
        0x20c9e9e9,
        0x4987cece,
        0xffaa5555,
        0x78502828,
        0x7aa5dfdf,
        0x8f038c8c,
        0xf859a1a1,
        0x80098989,
        0x171a0d0d,
        0xda65bfbf,
        0x31d7e6e6,
        0xc6844242,
        0xb8d06868,
        0xc3824141,
        0xb0299999,
        0x775a2d2d,
        0x111e0f0f,
        0xcb7bb0b0,
        0xfca85454,
        0xd66dbbbb,
        0x3a2c1616
    ];
    var T3 = [
        0x63a5c663,
        0x7c84f87c,
        0x7799ee77,
        0x7b8df67b,
        0xf20dfff2,
        0x6bbdd66b,
        0x6fb1de6f,
        0xc55491c5,
        0x30506030,
        0x01030201,
        0x67a9ce67,
        0x2b7d562b,
        0xfe19e7fe,
        0xd762b5d7,
        0xabe64dab,
        0x769aec76,
        0xca458fca,
        0x829d1f82,
        0xc94089c9,
        0x7d87fa7d,
        0xfa15effa,
        0x59ebb259,
        0x47c98e47,
        0xf00bfbf0,
        0xadec41ad,
        0xd467b3d4,
        0xa2fd5fa2,
        0xafea45af,
        0x9cbf239c,
        0xa4f753a4,
        0x7296e472,
        0xc05b9bc0,
        0xb7c275b7,
        0xfd1ce1fd,
        0x93ae3d93,
        0x266a4c26,
        0x365a6c36,
        0x3f417e3f,
        0xf702f5f7,
        0xcc4f83cc,
        0x345c6834,
        0xa5f451a5,
        0xe534d1e5,
        0xf108f9f1,
        0x7193e271,
        0xd873abd8,
        0x31536231,
        0x153f2a15,
        0x040c0804,
        0xc75295c7,
        0x23654623,
        0xc35e9dc3,
        0x18283018,
        0x96a13796,
        0x050f0a05,
        0x9ab52f9a,
        0x07090e07,
        0x12362412,
        0x809b1b80,
        0xe23ddfe2,
        0xeb26cdeb,
        0x27694e27,
        0xb2cd7fb2,
        0x759fea75,
        0x091b1209,
        0x839e1d83,
        0x2c74582c,
        0x1a2e341a,
        0x1b2d361b,
        0x6eb2dc6e,
        0x5aeeb45a,
        0xa0fb5ba0,
        0x52f6a452,
        0x3b4d763b,
        0xd661b7d6,
        0xb3ce7db3,
        0x297b5229,
        0xe33edde3,
        0x2f715e2f,
        0x84971384,
        0x53f5a653,
        0xd168b9d1,
        0x00000000,
        0xed2cc1ed,
        0x20604020,
        0xfc1fe3fc,
        0xb1c879b1,
        0x5bedb65b,
        0x6abed46a,
        0xcb468dcb,
        0xbed967be,
        0x394b7239,
        0x4ade944a,
        0x4cd4984c,
        0x58e8b058,
        0xcf4a85cf,
        0xd06bbbd0,
        0xef2ac5ef,
        0xaae54faa,
        0xfb16edfb,
        0x43c58643,
        0x4dd79a4d,
        0x33556633,
        0x85941185,
        0x45cf8a45,
        0xf910e9f9,
        0x02060402,
        0x7f81fe7f,
        0x50f0a050,
        0x3c44783c,
        0x9fba259f,
        0xa8e34ba8,
        0x51f3a251,
        0xa3fe5da3,
        0x40c08040,
        0x8f8a058f,
        0x92ad3f92,
        0x9dbc219d,
        0x38487038,
        0xf504f1f5,
        0xbcdf63bc,
        0xb6c177b6,
        0xda75afda,
        0x21634221,
        0x10302010,
        0xff1ae5ff,
        0xf30efdf3,
        0xd26dbfd2,
        0xcd4c81cd,
        0x0c14180c,
        0x13352613,
        0xec2fc3ec,
        0x5fe1be5f,
        0x97a23597,
        0x44cc8844,
        0x17392e17,
        0xc45793c4,
        0xa7f255a7,
        0x7e82fc7e,
        0x3d477a3d,
        0x64acc864,
        0x5de7ba5d,
        0x192b3219,
        0x7395e673,
        0x60a0c060,
        0x81981981,
        0x4fd19e4f,
        0xdc7fa3dc,
        0x22664422,
        0x2a7e542a,
        0x90ab3b90,
        0x88830b88,
        0x46ca8c46,
        0xee29c7ee,
        0xb8d36bb8,
        0x143c2814,
        0xde79a7de,
        0x5ee2bc5e,
        0x0b1d160b,
        0xdb76addb,
        0xe03bdbe0,
        0x32566432,
        0x3a4e743a,
        0x0a1e140a,
        0x49db9249,
        0x060a0c06,
        0x246c4824,
        0x5ce4b85c,
        0xc25d9fc2,
        0xd36ebdd3,
        0xacef43ac,
        0x62a6c462,
        0x91a83991,
        0x95a43195,
        0xe437d3e4,
        0x798bf279,
        0xe732d5e7,
        0xc8438bc8,
        0x37596e37,
        0x6db7da6d,
        0x8d8c018d,
        0xd564b1d5,
        0x4ed29c4e,
        0xa9e049a9,
        0x6cb4d86c,
        0x56faac56,
        0xf407f3f4,
        0xea25cfea,
        0x65afca65,
        0x7a8ef47a,
        0xaee947ae,
        0x08181008,
        0xbad56fba,
        0x7888f078,
        0x256f4a25,
        0x2e725c2e,
        0x1c24381c,
        0xa6f157a6,
        0xb4c773b4,
        0xc65197c6,
        0xe823cbe8,
        0xdd7ca1dd,
        0x749ce874,
        0x1f213e1f,
        0x4bdd964b,
        0xbddc61bd,
        0x8b860d8b,
        0x8a850f8a,
        0x7090e070,
        0x3e427c3e,
        0xb5c471b5,
        0x66aacc66,
        0x48d89048,
        0x03050603,
        0xf601f7f6,
        0x0e121c0e,
        0x61a3c261,
        0x355f6a35,
        0x57f9ae57,
        0xb9d069b9,
        0x86911786,
        0xc15899c1,
        0x1d273a1d,
        0x9eb9279e,
        0xe138d9e1,
        0xf813ebf8,
        0x98b32b98,
        0x11332211,
        0x69bbd269,
        0xd970a9d9,
        0x8e89078e,
        0x94a73394,
        0x9bb62d9b,
        0x1e223c1e,
        0x87921587,
        0xe920c9e9,
        0xce4987ce,
        0x55ffaa55,
        0x28785028,
        0xdf7aa5df,
        0x8c8f038c,
        0xa1f859a1,
        0x89800989,
        0x0d171a0d,
        0xbfda65bf,
        0xe631d7e6,
        0x42c68442,
        0x68b8d068,
        0x41c38241,
        0x99b02999,
        0x2d775a2d,
        0x0f111e0f,
        0xb0cb7bb0,
        0x54fca854,
        0xbbd66dbb,
        0x163a2c16
    ];
    var T4 = [
        0x6363a5c6,
        0x7c7c84f8,
        0x777799ee,
        0x7b7b8df6,
        0xf2f20dff,
        0x6b6bbdd6,
        0x6f6fb1de,
        0xc5c55491,
        0x30305060,
        0x01010302,
        0x6767a9ce,
        0x2b2b7d56,
        0xfefe19e7,
        0xd7d762b5,
        0xababe64d,
        0x76769aec,
        0xcaca458f,
        0x82829d1f,
        0xc9c94089,
        0x7d7d87fa,
        0xfafa15ef,
        0x5959ebb2,
        0x4747c98e,
        0xf0f00bfb,
        0xadadec41,
        0xd4d467b3,
        0xa2a2fd5f,
        0xafafea45,
        0x9c9cbf23,
        0xa4a4f753,
        0x727296e4,
        0xc0c05b9b,
        0xb7b7c275,
        0xfdfd1ce1,
        0x9393ae3d,
        0x26266a4c,
        0x36365a6c,
        0x3f3f417e,
        0xf7f702f5,
        0xcccc4f83,
        0x34345c68,
        0xa5a5f451,
        0xe5e534d1,
        0xf1f108f9,
        0x717193e2,
        0xd8d873ab,
        0x31315362,
        0x15153f2a,
        0x04040c08,
        0xc7c75295,
        0x23236546,
        0xc3c35e9d,
        0x18182830,
        0x9696a137,
        0x05050f0a,
        0x9a9ab52f,
        0x0707090e,
        0x12123624,
        0x80809b1b,
        0xe2e23ddf,
        0xebeb26cd,
        0x2727694e,
        0xb2b2cd7f,
        0x75759fea,
        0x09091b12,
        0x83839e1d,
        0x2c2c7458,
        0x1a1a2e34,
        0x1b1b2d36,
        0x6e6eb2dc,
        0x5a5aeeb4,
        0xa0a0fb5b,
        0x5252f6a4,
        0x3b3b4d76,
        0xd6d661b7,
        0xb3b3ce7d,
        0x29297b52,
        0xe3e33edd,
        0x2f2f715e,
        0x84849713,
        0x5353f5a6,
        0xd1d168b9,
        0x00000000,
        0xeded2cc1,
        0x20206040,
        0xfcfc1fe3,
        0xb1b1c879,
        0x5b5bedb6,
        0x6a6abed4,
        0xcbcb468d,
        0xbebed967,
        0x39394b72,
        0x4a4ade94,
        0x4c4cd498,
        0x5858e8b0,
        0xcfcf4a85,
        0xd0d06bbb,
        0xefef2ac5,
        0xaaaae54f,
        0xfbfb16ed,
        0x4343c586,
        0x4d4dd79a,
        0x33335566,
        0x85859411,
        0x4545cf8a,
        0xf9f910e9,
        0x02020604,
        0x7f7f81fe,
        0x5050f0a0,
        0x3c3c4478,
        0x9f9fba25,
        0xa8a8e34b,
        0x5151f3a2,
        0xa3a3fe5d,
        0x4040c080,
        0x8f8f8a05,
        0x9292ad3f,
        0x9d9dbc21,
        0x38384870,
        0xf5f504f1,
        0xbcbcdf63,
        0xb6b6c177,
        0xdada75af,
        0x21216342,
        0x10103020,
        0xffff1ae5,
        0xf3f30efd,
        0xd2d26dbf,
        0xcdcd4c81,
        0x0c0c1418,
        0x13133526,
        0xecec2fc3,
        0x5f5fe1be,
        0x9797a235,
        0x4444cc88,
        0x1717392e,
        0xc4c45793,
        0xa7a7f255,
        0x7e7e82fc,
        0x3d3d477a,
        0x6464acc8,
        0x5d5de7ba,
        0x19192b32,
        0x737395e6,
        0x6060a0c0,
        0x81819819,
        0x4f4fd19e,
        0xdcdc7fa3,
        0x22226644,
        0x2a2a7e54,
        0x9090ab3b,
        0x8888830b,
        0x4646ca8c,
        0xeeee29c7,
        0xb8b8d36b,
        0x14143c28,
        0xdede79a7,
        0x5e5ee2bc,
        0x0b0b1d16,
        0xdbdb76ad,
        0xe0e03bdb,
        0x32325664,
        0x3a3a4e74,
        0x0a0a1e14,
        0x4949db92,
        0x06060a0c,
        0x24246c48,
        0x5c5ce4b8,
        0xc2c25d9f,
        0xd3d36ebd,
        0xacacef43,
        0x6262a6c4,
        0x9191a839,
        0x9595a431,
        0xe4e437d3,
        0x79798bf2,
        0xe7e732d5,
        0xc8c8438b,
        0x3737596e,
        0x6d6db7da,
        0x8d8d8c01,
        0xd5d564b1,
        0x4e4ed29c,
        0xa9a9e049,
        0x6c6cb4d8,
        0x5656faac,
        0xf4f407f3,
        0xeaea25cf,
        0x6565afca,
        0x7a7a8ef4,
        0xaeaee947,
        0x08081810,
        0xbabad56f,
        0x787888f0,
        0x25256f4a,
        0x2e2e725c,
        0x1c1c2438,
        0xa6a6f157,
        0xb4b4c773,
        0xc6c65197,
        0xe8e823cb,
        0xdddd7ca1,
        0x74749ce8,
        0x1f1f213e,
        0x4b4bdd96,
        0xbdbddc61,
        0x8b8b860d,
        0x8a8a850f,
        0x707090e0,
        0x3e3e427c,
        0xb5b5c471,
        0x6666aacc,
        0x4848d890,
        0x03030506,
        0xf6f601f7,
        0x0e0e121c,
        0x6161a3c2,
        0x35355f6a,
        0x5757f9ae,
        0xb9b9d069,
        0x86869117,
        0xc1c15899,
        0x1d1d273a,
        0x9e9eb927,
        0xe1e138d9,
        0xf8f813eb,
        0x9898b32b,
        0x11113322,
        0x6969bbd2,
        0xd9d970a9,
        0x8e8e8907,
        0x9494a733,
        0x9b9bb62d,
        0x1e1e223c,
        0x87879215,
        0xe9e920c9,
        0xcece4987,
        0x5555ffaa,
        0x28287850,
        0xdfdf7aa5,
        0x8c8c8f03,
        0xa1a1f859,
        0x89898009,
        0x0d0d171a,
        0xbfbfda65,
        0xe6e631d7,
        0x4242c684,
        0x6868b8d0,
        0x4141c382,
        0x9999b029,
        0x2d2d775a,
        0x0f0f111e,
        0xb0b0cb7b,
        0x5454fca8,
        0xbbbbd66d,
        0x16163a2c
    ];
    // Transformations for decryption
    var T5 = [
        0x51f4a750,
        0x7e416553,
        0x1a17a4c3,
        0x3a275e96,
        0x3bab6bcb,
        0x1f9d45f1,
        0xacfa58ab,
        0x4be30393,
        0x2030fa55,
        0xad766df6,
        0x88cc7691,
        0xf5024c25,
        0x4fe5d7fc,
        0xc52acbd7,
        0x26354480,
        0xb562a38f,
        0xdeb15a49,
        0x25ba1b67,
        0x45ea0e98,
        0x5dfec0e1,
        0xc32f7502,
        0x814cf012,
        0x8d4697a3,
        0x6bd3f9c6,
        0x038f5fe7,
        0x15929c95,
        0xbf6d7aeb,
        0x955259da,
        0xd4be832d,
        0x587421d3,
        0x49e06929,
        0x8ec9c844,
        0x75c2896a,
        0xf48e7978,
        0x99583e6b,
        0x27b971dd,
        0xbee14fb6,
        0xf088ad17,
        0xc920ac66,
        0x7dce3ab4,
        0x63df4a18,
        0xe51a3182,
        0x97513360,
        0x62537f45,
        0xb16477e0,
        0xbb6bae84,
        0xfe81a01c,
        0xf9082b94,
        0x70486858,
        0x8f45fd19,
        0x94de6c87,
        0x527bf8b7,
        0xab73d323,
        0x724b02e2,
        0xe31f8f57,
        0x6655ab2a,
        0xb2eb2807,
        0x2fb5c203,
        0x86c57b9a,
        0xd33708a5,
        0x302887f2,
        0x23bfa5b2,
        0x02036aba,
        0xed16825c,
        0x8acf1c2b,
        0xa779b492,
        0xf307f2f0,
        0x4e69e2a1,
        0x65daf4cd,
        0x0605bed5,
        0xd134621f,
        0xc4a6fe8a,
        0x342e539d,
        0xa2f355a0,
        0x058ae132,
        0xa4f6eb75,
        0x0b83ec39,
        0x4060efaa,
        0x5e719f06,
        0xbd6e1051,
        0x3e218af9,
        0x96dd063d,
        0xdd3e05ae,
        0x4de6bd46,
        0x91548db5,
        0x71c45d05,
        0x0406d46f,
        0x605015ff,
        0x1998fb24,
        0xd6bde997,
        0x894043cc,
        0x67d99e77,
        0xb0e842bd,
        0x07898b88,
        0xe7195b38,
        0x79c8eedb,
        0xa17c0a47,
        0x7c420fe9,
        0xf8841ec9,
        0x00000000,
        0x09808683,
        0x322bed48,
        0x1e1170ac,
        0x6c5a724e,
        0xfd0efffb,
        0x0f853856,
        0x3daed51e,
        0x362d3927,
        0x0a0fd964,
        0x685ca621,
        0x9b5b54d1,
        0x24362e3a,
        0x0c0a67b1,
        0x9357e70f,
        0xb4ee96d2,
        0x1b9b919e,
        0x80c0c54f,
        0x61dc20a2,
        0x5a774b69,
        0x1c121a16,
        0xe293ba0a,
        0xc0a02ae5,
        0x3c22e043,
        0x121b171d,
        0x0e090d0b,
        0xf28bc7ad,
        0x2db6a8b9,
        0x141ea9c8,
        0x57f11985,
        0xaf75074c,
        0xee99ddbb,
        0xa37f60fd,
        0xf701269f,
        0x5c72f5bc,
        0x44663bc5,
        0x5bfb7e34,
        0x8b432976,
        0xcb23c6dc,
        0xb6edfc68,
        0xb8e4f163,
        0xd731dcca,
        0x42638510,
        0x13972240,
        0x84c61120,
        0x854a247d,
        0xd2bb3df8,
        0xaef93211,
        0xc729a16d,
        0x1d9e2f4b,
        0xdcb230f3,
        0x0d8652ec,
        0x77c1e3d0,
        0x2bb3166c,
        0xa970b999,
        0x119448fa,
        0x47e96422,
        0xa8fc8cc4,
        0xa0f03f1a,
        0x567d2cd8,
        0x223390ef,
        0x87494ec7,
        0xd938d1c1,
        0x8ccaa2fe,
        0x98d40b36,
        0xa6f581cf,
        0xa57ade28,
        0xdab78e26,
        0x3fadbfa4,
        0x2c3a9de4,
        0x5078920d,
        0x6a5fcc9b,
        0x547e4662,
        0xf68d13c2,
        0x90d8b8e8,
        0x2e39f75e,
        0x82c3aff5,
        0x9f5d80be,
        0x69d0937c,
        0x6fd52da9,
        0xcf2512b3,
        0xc8ac993b,
        0x10187da7,
        0xe89c636e,
        0xdb3bbb7b,
        0xcd267809,
        0x6e5918f4,
        0xec9ab701,
        0x834f9aa8,
        0xe6956e65,
        0xaaffe67e,
        0x21bccf08,
        0xef15e8e6,
        0xbae79bd9,
        0x4a6f36ce,
        0xea9f09d4,
        0x29b07cd6,
        0x31a4b2af,
        0x2a3f2331,
        0xc6a59430,
        0x35a266c0,
        0x744ebc37,
        0xfc82caa6,
        0xe090d0b0,
        0x33a7d815,
        0xf104984a,
        0x41ecdaf7,
        0x7fcd500e,
        0x1791f62f,
        0x764dd68d,
        0x43efb04d,
        0xccaa4d54,
        0xe49604df,
        0x9ed1b5e3,
        0x4c6a881b,
        0xc12c1fb8,
        0x4665517f,
        0x9d5eea04,
        0x018c355d,
        0xfa877473,
        0xfb0b412e,
        0xb3671d5a,
        0x92dbd252,
        0xe9105633,
        0x6dd64713,
        0x9ad7618c,
        0x37a10c7a,
        0x59f8148e,
        0xeb133c89,
        0xcea927ee,
        0xb761c935,
        0xe11ce5ed,
        0x7a47b13c,
        0x9cd2df59,
        0x55f2733f,
        0x1814ce79,
        0x73c737bf,
        0x53f7cdea,
        0x5ffdaa5b,
        0xdf3d6f14,
        0x7844db86,
        0xcaaff381,
        0xb968c43e,
        0x3824342c,
        0xc2a3405f,
        0x161dc372,
        0xbce2250c,
        0x283c498b,
        0xff0d9541,
        0x39a80171,
        0x080cb3de,
        0xd8b4e49c,
        0x6456c190,
        0x7bcb8461,
        0xd532b670,
        0x486c5c74,
        0xd0b85742
    ];
    var T6 = [
        0x5051f4a7,
        0x537e4165,
        0xc31a17a4,
        0x963a275e,
        0xcb3bab6b,
        0xf11f9d45,
        0xabacfa58,
        0x934be303,
        0x552030fa,
        0xf6ad766d,
        0x9188cc76,
        0x25f5024c,
        0xfc4fe5d7,
        0xd7c52acb,
        0x80263544,
        0x8fb562a3,
        0x49deb15a,
        0x6725ba1b,
        0x9845ea0e,
        0xe15dfec0,
        0x02c32f75,
        0x12814cf0,
        0xa38d4697,
        0xc66bd3f9,
        0xe7038f5f,
        0x9515929c,
        0xebbf6d7a,
        0xda955259,
        0x2dd4be83,
        0xd3587421,
        0x2949e069,
        0x448ec9c8,
        0x6a75c289,
        0x78f48e79,
        0x6b99583e,
        0xdd27b971,
        0xb6bee14f,
        0x17f088ad,
        0x66c920ac,
        0xb47dce3a,
        0x1863df4a,
        0x82e51a31,
        0x60975133,
        0x4562537f,
        0xe0b16477,
        0x84bb6bae,
        0x1cfe81a0,
        0x94f9082b,
        0x58704868,
        0x198f45fd,
        0x8794de6c,
        0xb7527bf8,
        0x23ab73d3,
        0xe2724b02,
        0x57e31f8f,
        0x2a6655ab,
        0x07b2eb28,
        0x032fb5c2,
        0x9a86c57b,
        0xa5d33708,
        0xf2302887,
        0xb223bfa5,
        0xba02036a,
        0x5ced1682,
        0x2b8acf1c,
        0x92a779b4,
        0xf0f307f2,
        0xa14e69e2,
        0xcd65daf4,
        0xd50605be,
        0x1fd13462,
        0x8ac4a6fe,
        0x9d342e53,
        0xa0a2f355,
        0x32058ae1,
        0x75a4f6eb,
        0x390b83ec,
        0xaa4060ef,
        0x065e719f,
        0x51bd6e10,
        0xf93e218a,
        0x3d96dd06,
        0xaedd3e05,
        0x464de6bd,
        0xb591548d,
        0x0571c45d,
        0x6f0406d4,
        0xff605015,
        0x241998fb,
        0x97d6bde9,
        0xcc894043,
        0x7767d99e,
        0xbdb0e842,
        0x8807898b,
        0x38e7195b,
        0xdb79c8ee,
        0x47a17c0a,
        0xe97c420f,
        0xc9f8841e,
        0x00000000,
        0x83098086,
        0x48322bed,
        0xac1e1170,
        0x4e6c5a72,
        0xfbfd0eff,
        0x560f8538,
        0x1e3daed5,
        0x27362d39,
        0x640a0fd9,
        0x21685ca6,
        0xd19b5b54,
        0x3a24362e,
        0xb10c0a67,
        0x0f9357e7,
        0xd2b4ee96,
        0x9e1b9b91,
        0x4f80c0c5,
        0xa261dc20,
        0x695a774b,
        0x161c121a,
        0x0ae293ba,
        0xe5c0a02a,
        0x433c22e0,
        0x1d121b17,
        0x0b0e090d,
        0xadf28bc7,
        0xb92db6a8,
        0xc8141ea9,
        0x8557f119,
        0x4caf7507,
        0xbbee99dd,
        0xfda37f60,
        0x9ff70126,
        0xbc5c72f5,
        0xc544663b,
        0x345bfb7e,
        0x768b4329,
        0xdccb23c6,
        0x68b6edfc,
        0x63b8e4f1,
        0xcad731dc,
        0x10426385,
        0x40139722,
        0x2084c611,
        0x7d854a24,
        0xf8d2bb3d,
        0x11aef932,
        0x6dc729a1,
        0x4b1d9e2f,
        0xf3dcb230,
        0xec0d8652,
        0xd077c1e3,
        0x6c2bb316,
        0x99a970b9,
        0xfa119448,
        0x2247e964,
        0xc4a8fc8c,
        0x1aa0f03f,
        0xd8567d2c,
        0xef223390,
        0xc787494e,
        0xc1d938d1,
        0xfe8ccaa2,
        0x3698d40b,
        0xcfa6f581,
        0x28a57ade,
        0x26dab78e,
        0xa43fadbf,
        0xe42c3a9d,
        0x0d507892,
        0x9b6a5fcc,
        0x62547e46,
        0xc2f68d13,
        0xe890d8b8,
        0x5e2e39f7,
        0xf582c3af,
        0xbe9f5d80,
        0x7c69d093,
        0xa96fd52d,
        0xb3cf2512,
        0x3bc8ac99,
        0xa710187d,
        0x6ee89c63,
        0x7bdb3bbb,
        0x09cd2678,
        0xf46e5918,
        0x01ec9ab7,
        0xa8834f9a,
        0x65e6956e,
        0x7eaaffe6,
        0x0821bccf,
        0xe6ef15e8,
        0xd9bae79b,
        0xce4a6f36,
        0xd4ea9f09,
        0xd629b07c,
        0xaf31a4b2,
        0x312a3f23,
        0x30c6a594,
        0xc035a266,
        0x37744ebc,
        0xa6fc82ca,
        0xb0e090d0,
        0x1533a7d8,
        0x4af10498,
        0xf741ecda,
        0x0e7fcd50,
        0x2f1791f6,
        0x8d764dd6,
        0x4d43efb0,
        0x54ccaa4d,
        0xdfe49604,
        0xe39ed1b5,
        0x1b4c6a88,
        0xb8c12c1f,
        0x7f466551,
        0x049d5eea,
        0x5d018c35,
        0x73fa8774,
        0x2efb0b41,
        0x5ab3671d,
        0x5292dbd2,
        0x33e91056,
        0x136dd647,
        0x8c9ad761,
        0x7a37a10c,
        0x8e59f814,
        0x89eb133c,
        0xeecea927,
        0x35b761c9,
        0xede11ce5,
        0x3c7a47b1,
        0x599cd2df,
        0x3f55f273,
        0x791814ce,
        0xbf73c737,
        0xea53f7cd,
        0x5b5ffdaa,
        0x14df3d6f,
        0x867844db,
        0x81caaff3,
        0x3eb968c4,
        0x2c382434,
        0x5fc2a340,
        0x72161dc3,
        0x0cbce225,
        0x8b283c49,
        0x41ff0d95,
        0x7139a801,
        0xde080cb3,
        0x9cd8b4e4,
        0x906456c1,
        0x617bcb84,
        0x70d532b6,
        0x74486c5c,
        0x42d0b857
    ];
    var T7 = [
        0xa75051f4,
        0x65537e41,
        0xa4c31a17,
        0x5e963a27,
        0x6bcb3bab,
        0x45f11f9d,
        0x58abacfa,
        0x03934be3,
        0xfa552030,
        0x6df6ad76,
        0x769188cc,
        0x4c25f502,
        0xd7fc4fe5,
        0xcbd7c52a,
        0x44802635,
        0xa38fb562,
        0x5a49deb1,
        0x1b6725ba,
        0x0e9845ea,
        0xc0e15dfe,
        0x7502c32f,
        0xf012814c,
        0x97a38d46,
        0xf9c66bd3,
        0x5fe7038f,
        0x9c951592,
        0x7aebbf6d,
        0x59da9552,
        0x832dd4be,
        0x21d35874,
        0x692949e0,
        0xc8448ec9,
        0x896a75c2,
        0x7978f48e,
        0x3e6b9958,
        0x71dd27b9,
        0x4fb6bee1,
        0xad17f088,
        0xac66c920,
        0x3ab47dce,
        0x4a1863df,
        0x3182e51a,
        0x33609751,
        0x7f456253,
        0x77e0b164,
        0xae84bb6b,
        0xa01cfe81,
        0x2b94f908,
        0x68587048,
        0xfd198f45,
        0x6c8794de,
        0xf8b7527b,
        0xd323ab73,
        0x02e2724b,
        0x8f57e31f,
        0xab2a6655,
        0x2807b2eb,
        0xc2032fb5,
        0x7b9a86c5,
        0x08a5d337,
        0x87f23028,
        0xa5b223bf,
        0x6aba0203,
        0x825ced16,
        0x1c2b8acf,
        0xb492a779,
        0xf2f0f307,
        0xe2a14e69,
        0xf4cd65da,
        0xbed50605,
        0x621fd134,
        0xfe8ac4a6,
        0x539d342e,
        0x55a0a2f3,
        0xe132058a,
        0xeb75a4f6,
        0xec390b83,
        0xefaa4060,
        0x9f065e71,
        0x1051bd6e,
        0x8af93e21,
        0x063d96dd,
        0x05aedd3e,
        0xbd464de6,
        0x8db59154,
        0x5d0571c4,
        0xd46f0406,
        0x15ff6050,
        0xfb241998,
        0xe997d6bd,
        0x43cc8940,
        0x9e7767d9,
        0x42bdb0e8,
        0x8b880789,
        0x5b38e719,
        0xeedb79c8,
        0x0a47a17c,
        0x0fe97c42,
        0x1ec9f884,
        0x00000000,
        0x86830980,
        0xed48322b,
        0x70ac1e11,
        0x724e6c5a,
        0xfffbfd0e,
        0x38560f85,
        0xd51e3dae,
        0x3927362d,
        0xd9640a0f,
        0xa621685c,
        0x54d19b5b,
        0x2e3a2436,
        0x67b10c0a,
        0xe70f9357,
        0x96d2b4ee,
        0x919e1b9b,
        0xc54f80c0,
        0x20a261dc,
        0x4b695a77,
        0x1a161c12,
        0xba0ae293,
        0x2ae5c0a0,
        0xe0433c22,
        0x171d121b,
        0x0d0b0e09,
        0xc7adf28b,
        0xa8b92db6,
        0xa9c8141e,
        0x198557f1,
        0x074caf75,
        0xddbbee99,
        0x60fda37f,
        0x269ff701,
        0xf5bc5c72,
        0x3bc54466,
        0x7e345bfb,
        0x29768b43,
        0xc6dccb23,
        0xfc68b6ed,
        0xf163b8e4,
        0xdccad731,
        0x85104263,
        0x22401397,
        0x112084c6,
        0x247d854a,
        0x3df8d2bb,
        0x3211aef9,
        0xa16dc729,
        0x2f4b1d9e,
        0x30f3dcb2,
        0x52ec0d86,
        0xe3d077c1,
        0x166c2bb3,
        0xb999a970,
        0x48fa1194,
        0x642247e9,
        0x8cc4a8fc,
        0x3f1aa0f0,
        0x2cd8567d,
        0x90ef2233,
        0x4ec78749,
        0xd1c1d938,
        0xa2fe8cca,
        0x0b3698d4,
        0x81cfa6f5,
        0xde28a57a,
        0x8e26dab7,
        0xbfa43fad,
        0x9de42c3a,
        0x920d5078,
        0xcc9b6a5f,
        0x4662547e,
        0x13c2f68d,
        0xb8e890d8,
        0xf75e2e39,
        0xaff582c3,
        0x80be9f5d,
        0x937c69d0,
        0x2da96fd5,
        0x12b3cf25,
        0x993bc8ac,
        0x7da71018,
        0x636ee89c,
        0xbb7bdb3b,
        0x7809cd26,
        0x18f46e59,
        0xb701ec9a,
        0x9aa8834f,
        0x6e65e695,
        0xe67eaaff,
        0xcf0821bc,
        0xe8e6ef15,
        0x9bd9bae7,
        0x36ce4a6f,
        0x09d4ea9f,
        0x7cd629b0,
        0xb2af31a4,
        0x23312a3f,
        0x9430c6a5,
        0x66c035a2,
        0xbc37744e,
        0xcaa6fc82,
        0xd0b0e090,
        0xd81533a7,
        0x984af104,
        0xdaf741ec,
        0x500e7fcd,
        0xf62f1791,
        0xd68d764d,
        0xb04d43ef,
        0x4d54ccaa,
        0x04dfe496,
        0xb5e39ed1,
        0x881b4c6a,
        0x1fb8c12c,
        0x517f4665,
        0xea049d5e,
        0x355d018c,
        0x7473fa87,
        0x412efb0b,
        0x1d5ab367,
        0xd25292db,
        0x5633e910,
        0x47136dd6,
        0x618c9ad7,
        0x0c7a37a1,
        0x148e59f8,
        0x3c89eb13,
        0x27eecea9,
        0xc935b761,
        0xe5ede11c,
        0xb13c7a47,
        0xdf599cd2,
        0x733f55f2,
        0xce791814,
        0x37bf73c7,
        0xcdea53f7,
        0xaa5b5ffd,
        0x6f14df3d,
        0xdb867844,
        0xf381caaf,
        0xc43eb968,
        0x342c3824,
        0x405fc2a3,
        0xc372161d,
        0x250cbce2,
        0x498b283c,
        0x9541ff0d,
        0x017139a8,
        0xb3de080c,
        0xe49cd8b4,
        0xc1906456,
        0x84617bcb,
        0xb670d532,
        0x5c74486c,
        0x5742d0b8
    ];
    var T8 = [
        0xf4a75051,
        0x4165537e,
        0x17a4c31a,
        0x275e963a,
        0xab6bcb3b,
        0x9d45f11f,
        0xfa58abac,
        0xe303934b,
        0x30fa5520,
        0x766df6ad,
        0xcc769188,
        0x024c25f5,
        0xe5d7fc4f,
        0x2acbd7c5,
        0x35448026,
        0x62a38fb5,
        0xb15a49de,
        0xba1b6725,
        0xea0e9845,
        0xfec0e15d,
        0x2f7502c3,
        0x4cf01281,
        0x4697a38d,
        0xd3f9c66b,
        0x8f5fe703,
        0x929c9515,
        0x6d7aebbf,
        0x5259da95,
        0xbe832dd4,
        0x7421d358,
        0xe0692949,
        0xc9c8448e,
        0xc2896a75,
        0x8e7978f4,
        0x583e6b99,
        0xb971dd27,
        0xe14fb6be,
        0x88ad17f0,
        0x20ac66c9,
        0xce3ab47d,
        0xdf4a1863,
        0x1a3182e5,
        0x51336097,
        0x537f4562,
        0x6477e0b1,
        0x6bae84bb,
        0x81a01cfe,
        0x082b94f9,
        0x48685870,
        0x45fd198f,
        0xde6c8794,
        0x7bf8b752,
        0x73d323ab,
        0x4b02e272,
        0x1f8f57e3,
        0x55ab2a66,
        0xeb2807b2,
        0xb5c2032f,
        0xc57b9a86,
        0x3708a5d3,
        0x2887f230,
        0xbfa5b223,
        0x036aba02,
        0x16825ced,
        0xcf1c2b8a,
        0x79b492a7,
        0x07f2f0f3,
        0x69e2a14e,
        0xdaf4cd65,
        0x05bed506,
        0x34621fd1,
        0xa6fe8ac4,
        0x2e539d34,
        0xf355a0a2,
        0x8ae13205,
        0xf6eb75a4,
        0x83ec390b,
        0x60efaa40,
        0x719f065e,
        0x6e1051bd,
        0x218af93e,
        0xdd063d96,
        0x3e05aedd,
        0xe6bd464d,
        0x548db591,
        0xc45d0571,
        0x06d46f04,
        0x5015ff60,
        0x98fb2419,
        0xbde997d6,
        0x4043cc89,
        0xd99e7767,
        0xe842bdb0,
        0x898b8807,
        0x195b38e7,
        0xc8eedb79,
        0x7c0a47a1,
        0x420fe97c,
        0x841ec9f8,
        0x00000000,
        0x80868309,
        0x2bed4832,
        0x1170ac1e,
        0x5a724e6c,
        0x0efffbfd,
        0x8538560f,
        0xaed51e3d,
        0x2d392736,
        0x0fd9640a,
        0x5ca62168,
        0x5b54d19b,
        0x362e3a24,
        0x0a67b10c,
        0x57e70f93,
        0xee96d2b4,
        0x9b919e1b,
        0xc0c54f80,
        0xdc20a261,
        0x774b695a,
        0x121a161c,
        0x93ba0ae2,
        0xa02ae5c0,
        0x22e0433c,
        0x1b171d12,
        0x090d0b0e,
        0x8bc7adf2,
        0xb6a8b92d,
        0x1ea9c814,
        0xf1198557,
        0x75074caf,
        0x99ddbbee,
        0x7f60fda3,
        0x01269ff7,
        0x72f5bc5c,
        0x663bc544,
        0xfb7e345b,
        0x4329768b,
        0x23c6dccb,
        0xedfc68b6,
        0xe4f163b8,
        0x31dccad7,
        0x63851042,
        0x97224013,
        0xc6112084,
        0x4a247d85,
        0xbb3df8d2,
        0xf93211ae,
        0x29a16dc7,
        0x9e2f4b1d,
        0xb230f3dc,
        0x8652ec0d,
        0xc1e3d077,
        0xb3166c2b,
        0x70b999a9,
        0x9448fa11,
        0xe9642247,
        0xfc8cc4a8,
        0xf03f1aa0,
        0x7d2cd856,
        0x3390ef22,
        0x494ec787,
        0x38d1c1d9,
        0xcaa2fe8c,
        0xd40b3698,
        0xf581cfa6,
        0x7ade28a5,
        0xb78e26da,
        0xadbfa43f,
        0x3a9de42c,
        0x78920d50,
        0x5fcc9b6a,
        0x7e466254,
        0x8d13c2f6,
        0xd8b8e890,
        0x39f75e2e,
        0xc3aff582,
        0x5d80be9f,
        0xd0937c69,
        0xd52da96f,
        0x2512b3cf,
        0xac993bc8,
        0x187da710,
        0x9c636ee8,
        0x3bbb7bdb,
        0x267809cd,
        0x5918f46e,
        0x9ab701ec,
        0x4f9aa883,
        0x956e65e6,
        0xffe67eaa,
        0xbccf0821,
        0x15e8e6ef,
        0xe79bd9ba,
        0x6f36ce4a,
        0x9f09d4ea,
        0xb07cd629,
        0xa4b2af31,
        0x3f23312a,
        0xa59430c6,
        0xa266c035,
        0x4ebc3774,
        0x82caa6fc,
        0x90d0b0e0,
        0xa7d81533,
        0x04984af1,
        0xecdaf741,
        0xcd500e7f,
        0x91f62f17,
        0x4dd68d76,
        0xefb04d43,
        0xaa4d54cc,
        0x9604dfe4,
        0xd1b5e39e,
        0x6a881b4c,
        0x2c1fb8c1,
        0x65517f46,
        0x5eea049d,
        0x8c355d01,
        0x877473fa,
        0x0b412efb,
        0x671d5ab3,
        0xdbd25292,
        0x105633e9,
        0xd647136d,
        0xd7618c9a,
        0xa10c7a37,
        0xf8148e59,
        0x133c89eb,
        0xa927eece,
        0x61c935b7,
        0x1ce5ede1,
        0x47b13c7a,
        0xd2df599c,
        0xf2733f55,
        0x14ce7918,
        0xc737bf73,
        0xf7cdea53,
        0xfdaa5b5f,
        0x3d6f14df,
        0x44db8678,
        0xaff381ca,
        0x68c43eb9,
        0x24342c38,
        0xa3405fc2,
        0x1dc37216,
        0xe2250cbc,
        0x3c498b28,
        0x0d9541ff,
        0xa8017139,
        0x0cb3de08,
        0xb4e49cd8,
        0x56c19064,
        0xcb84617b,
        0x32b670d5,
        0x6c5c7448,
        0xb85742d0
    ];
    // Transformations for decryption key expansion
    var U1 = [
        0x00000000,
        0x0e090d0b,
        0x1c121a16,
        0x121b171d,
        0x3824342c,
        0x362d3927,
        0x24362e3a,
        0x2a3f2331,
        0x70486858,
        0x7e416553,
        0x6c5a724e,
        0x62537f45,
        0x486c5c74,
        0x4665517f,
        0x547e4662,
        0x5a774b69,
        0xe090d0b0,
        0xee99ddbb,
        0xfc82caa6,
        0xf28bc7ad,
        0xd8b4e49c,
        0xd6bde997,
        0xc4a6fe8a,
        0xcaaff381,
        0x90d8b8e8,
        0x9ed1b5e3,
        0x8ccaa2fe,
        0x82c3aff5,
        0xa8fc8cc4,
        0xa6f581cf,
        0xb4ee96d2,
        0xbae79bd9,
        0xdb3bbb7b,
        0xd532b670,
        0xc729a16d,
        0xc920ac66,
        0xe31f8f57,
        0xed16825c,
        0xff0d9541,
        0xf104984a,
        0xab73d323,
        0xa57ade28,
        0xb761c935,
        0xb968c43e,
        0x9357e70f,
        0x9d5eea04,
        0x8f45fd19,
        0x814cf012,
        0x3bab6bcb,
        0x35a266c0,
        0x27b971dd,
        0x29b07cd6,
        0x038f5fe7,
        0x0d8652ec,
        0x1f9d45f1,
        0x119448fa,
        0x4be30393,
        0x45ea0e98,
        0x57f11985,
        0x59f8148e,
        0x73c737bf,
        0x7dce3ab4,
        0x6fd52da9,
        0x61dc20a2,
        0xad766df6,
        0xa37f60fd,
        0xb16477e0,
        0xbf6d7aeb,
        0x955259da,
        0x9b5b54d1,
        0x894043cc,
        0x87494ec7,
        0xdd3e05ae,
        0xd33708a5,
        0xc12c1fb8,
        0xcf2512b3,
        0xe51a3182,
        0xeb133c89,
        0xf9082b94,
        0xf701269f,
        0x4de6bd46,
        0x43efb04d,
        0x51f4a750,
        0x5ffdaa5b,
        0x75c2896a,
        0x7bcb8461,
        0x69d0937c,
        0x67d99e77,
        0x3daed51e,
        0x33a7d815,
        0x21bccf08,
        0x2fb5c203,
        0x058ae132,
        0x0b83ec39,
        0x1998fb24,
        0x1791f62f,
        0x764dd68d,
        0x7844db86,
        0x6a5fcc9b,
        0x6456c190,
        0x4e69e2a1,
        0x4060efaa,
        0x527bf8b7,
        0x5c72f5bc,
        0x0605bed5,
        0x080cb3de,
        0x1a17a4c3,
        0x141ea9c8,
        0x3e218af9,
        0x302887f2,
        0x223390ef,
        0x2c3a9de4,
        0x96dd063d,
        0x98d40b36,
        0x8acf1c2b,
        0x84c61120,
        0xaef93211,
        0xa0f03f1a,
        0xb2eb2807,
        0xbce2250c,
        0xe6956e65,
        0xe89c636e,
        0xfa877473,
        0xf48e7978,
        0xdeb15a49,
        0xd0b85742,
        0xc2a3405f,
        0xccaa4d54,
        0x41ecdaf7,
        0x4fe5d7fc,
        0x5dfec0e1,
        0x53f7cdea,
        0x79c8eedb,
        0x77c1e3d0,
        0x65daf4cd,
        0x6bd3f9c6,
        0x31a4b2af,
        0x3fadbfa4,
        0x2db6a8b9,
        0x23bfa5b2,
        0x09808683,
        0x07898b88,
        0x15929c95,
        0x1b9b919e,
        0xa17c0a47,
        0xaf75074c,
        0xbd6e1051,
        0xb3671d5a,
        0x99583e6b,
        0x97513360,
        0x854a247d,
        0x8b432976,
        0xd134621f,
        0xdf3d6f14,
        0xcd267809,
        0xc32f7502,
        0xe9105633,
        0xe7195b38,
        0xf5024c25,
        0xfb0b412e,
        0x9ad7618c,
        0x94de6c87,
        0x86c57b9a,
        0x88cc7691,
        0xa2f355a0,
        0xacfa58ab,
        0xbee14fb6,
        0xb0e842bd,
        0xea9f09d4,
        0xe49604df,
        0xf68d13c2,
        0xf8841ec9,
        0xd2bb3df8,
        0xdcb230f3,
        0xcea927ee,
        0xc0a02ae5,
        0x7a47b13c,
        0x744ebc37,
        0x6655ab2a,
        0x685ca621,
        0x42638510,
        0x4c6a881b,
        0x5e719f06,
        0x5078920d,
        0x0a0fd964,
        0x0406d46f,
        0x161dc372,
        0x1814ce79,
        0x322bed48,
        0x3c22e043,
        0x2e39f75e,
        0x2030fa55,
        0xec9ab701,
        0xe293ba0a,
        0xf088ad17,
        0xfe81a01c,
        0xd4be832d,
        0xdab78e26,
        0xc8ac993b,
        0xc6a59430,
        0x9cd2df59,
        0x92dbd252,
        0x80c0c54f,
        0x8ec9c844,
        0xa4f6eb75,
        0xaaffe67e,
        0xb8e4f163,
        0xb6edfc68,
        0x0c0a67b1,
        0x02036aba,
        0x10187da7,
        0x1e1170ac,
        0x342e539d,
        0x3a275e96,
        0x283c498b,
        0x26354480,
        0x7c420fe9,
        0x724b02e2,
        0x605015ff,
        0x6e5918f4,
        0x44663bc5,
        0x4a6f36ce,
        0x587421d3,
        0x567d2cd8,
        0x37a10c7a,
        0x39a80171,
        0x2bb3166c,
        0x25ba1b67,
        0x0f853856,
        0x018c355d,
        0x13972240,
        0x1d9e2f4b,
        0x47e96422,
        0x49e06929,
        0x5bfb7e34,
        0x55f2733f,
        0x7fcd500e,
        0x71c45d05,
        0x63df4a18,
        0x6dd64713,
        0xd731dcca,
        0xd938d1c1,
        0xcb23c6dc,
        0xc52acbd7,
        0xef15e8e6,
        0xe11ce5ed,
        0xf307f2f0,
        0xfd0efffb,
        0xa779b492,
        0xa970b999,
        0xbb6bae84,
        0xb562a38f,
        0x9f5d80be,
        0x91548db5,
        0x834f9aa8,
        0x8d4697a3
    ];
    var U2 = [
        0x00000000,
        0x0b0e090d,
        0x161c121a,
        0x1d121b17,
        0x2c382434,
        0x27362d39,
        0x3a24362e,
        0x312a3f23,
        0x58704868,
        0x537e4165,
        0x4e6c5a72,
        0x4562537f,
        0x74486c5c,
        0x7f466551,
        0x62547e46,
        0x695a774b,
        0xb0e090d0,
        0xbbee99dd,
        0xa6fc82ca,
        0xadf28bc7,
        0x9cd8b4e4,
        0x97d6bde9,
        0x8ac4a6fe,
        0x81caaff3,
        0xe890d8b8,
        0xe39ed1b5,
        0xfe8ccaa2,
        0xf582c3af,
        0xc4a8fc8c,
        0xcfa6f581,
        0xd2b4ee96,
        0xd9bae79b,
        0x7bdb3bbb,
        0x70d532b6,
        0x6dc729a1,
        0x66c920ac,
        0x57e31f8f,
        0x5ced1682,
        0x41ff0d95,
        0x4af10498,
        0x23ab73d3,
        0x28a57ade,
        0x35b761c9,
        0x3eb968c4,
        0x0f9357e7,
        0x049d5eea,
        0x198f45fd,
        0x12814cf0,
        0xcb3bab6b,
        0xc035a266,
        0xdd27b971,
        0xd629b07c,
        0xe7038f5f,
        0xec0d8652,
        0xf11f9d45,
        0xfa119448,
        0x934be303,
        0x9845ea0e,
        0x8557f119,
        0x8e59f814,
        0xbf73c737,
        0xb47dce3a,
        0xa96fd52d,
        0xa261dc20,
        0xf6ad766d,
        0xfda37f60,
        0xe0b16477,
        0xebbf6d7a,
        0xda955259,
        0xd19b5b54,
        0xcc894043,
        0xc787494e,
        0xaedd3e05,
        0xa5d33708,
        0xb8c12c1f,
        0xb3cf2512,
        0x82e51a31,
        0x89eb133c,
        0x94f9082b,
        0x9ff70126,
        0x464de6bd,
        0x4d43efb0,
        0x5051f4a7,
        0x5b5ffdaa,
        0x6a75c289,
        0x617bcb84,
        0x7c69d093,
        0x7767d99e,
        0x1e3daed5,
        0x1533a7d8,
        0x0821bccf,
        0x032fb5c2,
        0x32058ae1,
        0x390b83ec,
        0x241998fb,
        0x2f1791f6,
        0x8d764dd6,
        0x867844db,
        0x9b6a5fcc,
        0x906456c1,
        0xa14e69e2,
        0xaa4060ef,
        0xb7527bf8,
        0xbc5c72f5,
        0xd50605be,
        0xde080cb3,
        0xc31a17a4,
        0xc8141ea9,
        0xf93e218a,
        0xf2302887,
        0xef223390,
        0xe42c3a9d,
        0x3d96dd06,
        0x3698d40b,
        0x2b8acf1c,
        0x2084c611,
        0x11aef932,
        0x1aa0f03f,
        0x07b2eb28,
        0x0cbce225,
        0x65e6956e,
        0x6ee89c63,
        0x73fa8774,
        0x78f48e79,
        0x49deb15a,
        0x42d0b857,
        0x5fc2a340,
        0x54ccaa4d,
        0xf741ecda,
        0xfc4fe5d7,
        0xe15dfec0,
        0xea53f7cd,
        0xdb79c8ee,
        0xd077c1e3,
        0xcd65daf4,
        0xc66bd3f9,
        0xaf31a4b2,
        0xa43fadbf,
        0xb92db6a8,
        0xb223bfa5,
        0x83098086,
        0x8807898b,
        0x9515929c,
        0x9e1b9b91,
        0x47a17c0a,
        0x4caf7507,
        0x51bd6e10,
        0x5ab3671d,
        0x6b99583e,
        0x60975133,
        0x7d854a24,
        0x768b4329,
        0x1fd13462,
        0x14df3d6f,
        0x09cd2678,
        0x02c32f75,
        0x33e91056,
        0x38e7195b,
        0x25f5024c,
        0x2efb0b41,
        0x8c9ad761,
        0x8794de6c,
        0x9a86c57b,
        0x9188cc76,
        0xa0a2f355,
        0xabacfa58,
        0xb6bee14f,
        0xbdb0e842,
        0xd4ea9f09,
        0xdfe49604,
        0xc2f68d13,
        0xc9f8841e,
        0xf8d2bb3d,
        0xf3dcb230,
        0xeecea927,
        0xe5c0a02a,
        0x3c7a47b1,
        0x37744ebc,
        0x2a6655ab,
        0x21685ca6,
        0x10426385,
        0x1b4c6a88,
        0x065e719f,
        0x0d507892,
        0x640a0fd9,
        0x6f0406d4,
        0x72161dc3,
        0x791814ce,
        0x48322bed,
        0x433c22e0,
        0x5e2e39f7,
        0x552030fa,
        0x01ec9ab7,
        0x0ae293ba,
        0x17f088ad,
        0x1cfe81a0,
        0x2dd4be83,
        0x26dab78e,
        0x3bc8ac99,
        0x30c6a594,
        0x599cd2df,
        0x5292dbd2,
        0x4f80c0c5,
        0x448ec9c8,
        0x75a4f6eb,
        0x7eaaffe6,
        0x63b8e4f1,
        0x68b6edfc,
        0xb10c0a67,
        0xba02036a,
        0xa710187d,
        0xac1e1170,
        0x9d342e53,
        0x963a275e,
        0x8b283c49,
        0x80263544,
        0xe97c420f,
        0xe2724b02,
        0xff605015,
        0xf46e5918,
        0xc544663b,
        0xce4a6f36,
        0xd3587421,
        0xd8567d2c,
        0x7a37a10c,
        0x7139a801,
        0x6c2bb316,
        0x6725ba1b,
        0x560f8538,
        0x5d018c35,
        0x40139722,
        0x4b1d9e2f,
        0x2247e964,
        0x2949e069,
        0x345bfb7e,
        0x3f55f273,
        0x0e7fcd50,
        0x0571c45d,
        0x1863df4a,
        0x136dd647,
        0xcad731dc,
        0xc1d938d1,
        0xdccb23c6,
        0xd7c52acb,
        0xe6ef15e8,
        0xede11ce5,
        0xf0f307f2,
        0xfbfd0eff,
        0x92a779b4,
        0x99a970b9,
        0x84bb6bae,
        0x8fb562a3,
        0xbe9f5d80,
        0xb591548d,
        0xa8834f9a,
        0xa38d4697
    ];
    var U3 = [
        0x00000000,
        0x0d0b0e09,
        0x1a161c12,
        0x171d121b,
        0x342c3824,
        0x3927362d,
        0x2e3a2436,
        0x23312a3f,
        0x68587048,
        0x65537e41,
        0x724e6c5a,
        0x7f456253,
        0x5c74486c,
        0x517f4665,
        0x4662547e,
        0x4b695a77,
        0xd0b0e090,
        0xddbbee99,
        0xcaa6fc82,
        0xc7adf28b,
        0xe49cd8b4,
        0xe997d6bd,
        0xfe8ac4a6,
        0xf381caaf,
        0xb8e890d8,
        0xb5e39ed1,
        0xa2fe8cca,
        0xaff582c3,
        0x8cc4a8fc,
        0x81cfa6f5,
        0x96d2b4ee,
        0x9bd9bae7,
        0xbb7bdb3b,
        0xb670d532,
        0xa16dc729,
        0xac66c920,
        0x8f57e31f,
        0x825ced16,
        0x9541ff0d,
        0x984af104,
        0xd323ab73,
        0xde28a57a,
        0xc935b761,
        0xc43eb968,
        0xe70f9357,
        0xea049d5e,
        0xfd198f45,
        0xf012814c,
        0x6bcb3bab,
        0x66c035a2,
        0x71dd27b9,
        0x7cd629b0,
        0x5fe7038f,
        0x52ec0d86,
        0x45f11f9d,
        0x48fa1194,
        0x03934be3,
        0x0e9845ea,
        0x198557f1,
        0x148e59f8,
        0x37bf73c7,
        0x3ab47dce,
        0x2da96fd5,
        0x20a261dc,
        0x6df6ad76,
        0x60fda37f,
        0x77e0b164,
        0x7aebbf6d,
        0x59da9552,
        0x54d19b5b,
        0x43cc8940,
        0x4ec78749,
        0x05aedd3e,
        0x08a5d337,
        0x1fb8c12c,
        0x12b3cf25,
        0x3182e51a,
        0x3c89eb13,
        0x2b94f908,
        0x269ff701,
        0xbd464de6,
        0xb04d43ef,
        0xa75051f4,
        0xaa5b5ffd,
        0x896a75c2,
        0x84617bcb,
        0x937c69d0,
        0x9e7767d9,
        0xd51e3dae,
        0xd81533a7,
        0xcf0821bc,
        0xc2032fb5,
        0xe132058a,
        0xec390b83,
        0xfb241998,
        0xf62f1791,
        0xd68d764d,
        0xdb867844,
        0xcc9b6a5f,
        0xc1906456,
        0xe2a14e69,
        0xefaa4060,
        0xf8b7527b,
        0xf5bc5c72,
        0xbed50605,
        0xb3de080c,
        0xa4c31a17,
        0xa9c8141e,
        0x8af93e21,
        0x87f23028,
        0x90ef2233,
        0x9de42c3a,
        0x063d96dd,
        0x0b3698d4,
        0x1c2b8acf,
        0x112084c6,
        0x3211aef9,
        0x3f1aa0f0,
        0x2807b2eb,
        0x250cbce2,
        0x6e65e695,
        0x636ee89c,
        0x7473fa87,
        0x7978f48e,
        0x5a49deb1,
        0x5742d0b8,
        0x405fc2a3,
        0x4d54ccaa,
        0xdaf741ec,
        0xd7fc4fe5,
        0xc0e15dfe,
        0xcdea53f7,
        0xeedb79c8,
        0xe3d077c1,
        0xf4cd65da,
        0xf9c66bd3,
        0xb2af31a4,
        0xbfa43fad,
        0xa8b92db6,
        0xa5b223bf,
        0x86830980,
        0x8b880789,
        0x9c951592,
        0x919e1b9b,
        0x0a47a17c,
        0x074caf75,
        0x1051bd6e,
        0x1d5ab367,
        0x3e6b9958,
        0x33609751,
        0x247d854a,
        0x29768b43,
        0x621fd134,
        0x6f14df3d,
        0x7809cd26,
        0x7502c32f,
        0x5633e910,
        0x5b38e719,
        0x4c25f502,
        0x412efb0b,
        0x618c9ad7,
        0x6c8794de,
        0x7b9a86c5,
        0x769188cc,
        0x55a0a2f3,
        0x58abacfa,
        0x4fb6bee1,
        0x42bdb0e8,
        0x09d4ea9f,
        0x04dfe496,
        0x13c2f68d,
        0x1ec9f884,
        0x3df8d2bb,
        0x30f3dcb2,
        0x27eecea9,
        0x2ae5c0a0,
        0xb13c7a47,
        0xbc37744e,
        0xab2a6655,
        0xa621685c,
        0x85104263,
        0x881b4c6a,
        0x9f065e71,
        0x920d5078,
        0xd9640a0f,
        0xd46f0406,
        0xc372161d,
        0xce791814,
        0xed48322b,
        0xe0433c22,
        0xf75e2e39,
        0xfa552030,
        0xb701ec9a,
        0xba0ae293,
        0xad17f088,
        0xa01cfe81,
        0x832dd4be,
        0x8e26dab7,
        0x993bc8ac,
        0x9430c6a5,
        0xdf599cd2,
        0xd25292db,
        0xc54f80c0,
        0xc8448ec9,
        0xeb75a4f6,
        0xe67eaaff,
        0xf163b8e4,
        0xfc68b6ed,
        0x67b10c0a,
        0x6aba0203,
        0x7da71018,
        0x70ac1e11,
        0x539d342e,
        0x5e963a27,
        0x498b283c,
        0x44802635,
        0x0fe97c42,
        0x02e2724b,
        0x15ff6050,
        0x18f46e59,
        0x3bc54466,
        0x36ce4a6f,
        0x21d35874,
        0x2cd8567d,
        0x0c7a37a1,
        0x017139a8,
        0x166c2bb3,
        0x1b6725ba,
        0x38560f85,
        0x355d018c,
        0x22401397,
        0x2f4b1d9e,
        0x642247e9,
        0x692949e0,
        0x7e345bfb,
        0x733f55f2,
        0x500e7fcd,
        0x5d0571c4,
        0x4a1863df,
        0x47136dd6,
        0xdccad731,
        0xd1c1d938,
        0xc6dccb23,
        0xcbd7c52a,
        0xe8e6ef15,
        0xe5ede11c,
        0xf2f0f307,
        0xfffbfd0e,
        0xb492a779,
        0xb999a970,
        0xae84bb6b,
        0xa38fb562,
        0x80be9f5d,
        0x8db59154,
        0x9aa8834f,
        0x97a38d46
    ];
    var U4 = [
        0x00000000,
        0x090d0b0e,
        0x121a161c,
        0x1b171d12,
        0x24342c38,
        0x2d392736,
        0x362e3a24,
        0x3f23312a,
        0x48685870,
        0x4165537e,
        0x5a724e6c,
        0x537f4562,
        0x6c5c7448,
        0x65517f46,
        0x7e466254,
        0x774b695a,
        0x90d0b0e0,
        0x99ddbbee,
        0x82caa6fc,
        0x8bc7adf2,
        0xb4e49cd8,
        0xbde997d6,
        0xa6fe8ac4,
        0xaff381ca,
        0xd8b8e890,
        0xd1b5e39e,
        0xcaa2fe8c,
        0xc3aff582,
        0xfc8cc4a8,
        0xf581cfa6,
        0xee96d2b4,
        0xe79bd9ba,
        0x3bbb7bdb,
        0x32b670d5,
        0x29a16dc7,
        0x20ac66c9,
        0x1f8f57e3,
        0x16825ced,
        0x0d9541ff,
        0x04984af1,
        0x73d323ab,
        0x7ade28a5,
        0x61c935b7,
        0x68c43eb9,
        0x57e70f93,
        0x5eea049d,
        0x45fd198f,
        0x4cf01281,
        0xab6bcb3b,
        0xa266c035,
        0xb971dd27,
        0xb07cd629,
        0x8f5fe703,
        0x8652ec0d,
        0x9d45f11f,
        0x9448fa11,
        0xe303934b,
        0xea0e9845,
        0xf1198557,
        0xf8148e59,
        0xc737bf73,
        0xce3ab47d,
        0xd52da96f,
        0xdc20a261,
        0x766df6ad,
        0x7f60fda3,
        0x6477e0b1,
        0x6d7aebbf,
        0x5259da95,
        0x5b54d19b,
        0x4043cc89,
        0x494ec787,
        0x3e05aedd,
        0x3708a5d3,
        0x2c1fb8c1,
        0x2512b3cf,
        0x1a3182e5,
        0x133c89eb,
        0x082b94f9,
        0x01269ff7,
        0xe6bd464d,
        0xefb04d43,
        0xf4a75051,
        0xfdaa5b5f,
        0xc2896a75,
        0xcb84617b,
        0xd0937c69,
        0xd99e7767,
        0xaed51e3d,
        0xa7d81533,
        0xbccf0821,
        0xb5c2032f,
        0x8ae13205,
        0x83ec390b,
        0x98fb2419,
        0x91f62f17,
        0x4dd68d76,
        0x44db8678,
        0x5fcc9b6a,
        0x56c19064,
        0x69e2a14e,
        0x60efaa40,
        0x7bf8b752,
        0x72f5bc5c,
        0x05bed506,
        0x0cb3de08,
        0x17a4c31a,
        0x1ea9c814,
        0x218af93e,
        0x2887f230,
        0x3390ef22,
        0x3a9de42c,
        0xdd063d96,
        0xd40b3698,
        0xcf1c2b8a,
        0xc6112084,
        0xf93211ae,
        0xf03f1aa0,
        0xeb2807b2,
        0xe2250cbc,
        0x956e65e6,
        0x9c636ee8,
        0x877473fa,
        0x8e7978f4,
        0xb15a49de,
        0xb85742d0,
        0xa3405fc2,
        0xaa4d54cc,
        0xecdaf741,
        0xe5d7fc4f,
        0xfec0e15d,
        0xf7cdea53,
        0xc8eedb79,
        0xc1e3d077,
        0xdaf4cd65,
        0xd3f9c66b,
        0xa4b2af31,
        0xadbfa43f,
        0xb6a8b92d,
        0xbfa5b223,
        0x80868309,
        0x898b8807,
        0x929c9515,
        0x9b919e1b,
        0x7c0a47a1,
        0x75074caf,
        0x6e1051bd,
        0x671d5ab3,
        0x583e6b99,
        0x51336097,
        0x4a247d85,
        0x4329768b,
        0x34621fd1,
        0x3d6f14df,
        0x267809cd,
        0x2f7502c3,
        0x105633e9,
        0x195b38e7,
        0x024c25f5,
        0x0b412efb,
        0xd7618c9a,
        0xde6c8794,
        0xc57b9a86,
        0xcc769188,
        0xf355a0a2,
        0xfa58abac,
        0xe14fb6be,
        0xe842bdb0,
        0x9f09d4ea,
        0x9604dfe4,
        0x8d13c2f6,
        0x841ec9f8,
        0xbb3df8d2,
        0xb230f3dc,
        0xa927eece,
        0xa02ae5c0,
        0x47b13c7a,
        0x4ebc3774,
        0x55ab2a66,
        0x5ca62168,
        0x63851042,
        0x6a881b4c,
        0x719f065e,
        0x78920d50,
        0x0fd9640a,
        0x06d46f04,
        0x1dc37216,
        0x14ce7918,
        0x2bed4832,
        0x22e0433c,
        0x39f75e2e,
        0x30fa5520,
        0x9ab701ec,
        0x93ba0ae2,
        0x88ad17f0,
        0x81a01cfe,
        0xbe832dd4,
        0xb78e26da,
        0xac993bc8,
        0xa59430c6,
        0xd2df599c,
        0xdbd25292,
        0xc0c54f80,
        0xc9c8448e,
        0xf6eb75a4,
        0xffe67eaa,
        0xe4f163b8,
        0xedfc68b6,
        0x0a67b10c,
        0x036aba02,
        0x187da710,
        0x1170ac1e,
        0x2e539d34,
        0x275e963a,
        0x3c498b28,
        0x35448026,
        0x420fe97c,
        0x4b02e272,
        0x5015ff60,
        0x5918f46e,
        0x663bc544,
        0x6f36ce4a,
        0x7421d358,
        0x7d2cd856,
        0xa10c7a37,
        0xa8017139,
        0xb3166c2b,
        0xba1b6725,
        0x8538560f,
        0x8c355d01,
        0x97224013,
        0x9e2f4b1d,
        0xe9642247,
        0xe0692949,
        0xfb7e345b,
        0xf2733f55,
        0xcd500e7f,
        0xc45d0571,
        0xdf4a1863,
        0xd647136d,
        0x31dccad7,
        0x38d1c1d9,
        0x23c6dccb,
        0x2acbd7c5,
        0x15e8e6ef,
        0x1ce5ede1,
        0x07f2f0f3,
        0x0efffbfd,
        0x79b492a7,
        0x70b999a9,
        0x6bae84bb,
        0x62a38fb5,
        0x5d80be9f,
        0x548db591,
        0x4f9aa883,
        0x4697a38d
    ];
    function convertToInt32(bytes) {
        var result = [];
        for(var i = 0; i < bytes.length; i += 4)result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
        return result;
    }
    var AES = function(key) {
        if (!(this instanceof AES)) throw Error("AES must be instanitated with `new`");
        Object.defineProperty(this, "key", {
            value: coerceArray(key, true)
        });
        this._prepare();
    };
    AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        // encryption round keys
        this._Ke = [];
        // decryption round keys
        this._Kd = [];
        for(var i = 0; i <= rounds; i++){
            this._Ke.push([
                0,
                0,
                0,
                0
            ]);
            this._Kd.push([
                0,
                0,
                0,
                0
            ]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        // convert the key into ints
        var tk = convertToInt32(this.key);
        // copy values into round key arrays
        var index;
        for(var i = 0; i < KC; i++){
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
        }
        // key expansion (fips-197 section 5.2)
        var rconpointer = 0;
        var t = KC, tt;
        while(t < roundKeyCount){
            tt = tk[KC - 1];
            tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            // key expansion (for non-256 bit)
            if (KC != 8) for(var i = 1; i < KC; i++)tk[i] ^= tk[i - 1];
            else {
                for(var i = 1; i < KC / 2; i++)tk[i] ^= tk[i - 1];
                tt = tk[KC / 2 - 1];
                tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;
                for(var i = KC / 2 + 1; i < KC; i++)tk[i] ^= tk[i - 1];
            }
            // copy values into round key arrays
            var i = 0, r, c;
            while(i < KC && t < roundKeyCount){
                r = t >> 2;
                c = t % 4;
                this._Ke[r][c] = tk[i];
                this._Kd[rounds - r][c] = tk[i++];
                t++;
            }
        }
        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for(var r = 1; r < rounds; r++)for(var c = 0; c < 4; c++){
            tt = this._Kd[r][c];
            this._Kd[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
        }
    };
    AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) throw new Error("invalid plaintext size (must be 16 bytes)");
        var rounds = this._Ke.length - 1;
        var a = [
            0,
            0,
            0,
            0
        ];
        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for(var i = 0; i < 4; i++)t[i] ^= this._Ke[0][i];
        // apply round transforms
        for(var r = 1; r < rounds; r++){
            for(var i = 0; i < 4; i++)a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ this._Ke[r][i];
            t = a.slice();
        }
        // the last round is special
        var result = createArray(16), tt;
        for(var i = 0; i < 4; i++){
            tt = this._Ke[rounds][i];
            result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
    };
    AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) throw new Error("invalid ciphertext size (must be 16 bytes)");
        var rounds = this._Kd.length - 1;
        var a = [
            0,
            0,
            0,
            0
        ];
        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for(var i = 0; i < 4; i++)t[i] ^= this._Kd[0][i];
        // apply round transforms
        for(var r = 1; r < rounds; r++){
            for(var i = 0; i < 4; i++)a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ this._Kd[r][i];
            t = a.slice();
        }
        // the last round is special
        var result = createArray(16), tt;
        for(var i = 0; i < 4; i++){
            tt = this._Kd[rounds][i];
            result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
    };
    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */ var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) throw Error("AES must be instanitated with `new`");
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for(var i = 0; i < plaintext.length; i += 16){
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
        }
        return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for(var i = 0; i < ciphertext.length; i += 16){
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
        }
        return plaintext;
    };
    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */ var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) throw Error("AES must be instanitated with `new`");
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) iv = createArray(16);
        else if (iv.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)");
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for(var i = 0; i < plaintext.length; i += 16){
            copyArray(plaintext, block, 0, i, i + 16);
            for(var j = 0; j < 16; j++)block[j] ^= this._lastCipherblock[j];
            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
        }
        return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for(var i = 0; i < ciphertext.length; i += 16){
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            for(var j = 0; j < 16; j++)plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }
        return plaintext;
    };
    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */ var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) throw Error("AES must be instanitated with `new`");
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) iv = createArray(16);
        else if (iv.length != 16) throw new Error("invalid initialation vector size (must be 16 size)");
        if (!segmentSize) segmentSize = 1;
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)");
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for(var i = 0; i < encrypted.length; i += this.segmentSize){
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for(var j = 0; j < this.segmentSize; j++)encrypted[i + j] ^= xorSegment[j];
            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for(var i = 0; i < plaintext.length; i += this.segmentSize){
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for(var j = 0; j < this.segmentSize; j++)plaintext[i + j] ^= xorSegment[j];
            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return plaintext;
    };
    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */ var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) throw Error("AES must be instanitated with `new`");
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) iv = createArray(16);
        else if (iv.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)");
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for(var i = 0; i < encrypted.length; i++){
            if (this._lastPrecipherIndex === 16) {
                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                this._lastPrecipherIndex = 0;
            }
            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
    };
    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    /**
     *  Counter object for CTR common mode of operation
     */ var Counter = function(initialValue) {
        if (!(this instanceof Counter)) throw Error("Counter must be instanitated with `new`");
        // We allow 0, but anything false-ish uses the default 1
        if (initialValue !== 0 && !initialValue) initialValue = 1;
        if (typeof initialValue === "number") {
            this._counter = createArray(16);
            this.setValue(initialValue);
        } else this.setBytes(initialValue);
    };
    Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) throw new Error("invalid counter value (must be an integer)");
        for(var index = 15; index >= 0; --index){
            this._counter[index] = value % 256;
            value = value >> 8;
        }
    };
    Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) throw new Error("invalid counter bytes size (must be 16 bytes)");
        this._counter = bytes;
    };
    Counter.prototype.increment = function() {
        for(var i = 15; i >= 0; i--)if (this._counter[i] === 255) this._counter[i] = 0;
        else {
            this._counter[i]++;
            break;
        }
    };
    /**
     *  Mode Of Operation - Counter (CTR)
     */ var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) throw Error("AES must be instanitated with `new`");
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) counter = new Counter(counter);
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for(var i = 0; i < encrypted.length; i++){
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = this._aes.encrypt(this._counter._counter);
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
    };
    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    ///////////////////////
    // Padding
    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for(var i = data.length; i < result.length; i++)result[i] = padder;
        return result;
    }
    function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) throw new Error("PKCS#7 invalid length");
        var padder = data[data.length - 1];
        if (padder > 16) throw new Error("PKCS#7 padding byte out of range");
        var length = data.length - padder;
        for(var i = 0; i < padder; i++){
            if (data[length + i] !== padder) throw new Error("PKCS#7 invalid padding byte");
        }
        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
    }
    ///////////////////////
    // Exporting
    // The block cipher
    var aesjs = {
        AES: AES,
        Counter: Counter,
        ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
        },
        utils: {
            hex: convertHex,
            utf8: convertUtf8
        },
        padding: {
            pkcs7: {
                pad: pkcs7pad,
                strip: pkcs7strip
            }
        },
        _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray
        }
    };
    module.exports = aesjs;
})(this);

},{}],"ijo9y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "json-wallets/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d3wDI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "looseArrayify", ()=>looseArrayify);
parcelHelpers.export(exports, "zpad", ()=>zpad);
parcelHelpers.export(exports, "getPassword", ()=>getPassword);
parcelHelpers.export(exports, "searchPath", ()=>searchPath);
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
parcelHelpers.export(exports, "uuidV4", ()=>uuidV4);
var _bytes = require("@ethersproject/bytes");
var _strings = require("@ethersproject/strings");
"use strict";
function looseArrayify(hexString) {
    if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") hexString = "0x" + hexString;
    return (0, _bytes.arrayify)(hexString);
}
function zpad(value, length) {
    value = String(value);
    while(value.length < length)value = "0" + value;
    return value;
}
function getPassword(password) {
    if (typeof password === "string") return (0, _strings.toUtf8Bytes)(password, (0, _strings.UnicodeNormalizationForm).NFKC);
    return (0, _bytes.arrayify)(password);
}
function searchPath(object, path) {
    let currentChild = object;
    const comps = path.toLowerCase().split("/");
    for(let i = 0; i < comps.length; i++){
        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        for(const key in currentChild)if (key.toLowerCase() === comps[i]) {
            matchingChild = currentChild[key];
            break;
        }
        // Didn't find one. :'(
        if (matchingChild === null) return null;
        // Now check this child...
        currentChild = matchingChild;
    }
    return currentChild;
}
function uuidV4(randomBytes) {
    const bytes = (0, _bytes.arrayify)(randomBytes);
    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = bytes[6] & 0x0f | 0x40;
    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = bytes[8] & 0x3f | 0x80;
    const value = (0, _bytes.hexlify)(bytes);
    return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34)
    ].join("-");
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/strings":"5TGFZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ZcmH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isCrowdsaleWallet", ()=>isCrowdsaleWallet);
parcelHelpers.export(exports, "isKeystoreWallet", ()=>isKeystoreWallet);
//export function isJsonWallet(json: string): boolean {
//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));
//}
parcelHelpers.export(exports, "getJsonWalletAddress", ()=>getJsonWalletAddress);
var _address = require("@ethersproject/address");
"use strict";
function isCrowdsaleWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    } catch (error) {
        return false;
    }
    return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    } catch (error) {
        return false;
    }
    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) return false;
    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff
    return true;
}
function getJsonWalletAddress(json) {
    if (isCrowdsaleWallet(json)) try {
        return (0, _address.getAddress)(JSON.parse(json).ethaddr);
    } catch (error) {
        return null;
    }
    if (isKeystoreWallet(json)) try {
        return (0, _address.getAddress)(JSON.parse(json).address);
    } catch (error) {
        return null;
    }
    return null;
}

},{"@ethersproject/address":"ggdAz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cTqKv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KeystoreAccount", ()=>KeystoreAccount);
parcelHelpers.export(exports, "decryptSync", ()=>decryptSync);
parcelHelpers.export(exports, "decrypt", ()=>decrypt);
parcelHelpers.export(exports, "encrypt", ()=>encrypt);
var _aesJs = require("aes-js");
var _aesJsDefault = parcelHelpers.interopDefault(_aesJs);
var _scryptJs = require("scrypt-js");
var _scryptJsDefault = parcelHelpers.interopDefault(_scryptJs);
var _address = require("@ethersproject/address");
var _bytes = require("@ethersproject/bytes");
var _hdnode = require("@ethersproject/hdnode");
var _keccak256 = require("@ethersproject/keccak256");
var _pbkdf2 = require("@ethersproject/pbkdf2");
var _random = require("@ethersproject/random");
var _properties = require("@ethersproject/properties");
var _transactions = require("@ethersproject/transactions");
var _utils = require("./utils");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
// Exported Types
function hasMnemonic(value) {
    return value != null && value.mnemonic && value.mnemonic.phrase;
}
class KeystoreAccount extends (0, _properties.Description) {
    isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
    }
}
function _decrypt(data, key, ciphertext) {
    const cipher = (0, _utils.searchPath)(data, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
        const iv = (0, _utils.looseArrayify)((0, _utils.searchPath)(data, "crypto/cipherparams/iv"));
        const counter = new (0, _aesJsDefault.default).Counter(iv);
        const aesCtr = new (0, _aesJsDefault.default).ModeOfOperation.ctr(key, counter);
        return (0, _bytes.arrayify)(aesCtr.decrypt(ciphertext));
    }
    return null;
}
function _getAccount(data, key) {
    const ciphertext = (0, _utils.looseArrayify)((0, _utils.searchPath)(data, "crypto/ciphertext"));
    const computedMAC = (0, _bytes.hexlify)((0, _keccak256.keccak256)((0, _bytes.concat)([
        key.slice(16, 32),
        ciphertext
    ]))).substring(2);
    if (computedMAC !== (0, _utils.searchPath)(data, "crypto/mac").toLowerCase()) throw new Error("invalid password");
    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
    if (!privateKey) logger.throwError("unsupported cipher", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        operation: "decrypt"
    });
    const mnemonicKey = key.slice(32, 64);
    const address = (0, _transactions.computeAddress)(privateKey);
    if (data.address) {
        let check = data.address.toLowerCase();
        if (check.substring(0, 2) !== "0x") check = "0x" + check;
        if ((0, _address.getAddress)(check) !== address) throw new Error("address mismatch");
    }
    const account = {
        _isKeystoreAccount: true,
        address: address,
        privateKey: (0, _bytes.hexlify)(privateKey)
    };
    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
    if ((0, _utils.searchPath)(data, "x-ethers/version") === "0.1") {
        const mnemonicCiphertext = (0, _utils.looseArrayify)((0, _utils.searchPath)(data, "x-ethers/mnemonicCiphertext"));
        const mnemonicIv = (0, _utils.looseArrayify)((0, _utils.searchPath)(data, "x-ethers/mnemonicCounter"));
        const mnemonicCounter = new (0, _aesJsDefault.default).Counter(mnemonicIv);
        const mnemonicAesCtr = new (0, _aesJsDefault.default).ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        const path = (0, _utils.searchPath)(data, "x-ethers/path") || (0, _hdnode.defaultPath);
        const locale = (0, _utils.searchPath)(data, "x-ethers/locale") || "en";
        const entropy = (0, _bytes.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
        try {
            const mnemonic = (0, _hdnode.entropyToMnemonic)(entropy, locale);
            const node = (0, _hdnode.HDNode).fromMnemonic(mnemonic, null, locale).derivePath(path);
            if (node.privateKey != account.privateKey) throw new Error("mnemonic mismatch");
            account.mnemonic = node.mnemonic;
        } catch (error) {
            // If we don't have the locale wordlist installed to
            // read this mnemonic, just bail and don't set the
            // mnemonic
            if (error.code !== (0, _logger.Logger).errors.INVALID_ARGUMENT || error.argument !== "wordlist") throw error;
        }
    }
    return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return (0, _bytes.arrayify)((0, _pbkdf2.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = (0, _utils.getPassword)(password);
    const kdf = (0, _utils.searchPath)(data, "crypto/kdf");
    if (kdf && typeof kdf === "string") {
        const throwError = function(name, value) {
            return logger.throwArgumentError("invalid key-derivation function parameters", name, value);
        };
        if (kdf.toLowerCase() === "scrypt") {
            const salt = (0, _utils.looseArrayify)((0, _utils.searchPath)(data, "crypto/kdfparams/salt"));
            const N = parseInt((0, _utils.searchPath)(data, "crypto/kdfparams/n"));
            const r = parseInt((0, _utils.searchPath)(data, "crypto/kdfparams/r"));
            const p = parseInt((0, _utils.searchPath)(data, "crypto/kdfparams/p"));
            // Check for all required parameters
            if (!N || !r || !p) throwError("kdf", kdf);
            // Make sure N is a power of 2
            if ((N & N - 1) !== 0) throwError("N", N);
            const dkLen = parseInt((0, _utils.searchPath)(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) throwError("dklen", dkLen);
            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
        } else if (kdf.toLowerCase() === "pbkdf2") {
            const salt = (0, _utils.looseArrayify)((0, _utils.searchPath)(data, "crypto/kdfparams/salt"));
            let prfFunc = null;
            const prf = (0, _utils.searchPath)(data, "crypto/kdfparams/prf");
            if (prf === "hmac-sha256") prfFunc = "sha256";
            else if (prf === "hmac-sha512") prfFunc = "sha512";
            else throwError("prf", prf);
            const count = parseInt((0, _utils.searchPath)(data, "crypto/kdfparams/c"));
            const dkLen = parseInt((0, _utils.searchPath)(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) throwError("dklen", dkLen);
            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
    }
    return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
    const data = JSON.parse(json);
    const key = _computeKdfKey(data, password, pbkdf2Sync, (0, _scryptJsDefault.default).syncScrypt);
    return _getAccount(data, key);
}
function decrypt(json, password, progressCallback) {
    return __awaiter(this, void 0, void 0, function*() {
        const data = JSON.parse(json);
        const key = yield _computeKdfKey(data, password, pbkdf2, (0, _scryptJsDefault.default).scrypt, progressCallback);
        return _getAccount(data, key);
    });
}
function encrypt(account, password, options, progressCallback) {
    try {
        // Check the address matches the private key
        if ((0, _address.getAddress)(account.address) !== (0, _transactions.computeAddress)(account.privateKey)) throw new Error("address/privateKey mismatch");
        // Check the mnemonic (if any) matches the private key
        if (hasMnemonic(account)) {
            const mnemonic = account.mnemonic;
            const node = (0, _hdnode.HDNode).fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || (0, _hdnode.defaultPath));
            if (node.privateKey != account.privateKey) throw new Error("mnemonic mismatch");
        }
    } catch (e) {
        return Promise.reject(e);
    }
    // The options are optional, so adjust the call as needed
    if (typeof options === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
    }
    if (!options) options = {};
    const privateKey = (0, _bytes.arrayify)(account.privateKey);
    const passwordBytes = (0, _utils.getPassword)(password);
    let entropy = null;
    let path = null;
    let locale = null;
    if (hasMnemonic(account)) {
        const srcMnemonic = account.mnemonic;
        entropy = (0, _bytes.arrayify)((0, _hdnode.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
        path = srcMnemonic.path || (0, _hdnode.defaultPath);
        locale = srcMnemonic.locale || "en";
    }
    let client = options.client;
    if (!client) client = "ethers.js";
    // Check/generate the salt
    let salt = null;
    if (options.salt) salt = (0, _bytes.arrayify)(options.salt);
    else salt = (0, _random.randomBytes)(32);
    // Override initialization vector
    let iv = null;
    if (options.iv) {
        iv = (0, _bytes.arrayify)(options.iv);
        if (iv.length !== 16) throw new Error("invalid iv");
    } else iv = (0, _random.randomBytes)(16);
    // Override the uuid
    let uuidRandom = null;
    if (options.uuid) {
        uuidRandom = (0, _bytes.arrayify)(options.uuid);
        if (uuidRandom.length !== 16) throw new Error("invalid uuid");
    } else uuidRandom = (0, _random.randomBytes)(16);
    // Override the scrypt password-based key derivation function parameters
    let N = 131072, r = 8, p = 1;
    if (options.scrypt) {
        if (options.scrypt.N) N = options.scrypt.N;
        if (options.scrypt.r) r = options.scrypt.r;
        if (options.scrypt.p) p = options.scrypt.p;
    }
    // We take 64 bytes:
    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
    return (0, _scryptJsDefault.default).scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key)=>{
        key = (0, _bytes.arrayify)(key);
        // This will be used to encrypt the wallet (as per Web3 secret storage)
        const derivedKey = key.slice(0, 16);
        const macPrefix = key.slice(16, 32);
        // This will be used to encrypt the mnemonic phrase (if any)
        const mnemonicKey = key.slice(32, 64);
        // Encrypt the private key
        const counter = new (0, _aesJsDefault.default).Counter(iv);
        const aesCtr = new (0, _aesJsDefault.default).ModeOfOperation.ctr(derivedKey, counter);
        const ciphertext = (0, _bytes.arrayify)(aesCtr.encrypt(privateKey));
        // Compute the message authentication code, used to check the password
        const mac = (0, _keccak256.keccak256)((0, _bytes.concat)([
            macPrefix,
            ciphertext
        ]));
        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
        const data = {
            address: account.address.substring(2).toLowerCase(),
            id: (0, _utils.uuidV4)(uuidRandom),
            version: 3,
            crypto: {
                cipher: "aes-128-ctr",
                cipherparams: {
                    iv: (0, _bytes.hexlify)(iv).substring(2)
                },
                ciphertext: (0, _bytes.hexlify)(ciphertext).substring(2),
                kdf: "scrypt",
                kdfparams: {
                    salt: (0, _bytes.hexlify)(salt).substring(2),
                    n: N,
                    dklen: 32,
                    p: p,
                    r: r
                },
                mac: mac.substring(2)
            }
        };
        // If we have a mnemonic, encrypt it into the JSON wallet
        if (entropy) {
            const mnemonicIv = (0, _random.randomBytes)(16);
            const mnemonicCounter = new (0, _aesJsDefault.default).Counter(mnemonicIv);
            const mnemonicAesCtr = new (0, _aesJsDefault.default).ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
            const mnemonicCiphertext = (0, _bytes.arrayify)(mnemonicAesCtr.encrypt(entropy));
            const now = new Date();
            const timestamp = now.getUTCFullYear() + "-" + (0, _utils.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0, _utils.zpad)(now.getUTCDate(), 2) + "T" + (0, _utils.zpad)(now.getUTCHours(), 2) + "-" + (0, _utils.zpad)(now.getUTCMinutes(), 2) + "-" + (0, _utils.zpad)(now.getUTCSeconds(), 2) + ".0Z";
            data["x-ethers"] = {
                client: client,
                gethFilename: "UTC--" + timestamp + "--" + data.address,
                mnemonicCounter: (0, _bytes.hexlify)(mnemonicIv).substring(2),
                mnemonicCiphertext: (0, _bytes.hexlify)(mnemonicCiphertext).substring(2),
                path: path,
                locale: locale,
                version: "0.1"
            };
        }
        return JSON.stringify(data);
    });
}

},{"aes-js":"6m1U5","scrypt-js":"5vTk0","@ethersproject/address":"ggdAz","@ethersproject/bytes":"htrqZ","@ethersproject/hdnode":"8PpMD","@ethersproject/keccak256":"hXDEv","@ethersproject/pbkdf2":"ityKl","@ethersproject/random":"7myQM","@ethersproject/properties":"h3GJb","@ethersproject/transactions":"d1ust","./utils":"d3wDI","@ethersproject/logger":"hLvB2","./_version":"ijo9y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5vTk0":[function(require,module,exports) {
"use strict";
(function(root) {
    const MAX_VALUE = 0x7fffffff;
    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
        const K = new Uint32Array([
            0x428a2f98,
            0x71374491,
            0xb5c0fbcf,
            0xe9b5dba5,
            0x3956c25b,
            0x59f111f1,
            0x923f82a4,
            0xab1c5ed5,
            0xd807aa98,
            0x12835b01,
            0x243185be,
            0x550c7dc3,
            0x72be5d74,
            0x80deb1fe,
            0x9bdc06a7,
            0xc19bf174,
            0xe49b69c1,
            0xefbe4786,
            0x0fc19dc6,
            0x240ca1cc,
            0x2de92c6f,
            0x4a7484aa,
            0x5cb0a9dc,
            0x76f988da,
            0x983e5152,
            0xa831c66d,
            0xb00327c8,
            0xbf597fc7,
            0xc6e00bf3,
            0xd5a79147,
            0x06ca6351,
            0x14292967,
            0x27b70a85,
            0x2e1b2138,
            0x4d2c6dfc,
            0x53380d13,
            0x650a7354,
            0x766a0abb,
            0x81c2c92e,
            0x92722c85,
            0xa2bfe8a1,
            0xa81a664b,
            0xc24b8b70,
            0xc76c51a3,
            0xd192e819,
            0xd6990624,
            0xf40e3585,
            0x106aa070,
            0x19a4c116,
            0x1e376c08,
            0x2748774c,
            0x34b0bcb5,
            0x391c0cb3,
            0x4ed8aa4a,
            0x5b9cca4f,
            0x682e6ff3,
            0x748f82ee,
            0x78a5636f,
            0x84c87814,
            0x8cc70208,
            0x90befffa,
            0xa4506ceb,
            0xbef9a3f7,
            0xc67178f2
        ]);
        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const w = new Uint32Array(64);
        function blocks(p) {
            let off = 0, len = p.length;
            while(len >= 64){
                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;
                for(i = 0; i < 16; i++){
                    j = off + i * 4;
                    w[i] = (p[j] & 0xff) << 24 | (p[j + 1] & 0xff) << 16 | (p[j + 2] & 0xff) << 8 | p[j + 3] & 0xff;
                }
                for(i = 16; i < 64; i++){
                    u = w[i - 2];
                    t1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
                    u = w[i - 15];
                    t2 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
                    w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0) | 0;
                }
                for(i = 0; i < 64; i++){
                    t1 = (((e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
                    t2 = ((a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10)) + (a & b ^ a & c ^ b & c) | 0;
                    h = g;
                    g = f;
                    f = e;
                    e = d + t1 | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = t1 + t2 | 0;
                }
                h0 = h0 + a | 0;
                h1 = h1 + b | 0;
                h2 = h2 + c | 0;
                h3 = h3 + d | 0;
                h4 = h4 + e | 0;
                h5 = h5 + f | 0;
                h6 = h6 + g | 0;
                h7 = h7 + h | 0;
                off += 64;
                len -= 64;
            }
        }
        blocks(m);
        let i, bytesLeft = m.length % 64, bitLenHi = m.length / 0x20000000 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
        p.push(0x80);
        for(i = bytesLeft + 1; i < numZeros; i++)p.push(0);
        p.push(bitLenHi >>> 24 & 0xff);
        p.push(bitLenHi >>> 16 & 0xff);
        p.push(bitLenHi >>> 8 & 0xff);
        p.push(bitLenHi >>> 0 & 0xff);
        p.push(bitLenLo >>> 24 & 0xff);
        p.push(bitLenLo >>> 16 & 0xff);
        p.push(bitLenLo >>> 8 & 0xff);
        p.push(bitLenLo >>> 0 & 0xff);
        blocks(p);
        return [
            h0 >>> 24 & 0xff,
            h0 >>> 16 & 0xff,
            h0 >>> 8 & 0xff,
            h0 >>> 0 & 0xff,
            h1 >>> 24 & 0xff,
            h1 >>> 16 & 0xff,
            h1 >>> 8 & 0xff,
            h1 >>> 0 & 0xff,
            h2 >>> 24 & 0xff,
            h2 >>> 16 & 0xff,
            h2 >>> 8 & 0xff,
            h2 >>> 0 & 0xff,
            h3 >>> 24 & 0xff,
            h3 >>> 16 & 0xff,
            h3 >>> 8 & 0xff,
            h3 >>> 0 & 0xff,
            h4 >>> 24 & 0xff,
            h4 >>> 16 & 0xff,
            h4 >>> 8 & 0xff,
            h4 >>> 0 & 0xff,
            h5 >>> 24 & 0xff,
            h5 >>> 16 & 0xff,
            h5 >>> 8 & 0xff,
            h5 >>> 0 & 0xff,
            h6 >>> 24 & 0xff,
            h6 >>> 16 & 0xff,
            h6 >>> 8 & 0xff,
            h6 >>> 0 & 0xff,
            h7 >>> 24 & 0xff,
            h7 >>> 16 & 0xff,
            h7 >>> 8 & 0xff,
            h7 >>> 0 & 0xff
        ];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        // compress password if it's longer than hash block length
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i;
        let dk = [];
        // inner = (password ^ ipad) || salt || counter
        for(i = 0; i < 64; i++)inner[i] = 0x36;
        for(i = 0; i < password.length; i++)inner[i] ^= password[i];
        for(i = 0; i < salt.length; i++)inner[64 + i] = salt[i];
        for(i = innerLen - 4; i < innerLen; i++)inner[i] = 0;
        // outerKey = password ^ opad
        for(i = 0; i < 64; i++)outerKey[i] = 0x5c;
        for(i = 0; i < password.length; i++)outerKey[i] ^= password[i];
        // increments counter inside inner
        function incrementCounter() {
            for(let i = innerLen - 1; i >= innerLen - 4; i--){
                inner[i]++;
                if (inner[i] <= 0xff) return;
                inner[i] = 0;
            }
        }
        // output blocks = SHA256(outerKey || SHA256(inner)) ...
        while(dkLen >= 32){
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
        }
        if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
    }
    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;
        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for(i = 0; i < 2 * r; i++){
            blockxor(BY, i * 16, _X, 16);
            salsa20_8(_X, x);
            arraycopy(_X, 0, BY, Yi + i * 16, 16);
        }
        for(i = 0; i < r; i++)arraycopy(BY, Yi + i * 32, BY, i * 16, 16);
        for(i = 0; i < r; i++)arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
    }
    function R(a, b) {
        return a << b | a >>> 32 - b;
    }
    function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);
        for(let i = 8; i > 0; i -= 2){
            x[4] ^= R(x[0] + x[12], 7);
            x[8] ^= R(x[4] + x[0], 9);
            x[12] ^= R(x[8] + x[4], 13);
            x[0] ^= R(x[12] + x[8], 18);
            x[9] ^= R(x[5] + x[1], 7);
            x[13] ^= R(x[9] + x[5], 9);
            x[1] ^= R(x[13] + x[9], 13);
            x[5] ^= R(x[1] + x[13], 18);
            x[14] ^= R(x[10] + x[6], 7);
            x[2] ^= R(x[14] + x[10], 9);
            x[6] ^= R(x[2] + x[14], 13);
            x[10] ^= R(x[6] + x[2], 18);
            x[3] ^= R(x[15] + x[11], 7);
            x[7] ^= R(x[3] + x[15], 9);
            x[11] ^= R(x[7] + x[3], 13);
            x[15] ^= R(x[11] + x[7], 18);
            x[1] ^= R(x[0] + x[3], 7);
            x[2] ^= R(x[1] + x[0], 9);
            x[3] ^= R(x[2] + x[1], 13);
            x[0] ^= R(x[3] + x[2], 18);
            x[6] ^= R(x[5] + x[4], 7);
            x[7] ^= R(x[6] + x[5], 9);
            x[4] ^= R(x[7] + x[6], 13);
            x[5] ^= R(x[4] + x[7], 18);
            x[11] ^= R(x[10] + x[9], 7);
            x[8] ^= R(x[11] + x[10], 9);
            x[9] ^= R(x[8] + x[11], 13);
            x[10] ^= R(x[9] + x[8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }
        for(let i = 0; i < 16; ++i)B[i] += x[i];
    }
    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
        for(let i = 0; i < len; i++)D[i] ^= S[Si + i];
    }
    function arraycopy(src, srcPos, dest, destPos, length) {
        while(length--)dest[destPos++] = src[srcPos++];
    }
    function checkBufferish(o) {
        if (!o || typeof o.length !== "number") return false;
        for(let i = 0; i < o.length; i++){
            const v = o[i];
            if (typeof v !== "number" || v % 1 || v < 0 || v >= 256) return false;
        }
        return true;
    }
    function ensureInteger(value, name) {
        if (typeof value !== "number" || value % 1) throw new Error("invalid " + name);
        return value;
    }
    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {
        N = ensureInteger(N, "N");
        r = ensureInteger(r, "r");
        p = ensureInteger(p, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N === 0 || (N & N - 1) !== 0) throw new Error("N must be power of 2");
        if (N > MAX_VALUE / 128 / r) throw new Error("N too large");
        if (r > MAX_VALUE / 128 / p) throw new Error("r too large");
        if (!checkBufferish(password)) throw new Error("password must be an array or buffer");
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) throw new Error("salt must be an array or buffer");
        salt = Array.prototype.slice.call(salt);
        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r);
        for(let i = 0; i < B.length; i++){
            const j = i * 4;
            B[i] = (b[j + 3] & 0xff) << 24 | (b[j + 2] & 0xff) << 16 | (b[j + 1] & 0xff) << 8 | (b[j + 0] & 0xff) << 0;
        }
        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);
        const Yi = 32 * r;
        // scratch space
        const x = new Uint32Array(16); // salsa20_8
        const _X = new Uint32Array(16); // blockmix_salsa8
        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        // Set this to true to abandon the scrypt on the next step
        let stop = false;
        // State information
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        // How many blockmix_salsa8 can we do per step?
        const limit = callback ? parseInt(1000 / r) : 0xffffffff;
        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        // This is really all I changed; making scryptsy a state machine so we occasionally
        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
        const incrementalSMix = function() {
            if (stop) return callback(new Error("cancelled"), currentOp / totalOps);
            let steps;
            switch(state){
                case 0:
                    // for (var i = 0; i < p; i++)...
                    Bi = i0 * 32 * r;
                    arraycopy(B, Bi, XY, 0, Yi); // ROMix - 1
                    state = 1; // Move to ROMix 2
                    i1 = 0;
                // Fall through
                case 1:
                    // Run up to 1000 steps of the first inner smix loop
                    steps = N - i1;
                    if (steps > limit) steps = limit;
                    for(let i = 0; i < steps; i++){
                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi) // ROMix - 3
                        ;
                        blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 4
                    }
                    // for (var i = 0; i < N; i++)
                    i1 += steps;
                    currentOp += steps;
                    if (callback) {
                        // Call the callback with the progress (optionally stopping us)
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) break;
                            lastPercent10 = percent10;
                        }
                    }
                    if (i1 < N) break;
                    i1 = 0; // Move to ROMix 6
                    state = 2;
                // Fall through
                case 2:
                    // Run up to 1000 steps of the second inner smix loop
                    steps = N - i1;
                    if (steps > limit) steps = limit;
                    for(let i = 0; i < steps; i++){
                        const offset = (2 * r - 1) * 16; // ROMix - 7
                        const j = XY[offset] & N - 1;
                        blockxor(V, j * Yi, XY, Yi); // ROMix - 8 (inner)
                        blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 9 (outer)
                    }
                    // for (var i = 0; i < N; i++)...
                    i1 += steps;
                    currentOp += steps;
                    // Call the callback with the progress (optionally stopping us)
                    if (callback) {
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) break;
                            lastPercent10 = percent10;
                        }
                    }
                    if (i1 < N) break;
                    arraycopy(XY, 0, B, Bi, Yi); // ROMix - 10
                    // for (var i = 0; i < p; i++)...
                    i0++;
                    if (i0 < p) {
                        state = 0;
                        break;
                    }
                    b = [];
                    for(let i = 0; i < B.length; i++){
                        b.push(B[i] >> 0 & 0xff);
                        b.push(B[i] >> 8 & 0xff);
                        b.push(B[i] >> 16 & 0xff);
                        b.push(B[i] >> 24 & 0xff);
                    }
                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);
                    // Send the result to the callback
                    if (callback) callback(null, 1.0, derivedKey);
                    // Done; don't break (which would reschedule)
                    return derivedKey;
            }
            // Schedule the next steps
            if (callback) nextTick(incrementalSMix);
        };
        // Run the smix state machine until completion
        if (!callback) while(true){
            const derivedKey = incrementalSMix();
            if (derivedKey != undefined) return derivedKey;
        }
        // Bootstrap the async incremental smix
        incrementalSMix();
    }
    const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
                let lastProgress = 0;
                if (progressCallback) progressCallback(0);
                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
                    if (error) reject(error);
                    else if (key) {
                        if (progressCallback && lastProgress !== 1) progressCallback(1);
                        resolve(new Uint8Array(key));
                    } else if (progressCallback && progress !== lastProgress) {
                        lastProgress = progress;
                        return progressCallback(progress);
                    }
                });
            });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
    };
    // node.js
    if (typeof exports !== "undefined") module.exports = lib;
    else if (typeof define === "function" && define.amd) define(lib);
    else if (root) {
        // If there was an existing library "scrypt", make sure it is still available
        if (root.scrypt) root._scrypt = root.scrypt;
        root.scrypt = lib;
    }
})(this);

},{}],"ej99N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "wallet/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bErvj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
////////////////////////
// Exports
parcelHelpers.export(exports, "Provider", ()=>// Abstract Providers (or Abstract-ish)
    (0, _abstractProvider.Provider));
parcelHelpers.export(exports, "BaseProvider", ()=>(0, _baseProvider.BaseProvider));
parcelHelpers.export(exports, "Resolver", ()=>(0, _baseProvider.Resolver));
parcelHelpers.export(exports, "UrlJsonRpcProvider", ()=>(0, _urlJsonRpcProvider.UrlJsonRpcProvider));
parcelHelpers.export(exports, "FallbackProvider", ()=>///////////////////////
    // Concrete Providers
    (0, _fallbackProvider.FallbackProvider));
parcelHelpers.export(exports, "AlchemyProvider", ()=>(0, _alchemyProvider.AlchemyProvider));
parcelHelpers.export(exports, "AlchemyWebSocketProvider", ()=>(0, _alchemyProvider.AlchemyWebSocketProvider));
parcelHelpers.export(exports, "AnkrProvider", ()=>(0, _ankrProvider.AnkrProvider));
parcelHelpers.export(exports, "CloudflareProvider", ()=>(0, _cloudflareProvider.CloudflareProvider));
parcelHelpers.export(exports, "EtherscanProvider", ()=>(0, _etherscanProvider.EtherscanProvider));
parcelHelpers.export(exports, "InfuraProvider", ()=>(0, _infuraProvider.InfuraProvider));
parcelHelpers.export(exports, "InfuraWebSocketProvider", ()=>(0, _infuraProvider.InfuraWebSocketProvider));
parcelHelpers.export(exports, "JsonRpcProvider", ()=>(0, _jsonRpcProvider.JsonRpcProvider));
parcelHelpers.export(exports, "JsonRpcBatchProvider", ()=>(0, _jsonRpcBatchProvider.JsonRpcBatchProvider));
parcelHelpers.export(exports, "NodesmithProvider", ()=>(0, _nodesmithProvider.NodesmithProvider));
parcelHelpers.export(exports, "PocketProvider", ()=>(0, _pocketProvider.PocketProvider));
parcelHelpers.export(exports, "StaticJsonRpcProvider", ()=>(0, _urlJsonRpcProvider.StaticJsonRpcProvider));
parcelHelpers.export(exports, "Web3Provider", ()=>(0, _web3Provider.Web3Provider));
parcelHelpers.export(exports, "WebSocketProvider", ()=>(0, _websocketProvider.WebSocketProvider));
parcelHelpers.export(exports, "IpcProvider", ()=>(0, _ipcProvider.IpcProvider));
parcelHelpers.export(exports, "JsonRpcSigner", ()=>///////////////////////
    // Signer
    (0, _jsonRpcProvider.JsonRpcSigner));
parcelHelpers.export(exports, "getDefaultProvider", ()=>///////////////////////
    // Functions
    getDefaultProvider);
parcelHelpers.export(exports, "getNetwork", ()=>(0, _networks.getNetwork));
parcelHelpers.export(exports, "isCommunityResource", ()=>(0, _formatter.isCommunityResource));
parcelHelpers.export(exports, "isCommunityResourcable", ()=>(0, _formatter.isCommunityResourcable));
parcelHelpers.export(exports, "showThrottleMessage", ()=>(0, _formatter.showThrottleMessage));
parcelHelpers.export(exports, "Formatter", ()=>///////////////////////
    // Objects
    (0, _formatter.Formatter));
var _abstractProvider = require("@ethersproject/abstract-provider");
var _networks = require("@ethersproject/networks");
var _baseProvider = require("./base-provider");
var _alchemyProvider = require("./alchemy-provider");
var _ankrProvider = require("./ankr-provider");
var _cloudflareProvider = require("./cloudflare-provider");
var _etherscanProvider = require("./etherscan-provider");
var _fallbackProvider = require("./fallback-provider");
var _ipcProvider = require("./ipc-provider");
var _infuraProvider = require("./infura-provider");
var _jsonRpcProvider = require("./json-rpc-provider");
var _jsonRpcBatchProvider = require("./json-rpc-batch-provider");
var _nodesmithProvider = require("./nodesmith-provider");
var _pocketProvider = require("./pocket-provider");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _web3Provider = require("./web3-provider");
var _websocketProvider = require("./websocket-provider");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
////////////////////////
// Helper Functions
function getDefaultProvider(network, options) {
    if (network == null) network = "homestead";
    // If passed a URL, figure out the right type of provider based on the scheme
    if (typeof network === "string") {
        // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?
        // Handle http and ws (and their secure variants)
        const match = network.match(/^(ws|http)s?:/i);
        if (match) switch(match[1].toLowerCase()){
            case "http":
            case "https":
                return new (0, _jsonRpcProvider.JsonRpcProvider)(network);
            case "ws":
            case "wss":
                return new (0, _websocketProvider.WebSocketProvider)(network);
            default:
                logger.throwArgumentError("unsupported URL scheme", "network", network);
        }
    }
    const n = (0, _networks.getNetwork)(network);
    if (!n || !n._defaultProvider) logger.throwError("unsupported getDefaultProvider network", (0, _logger.Logger).errors.NETWORK_ERROR, {
        operation: "getDefaultProvider",
        network: network
    });
    return n._defaultProvider({
        FallbackProvider: (0, _fallbackProvider.FallbackProvider),
        AlchemyProvider: (0, _alchemyProvider.AlchemyProvider),
        AnkrProvider: (0, _ankrProvider.AnkrProvider),
        CloudflareProvider: (0, _cloudflareProvider.CloudflareProvider),
        EtherscanProvider: (0, _etherscanProvider.EtherscanProvider),
        InfuraProvider: (0, _infuraProvider.InfuraProvider),
        JsonRpcProvider: (0, _jsonRpcProvider.JsonRpcProvider),
        NodesmithProvider: (0, _nodesmithProvider.NodesmithProvider),
        PocketProvider: (0, _pocketProvider.PocketProvider),
        Web3Provider: (0, _web3Provider.Web3Provider),
        IpcProvider: (0, _ipcProvider.IpcProvider)
    }, options);
}

},{"@ethersproject/abstract-provider":"g1jr1","@ethersproject/networks":"6JNhW","./base-provider":"7OFAa","./alchemy-provider":"jD4Nf","./ankr-provider":"cKap1","./cloudflare-provider":"9VKg2","./etherscan-provider":"arYKc","./fallback-provider":"2wNFK","./ipc-provider":"6WQjk","./infura-provider":"iqlOM","./json-rpc-provider":"1sWtk","./json-rpc-batch-provider":"hGNo4","./nodesmith-provider":"8l5lW","./pocket-provider":"3a8Ys","./url-json-rpc-provider":"9CTqA","./web3-provider":"cIjQb","./websocket-provider":"9KF9f","./formatter":"ZfOHh","@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6JNhW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */ parcelHelpers.export(exports, "getNetwork", ()=>getNetwork);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function isRenetworkable(value) {
    return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
    const func = function(providers, options) {
        if (options == null) options = {};
        const providerList = [];
        if (providers.InfuraProvider && options.infura !== "-") try {
            providerList.push(new providers.InfuraProvider(network, options.infura));
        } catch (error) {}
        if (providers.EtherscanProvider && options.etherscan !== "-") try {
            providerList.push(new providers.EtherscanProvider(network, options.etherscan));
        } catch (error) {}
        if (providers.AlchemyProvider && options.alchemy !== "-") try {
            providerList.push(new providers.AlchemyProvider(network, options.alchemy));
        } catch (error) {}
        if (providers.PocketProvider && options.pocket !== "-") {
            // These networks are currently faulty on Pocket as their
            // network does not handle the Berlin hardfork, which is
            // live on these ones.
            // @TODO: This goes away once Pocket has upgraded their nodes
            const skip = [
                "goerli",
                "ropsten",
                "rinkeby",
                "sepolia"
            ];
            try {
                const provider = new providers.PocketProvider(network, options.pocket);
                if (provider.network && skip.indexOf(provider.network.name) === -1) providerList.push(provider);
            } catch (error) {}
        }
        if (providers.CloudflareProvider && options.cloudflare !== "-") try {
            providerList.push(new providers.CloudflareProvider(network));
        } catch (error) {}
        if (providers.AnkrProvider && options.ankr !== "-") try {
            const skip = [
                "ropsten"
            ];
            const provider = new providers.AnkrProvider(network, options.ankr);
            if (provider.network && skip.indexOf(provider.network.name) === -1) providerList.push(provider);
        } catch (error) {}
        if (providerList.length === 0) return null;
        if (providers.FallbackProvider) {
            let quorum = 1;
            if (options.quorum != null) quorum = options.quorum;
            else if (network === "homestead") quorum = 2;
            return new providers.FallbackProvider(providerList, quorum);
        }
        return providerList[0];
    };
    func.renetwork = function(network) {
        return ethDefaultProvider(network);
    };
    return func;
}
function etcDefaultProvider(url, network) {
    const func = function(providers, options) {
        if (providers.JsonRpcProvider) return new providers.JsonRpcProvider(url, network);
        return null;
    };
    func.renetwork = function(network) {
        return etcDefaultProvider(url, network);
    };
    return func;
}
const homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
// See: https://chainlist.org
const networks = {
    unspecified: {
        chainId: 0,
        name: "unspecified"
    },
    homestead: homestead,
    mainnet: homestead,
    morden: {
        chainId: 2,
        name: "morden"
    },
    ropsten: ropsten,
    testnet: ropsten,
    rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
    },
    kintsugi: {
        chainId: 1337702,
        name: "kintsugi"
    },
    sepolia: {
        chainId: 11155111,
        name: "sepolia",
        _defaultProvider: ethDefaultProvider("sepolia")
    },
    // ETC (See: #351)
    classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
    },
    classicMorden: {
        chainId: 62,
        name: "classicMorden"
    },
    classicMordor: classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: {
        chainId: 100,
        name: "xdai"
    },
    matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: ethDefaultProvider("matic")
    },
    maticmum: {
        chainId: 80001,
        name: "maticmum"
    },
    optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: ethDefaultProvider("optimism")
    },
    "optimism-kovan": {
        chainId: 69,
        name: "optimism-kovan"
    },
    "optimism-goerli": {
        chainId: 420,
        name: "optimism-goerli"
    },
    arbitrum: {
        chainId: 42161,
        name: "arbitrum"
    },
    "arbitrum-rinkeby": {
        chainId: 421611,
        name: "arbitrum-rinkeby"
    },
    "arbitrum-goerli": {
        chainId: 421613,
        name: "arbitrum-goerli"
    },
    bnb: {
        chainId: 56,
        name: "bnb"
    },
    bnbt: {
        chainId: 97,
        name: "bnbt"
    }
};
function getNetwork(network) {
    // No network (null)
    if (network == null) return null;
    if (typeof network === "number") {
        for(const name in networks){
            const standard = networks[name];
            if (standard.chainId === network) return {
                name: standard.name,
                chainId: standard.chainId,
                ensAddress: standard.ensAddress || null,
                _defaultProvider: standard._defaultProvider || null
            };
        }
        return {
            chainId: network,
            name: "unknown"
        };
    }
    if (typeof network === "string") {
        const standard = networks[network];
        if (standard == null) return null;
        return {
            name: standard.name,
            chainId: standard.chainId,
            ensAddress: standard.ensAddress,
            _defaultProvider: standard._defaultProvider || null
        };
    }
    const standard = networks[network.name];
    // Not a standard network; check that it is a valid network in general
    if (!standard) {
        if (typeof network.chainId !== "number") logger.throwArgumentError("invalid network chainId", "network", network);
        return network;
    }
    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)
    if (network.chainId !== 0 && network.chainId !== standard.chainId) logger.throwArgumentError("network chainId mismatch", "network", network);
    // @TODO: In the next major version add an attach function to a defaultProvider
    // class and move the _defaultProvider internal to this file (extend Network)
    let defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) defaultProvider = standard._defaultProvider.renetwork(network);
        else defaultProvider = standard._defaultProvider;
    }
    // Standard Network (allow overriding the ENS address)
    return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: network.ensAddress || standard.ensAddress || null,
        _defaultProvider: defaultProvider
    };
}

},{"@ethersproject/logger":"hLvB2","./_version":"9eROf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9eROf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "networks/5.7.1";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7OFAa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Event", ()=>Event);
parcelHelpers.export(exports, "Resolver", ()=>Resolver);
parcelHelpers.export(exports, "BaseProvider", ()=>BaseProvider);
var _abstractProvider = require("@ethersproject/abstract-provider");
var _base64 = require("@ethersproject/base64");
var _basex = require("@ethersproject/basex");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _constants = require("@ethersproject/constants");
var _hash = require("@ethersproject/hash");
var _networks = require("@ethersproject/networks");
var _properties = require("@ethersproject/properties");
var _sha2 = require("@ethersproject/sha2");
var _strings = require("@ethersproject/strings");
var _web = require("@ethersproject/web");
var _bech32 = require("bech32");
var _bech32Default = parcelHelpers.interopDefault(_bech32);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _formatter = require("./formatter");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const MAX_CCIP_REDIRECTS = 10;
//////////////////////////////
// Event Serializeing
function checkTopic(topic) {
    if (topic == null) return "null";
    if ((0, _bytes.hexDataLength)(topic) !== 32) logger.throwArgumentError("invalid topic", "topic", topic);
    return topic.toLowerCase();
}
function serializeTopics(topics) {
    // Remove trailing null AND-topics; they are redundant
    topics = topics.slice();
    while(topics.length > 0 && topics[topics.length - 1] == null)topics.pop();
    return topics.map((topic)=>{
        if (Array.isArray(topic)) {
            // Only track unique OR-topics
            const unique = {};
            topic.forEach((topic)=>{
                unique[checkTopic(topic)] = true;
            });
            // The order of OR-topics does not matter
            const sorted = Object.keys(unique);
            sorted.sort();
            return sorted.join("|");
        } else return checkTopic(topic);
    }).join("&");
}
function deserializeTopics(data) {
    if (data === "") return [];
    return data.split(/&/g).map((topic)=>{
        if (topic === "") return [];
        const comps = topic.split("|").map((topic)=>{
            return topic === "null" ? null : topic;
        });
        return comps.length === 1 ? comps[0] : comps;
    });
}
function getEventTag(eventName) {
    if (typeof eventName === "string") {
        eventName = eventName.toLowerCase();
        if ((0, _bytes.hexDataLength)(eventName) === 32) return "tx:" + eventName;
        if (eventName.indexOf(":") === -1) return eventName;
    } else if (Array.isArray(eventName)) return "filter:*:" + serializeTopics(eventName);
    else if ((0, _abstractProvider.ForkEvent).isForkEvent(eventName)) {
        logger.warn("not implemented");
        throw new Error("not implemented");
    } else if (eventName && typeof eventName === "object") return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    throw new Error("invalid event - " + eventName);
}
//////////////////////////////
// Helper Object
function getTime() {
    return new Date().getTime();
}
function stall(duration) {
    return new Promise((resolve)=>{
        setTimeout(resolve, duration);
    });
}
//////////////////////////////
// Provider Object
/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */ const PollableEvents = [
    "block",
    "network",
    "pending",
    "poll"
];
class Event {
    constructor(tag, listener, once){
        (0, _properties.defineReadOnly)(this, "tag", tag);
        (0, _properties.defineReadOnly)(this, "listener", listener);
        (0, _properties.defineReadOnly)(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
    }
    get event() {
        switch(this.type){
            case "tx":
                return this.hash;
            case "filter":
                return this.filter;
        }
        return this.tag;
    }
    get type() {
        return this.tag.split(":")[0];
    }
    get hash() {
        const comps = this.tag.split(":");
        if (comps[0] !== "tx") return null;
        return comps[1];
    }
    get filter() {
        const comps = this.tag.split(":");
        if (comps[0] !== "filter") return null;
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) filter.topics = topics;
        if (address && address !== "*") filter.address = address;
        return filter;
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
    }
}
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
const coinInfos = {
    "0": {
        symbol: "btc",
        p2pkh: 0x00,
        p2sh: 0x05,
        prefix: "bc"
    },
    "2": {
        symbol: "ltc",
        p2pkh: 0x30,
        p2sh: 0x32,
        prefix: "ltc"
    },
    "3": {
        symbol: "doge",
        p2pkh: 0x1e,
        p2sh: 0x16
    },
    "60": {
        symbol: "eth",
        ilk: "eth"
    },
    "61": {
        symbol: "etc",
        ilk: "eth"
    },
    "700": {
        symbol: "xdai",
        ilk: "eth"
    }
};
function bytes32ify(value) {
    return (0, _bytes.hexZeroPad)((0, _bignumber.BigNumber).from(value).toHexString(), 32);
}
// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)
function base58Encode(data) {
    return (0, _basex.Base58).encode((0, _bytes.concat)([
        data,
        (0, _bytes.hexDataSlice)((0, _sha2.sha256)((0, _sha2.sha256)(data)), 0, 4)
    ]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
    try {
        return (0, _strings.toUtf8String)(_parseBytes(result, start));
    } catch (error) {}
    return null;
}
function _parseBytes(result, start) {
    if (result === "0x") return null;
    const offset = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(result, start, start + 32)).toNumber();
    const length = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(result, offset, offset + 32)).toNumber();
    return (0, _bytes.hexDataSlice)(result, offset + 32, offset + 32 + length);
}
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) link = link.substring(12);
    else if (link.match(/^ipfs:\/\//i)) link = link.substring(7);
    else logger.throwArgumentError("unsupported IPFS format", "link", link);
    return `https:/\/gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
    const result = (0, _bytes.arrayify)(value);
    if (result.length > 32) throw new Error("internal; should not happen");
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
}
function bytesPad(value) {
    if (value.length % 32 === 0) return value;
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
}
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    // Add place-holders for pointers as we add items
    for(let i = 0; i < datas.length; i++){
        result.push(null);
        byteCount += 32;
    }
    for(let i = 0; i < datas.length; i++){
        const data = (0, _bytes.arrayify)(datas[i]);
        // Update the bytes offset
        result[i] = numPad(byteCount);
        // The length and padded value of data
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return (0, _bytes.hexConcat)(result);
}
class Resolver {
    // The resolvedAddress is only for creating a ReverseLookup resolver
    constructor(provider, address, name, resolvedAddress){
        (0, _properties.defineReadOnly)(this, "provider", provider);
        (0, _properties.defineReadOnly)(this, "name", name);
        (0, _properties.defineReadOnly)(this, "address", provider.formatter.address(address));
        (0, _properties.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
    }
    supportsWildcard() {
        if (!this._supportsEip2544) // supportsInterface(bytes4 = selector("resolve(bytes,bytes)"))
        this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
        }).then((result)=>{
            return (0, _bignumber.BigNumber).from(result).eq(1);
        }).catch((error)=>{
            if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) return false;
            // Rethrow the error: link is down, etc. Let future attempts retry.
            this._supportsEip2544 = null;
            throw error;
        });
        return this._supportsEip2544;
    }
    _fetch(selector, parameters) {
        return __awaiter(this, void 0, void 0, function*() {
            // e.g. keccak256("addr(bytes32,uint256)")
            const tx = {
                to: this.address,
                ccipReadEnabled: true,
                data: (0, _bytes.hexConcat)([
                    selector,
                    (0, _hash.namehash)(this.name),
                    parameters || "0x"
                ])
            };
            // Wildcard support; use EIP-2544 to resolve the request
            let parseBytes = false;
            if (yield this.supportsWildcard()) {
                parseBytes = true;
                // selector("resolve(bytes,bytes)")
                tx.data = (0, _bytes.hexConcat)([
                    "0x9061b923",
                    encodeBytes([
                        (0, _hash.dnsEncode)(this.name),
                        tx.data
                    ])
                ]);
            }
            try {
                let result = yield this.provider.call(tx);
                if ((0, _bytes.arrayify)(result).length % 32 === 4) logger.throwError("resolver threw error", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    transaction: tx,
                    data: result
                });
                if (parseBytes) result = _parseBytes(result, 0);
                return result;
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) return null;
                throw error;
            }
        });
    }
    _fetchBytes(selector, parameters) {
        return __awaiter(this, void 0, void 0, function*() {
            const result = yield this._fetch(selector, parameters);
            if (result != null) return _parseBytes(result, 0);
            return null;
        });
    }
    _getAddress(coinType, hexBytes) {
        const coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) logger.throwError(`unsupported coin type: ${coinType}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${coinType})`
        });
        if (coinInfo.ilk === "eth") return this.provider.formatter.address(hexBytes);
        const bytes = (0, _bytes.arrayify)(hexBytes);
        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        if (coinInfo.p2pkh != null) {
            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (p2pkh) {
                const length = parseInt(p2pkh[1], 16);
                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) return base58Encode((0, _bytes.concat)([
                    [
                        coinInfo.p2pkh
                    ],
                    "0x" + p2pkh[2]
                ]));
            }
        }
        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
        if (coinInfo.p2sh != null) {
            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (p2sh) {
                const length = parseInt(p2sh[1], 16);
                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) return base58Encode((0, _bytes.concat)([
                    [
                        coinInfo.p2sh
                    ],
                    "0x" + p2sh[2]
                ]));
            }
        }
        // Bech32
        if (coinInfo.prefix != null) {
            const length = bytes[1];
            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program
            let version = bytes[0];
            if (version === 0x00) {
                if (length !== 20 && length !== 32) version = -1;
            } else version = -1;
            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
                const words = (0, _bech32Default.default).toWords(bytes.slice(2));
                words.unshift(version);
                return (0, _bech32Default.default).encode(coinInfo.prefix, words);
            }
        }
        return null;
    }
    getAddress(coinType) {
        return __awaiter(this, void 0, void 0, function*() {
            if (coinType == null) coinType = 60;
            // If Ethereum, use the standard `addr(bytes32)`
            if (coinType === 60) try {
                // keccak256("addr(bytes32)")
                const result = yield this._fetch("0x3b3b57de");
                // No address
                if (result === "0x" || result === (0, _constants.HashZero)) return null;
                return this.provider.formatter.callAddress(result);
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) return null;
                throw error;
            }
            // keccak256("addr(bytes32,uint256")
            const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
            // No address
            if (hexBytes == null || hexBytes === "0x") return null;
            // Compute the address
            const address = this._getAddress(coinType, hexBytes);
            if (address == null) logger.throwError(`invalid or unsupported coin data`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${coinType})`,
                coinType: coinType,
                data: hexBytes
            });
            return address;
        });
    }
    getAvatar() {
        return __awaiter(this, void 0, void 0, function*() {
            const linkage = [
                {
                    type: "name",
                    content: this.name
                }
            ];
            try {
                // test data for ricmoo.eth
                //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
                const avatar = yield this.getText("avatar");
                if (avatar == null) return null;
                for(let i = 0; i < matchers.length; i++){
                    const match = avatar.match(matchers[i]);
                    if (match == null) continue;
                    const scheme = match[1].toLowerCase();
                    switch(scheme){
                        case "https":
                            linkage.push({
                                type: "url",
                                content: avatar
                            });
                            return {
                                linkage,
                                url: avatar
                            };
                        case "data":
                            linkage.push({
                                type: "data",
                                content: avatar
                            });
                            return {
                                linkage,
                                url: avatar
                            };
                        case "ipfs":
                            linkage.push({
                                type: "ipfs",
                                content: avatar
                            });
                            return {
                                linkage,
                                url: getIpfsLink(avatar)
                            };
                        case "erc721":
                        case "erc1155":
                            {
                                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                                const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                                linkage.push({
                                    type: scheme,
                                    content: avatar
                                });
                                // The owner of this name
                                const owner = this._resolvedAddress || (yield this.getAddress());
                                const comps = (match[2] || "").split("/");
                                if (comps.length !== 2) return null;
                                const addr = yield this.provider.formatter.address(comps[0]);
                                const tokenId = (0, _bytes.hexZeroPad)((0, _bignumber.BigNumber).from(comps[1]).toHexString(), 32);
                                // Check that this account owns the token
                                if (scheme === "erc721") {
                                    // ownerOf(uint256 tokenId)
                                    const tokenOwner = this.provider.formatter.callAddress((yield this.provider.call({
                                        to: addr,
                                        data: (0, _bytes.hexConcat)([
                                            "0x6352211e",
                                            tokenId
                                        ])
                                    })));
                                    if (owner !== tokenOwner) return null;
                                    linkage.push({
                                        type: "owner",
                                        content: tokenOwner
                                    });
                                } else if (scheme === "erc1155") {
                                    // balanceOf(address owner, uint256 tokenId)
                                    const balance = (0, _bignumber.BigNumber).from((yield this.provider.call({
                                        to: addr,
                                        data: (0, _bytes.hexConcat)([
                                            "0x00fdd58e",
                                            (0, _bytes.hexZeroPad)(owner, 32),
                                            tokenId
                                        ])
                                    })));
                                    if (balance.isZero()) return null;
                                    linkage.push({
                                        type: "balance",
                                        content: balance.toString()
                                    });
                                }
                                // Call the token contract for the metadata URL
                                const tx = {
                                    to: this.provider.formatter.address(comps[0]),
                                    data: (0, _bytes.hexConcat)([
                                        selector,
                                        tokenId
                                    ])
                                };
                                let metadataUrl = _parseString((yield this.provider.call(tx)), 0);
                                if (metadataUrl == null) return null;
                                linkage.push({
                                    type: "metadata-url-base",
                                    content: metadataUrl
                                });
                                // ERC-1155 allows a generic {id} in the URL
                                if (scheme === "erc1155") {
                                    metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                                    linkage.push({
                                        type: "metadata-url-expanded",
                                        content: metadataUrl
                                    });
                                }
                                // Transform IPFS metadata links
                                if (metadataUrl.match(/^ipfs:/i)) metadataUrl = getIpfsLink(metadataUrl);
                                linkage.push({
                                    type: "metadata-url",
                                    content: metadataUrl
                                });
                                // Get the token metadata
                                const metadata = yield (0, _web.fetchJson)(metadataUrl);
                                if (!metadata) return null;
                                linkage.push({
                                    type: "metadata",
                                    content: JSON.stringify(metadata)
                                });
                                // Pull the image URL out
                                let imageUrl = metadata.image;
                                if (typeof imageUrl !== "string") return null;
                                if (imageUrl.match(/^(https:\/\/|data:)/i)) ;
                                else {
                                    // Transform IPFS link to gateway
                                    const ipfs = imageUrl.match(matcherIpfs);
                                    if (ipfs == null) return null;
                                    linkage.push({
                                        type: "url-ipfs",
                                        content: imageUrl
                                    });
                                    imageUrl = getIpfsLink(imageUrl);
                                }
                                linkage.push({
                                    type: "url",
                                    content: imageUrl
                                });
                                return {
                                    linkage,
                                    url: imageUrl
                                };
                            }
                    }
                }
            } catch (error) {}
            return null;
        });
    }
    getContentHash() {
        return __awaiter(this, void 0, void 0, function*() {
            // keccak256("contenthash()")
            const hexBytes = yield this._fetchBytes("0xbc1c58d1");
            // No contenthash
            if (hexBytes == null || hexBytes === "0x") return null;
            // IPFS (CID: 1, Type: DAG-PB)
            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (ipfs) {
                const length = parseInt(ipfs[3], 16);
                if (ipfs[4].length === length * 2) return "ipfs://" + (0, _basex.Base58).encode("0x" + ipfs[1]);
            }
            // IPNS (CID: 1, Type: libp2p-key)
            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (ipns) {
                const length = parseInt(ipns[3], 16);
                if (ipns[4].length === length * 2) return "ipns://" + (0, _basex.Base58).encode("0x" + ipns[1]);
            }
            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (swarm) {
                if (swarm[1].length === 64) return "bzz://" + swarm[1];
            }
            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
            if (skynet) {
                if (skynet[1].length === 68) {
                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5
                    const urlSafe = {
                        "=": "",
                        "+": "-",
                        "/": "_"
                    };
                    const hash = (0, _base64.encode)("0x" + skynet[1]).replace(/[=+\/]/g, (a)=>urlSafe[a]);
                    return "sia://" + hash;
                }
            }
            return logger.throwError(`invalid or unsupported content hash data`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: hexBytes
            });
        });
    }
    getText(key) {
        return __awaiter(this, void 0, void 0, function*() {
            // The key encoded as parameter to fetchBytes
            let keyBytes = (0, _strings.toUtf8Bytes)(key);
            // The nodehash consumes the first slot, so the string pointer targets
            // offset 64, with the length at offset 64 and data starting at offset 96
            keyBytes = (0, _bytes.concat)([
                bytes32ify(64),
                bytes32ify(keyBytes.length),
                keyBytes
            ]);
            // Pad to word-size (32 bytes)
            if (keyBytes.length % 32 !== 0) keyBytes = (0, _bytes.concat)([
                keyBytes,
                (0, _bytes.hexZeroPad)("0x", 32 - key.length % 32)
            ]);
            const hexBytes = yield this._fetchBytes("0x59d1d43c", (0, _bytes.hexlify)(keyBytes));
            if (hexBytes == null || hexBytes === "0x") return null;
            return (0, _strings.toUtf8String)(hexBytes);
        });
    }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends (0, _abstractProvider.Provider) {
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */ constructor(network){
        super();
        // Events being listened to
        this._events = [];
        this._emitted = {
            block: -2
        };
        this.disableCcipRead = false;
        this.formatter = new.target.getFormatter();
        // If network is any, this Provider allows the underlying
        // network to change dynamically, and we auto-detect the
        // current network
        (0, _properties.defineReadOnly)(this, "anyNetwork", network === "any");
        if (this.anyNetwork) network = this.detectNetwork();
        if (network instanceof Promise) {
            this._networkPromise = network;
            // Squash any "unhandled promise" errors; that do not need to be handled
            network.catch((error)=>{});
            // Trigger initial network setting (async)
            this._ready().catch((error)=>{});
        } else {
            const knownNetwork = (0, _properties.getStatic)(new.target, "getNetwork")(network);
            if (knownNetwork) {
                (0, _properties.defineReadOnly)(this, "_network", knownNetwork);
                this.emit("network", knownNetwork, null);
            } else logger.throwArgumentError("invalid network", "network", network);
        }
        this._maxInternalBlockNumber = -1024;
        this._lastBlockNumber = -2;
        this._maxFilterBlockRange = 10;
        this._pollingInterval = 4000;
        this._fastQueryDate = 0;
    }
    _ready() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this._network == null) {
                let network = null;
                if (this._networkPromise) try {
                    network = yield this._networkPromise;
                } catch (error) {}
                // Try the Provider's network detection (this MUST throw if it cannot)
                if (network == null) network = yield this.detectNetwork();
                // This should never happen; every Provider sub-class should have
                // suggested a network by here (or have thrown).
                if (!network) logger.throwError("no network detected", (0, _logger.Logger).errors.UNKNOWN_ERROR, {});
                // Possible this call stacked so do not call defineReadOnly again
                if (this._network == null) {
                    if (this.anyNetwork) this._network = network;
                    else (0, _properties.defineReadOnly)(this, "_network", network);
                    this.emit("network", network, null);
                }
            }
            return this._network;
        });
    }
    // This will always return the most recently established network.
    // For "any", this can change (a "network" event is emitted before
    // any change is reflected); otherwise this cannot change
    get ready() {
        return (0, _web.poll)(()=>{
            return this._ready().then((network)=>{
                return network;
            }, (error)=>{
                // If the network isn't running yet, we will wait
                if (error.code === (0, _logger.Logger).errors.NETWORK_ERROR && error.event === "noNetwork") return undefined;
                throw error;
            });
        });
    }
    // @TODO: Remove this and just create a singleton formatter
    static getFormatter() {
        if (defaultFormatter == null) defaultFormatter = new (0, _formatter.Formatter)();
        return defaultFormatter;
    }
    // @TODO: Remove this and just use getNetwork
    static getNetwork(network) {
        return (0, _networks.getNetwork)(network == null ? "homestead" : network);
    }
    ccipReadFetch(tx, calldata, urls) {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.disableCcipRead || urls.length === 0) return null;
            const sender = tx.to.toLowerCase();
            const data = calldata.toLowerCase();
            const errorMessages = [];
            for(let i = 0; i < urls.length; i++){
                const url = urls[i];
                // URL expansion
                const href = url.replace("{sender}", sender).replace("{data}", data);
                // If no {data} is present, use POST; otherwise GET
                const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({
                    data,
                    sender
                });
                const result = yield (0, _web.fetchJson)({
                    url: href,
                    errorPassThrough: true
                }, json, (value, response)=>{
                    value.status = response.statusCode;
                    return value;
                });
                if (result.data) return result.data;
                const errorMessage = result.message || "unknown error";
                // 4xx indicates the result is not present; stop
                if (result.status >= 400 && result.status < 500) return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, (0, _logger.Logger).errors.SERVER_ERROR, {
                    url,
                    errorMessage
                });
                // 5xx indicates server issue; try the next url
                errorMessages.push(errorMessage);
            }
            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(", ")}`, (0, _logger.Logger).errors.SERVER_ERROR, {
                urls,
                errorMessages
            });
        });
    }
    // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request
    _getInternalBlockNumber(maxAge) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this._ready();
            // Allowing stale data up to maxAge old
            if (maxAge > 0) // While there are pending internal block requests...
            while(this._internalBlockNumber){
                // ..."remember" which fetch we started with
                const internalBlockNumber = this._internalBlockNumber;
                try {
                    // Check the result is not too stale
                    const result = yield internalBlockNumber;
                    if (getTime() - result.respTime <= maxAge) return result.blockNumber;
                    break;
                } catch (error) {
                    // The fetch rejected; if we are the first to get the
                    // rejection, drop through so we replace it with a new
                    // fetch; all others blocked will then get that fetch
                    // which won't match the one they "remembered" and loop
                    if (this._internalBlockNumber === internalBlockNumber) break;
                }
            }
            const reqTime = getTime();
            const checkInternalBlockNumber = (0, _properties.resolveProperties)({
                blockNumber: this.perform("getBlockNumber", {}),
                networkError: this.getNetwork().then((network)=>null, (error)=>error)
            }).then(({ blockNumber, networkError })=>{
                if (networkError) {
                    // Unremember this bad internal block number
                    if (this._internalBlockNumber === checkInternalBlockNumber) this._internalBlockNumber = null;
                    throw networkError;
                }
                const respTime = getTime();
                blockNumber = (0, _bignumber.BigNumber).from(blockNumber).toNumber();
                if (blockNumber < this._maxInternalBlockNumber) blockNumber = this._maxInternalBlockNumber;
                this._maxInternalBlockNumber = blockNumber;
                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?
                return {
                    blockNumber,
                    reqTime,
                    respTime
                };
            });
            this._internalBlockNumber = checkInternalBlockNumber;
            // Swallow unhandled exceptions; if needed they are handled else where
            checkInternalBlockNumber.catch((error)=>{
                // Don't null the dead (rejected) fetch, if it has already been updated
                if (this._internalBlockNumber === checkInternalBlockNumber) this._internalBlockNumber = null;
            });
            return (yield checkInternalBlockNumber).blockNumber;
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function*() {
            const pollId = nextPollId++;
            // Track all running promises, so we can trigger a post-poll once they are complete
            const runners = [];
            let blockNumber = null;
            try {
                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
            } catch (error) {
                this.emit("error", error);
                return;
            }
            this._setFastBlockNumber(blockNumber);
            // Emit a poll event after we have the latest (fast) block number
            this.emit("poll", pollId, blockNumber);
            // If the block has not changed, meh.
            if (blockNumber === this._lastBlockNumber) {
                this.emit("didPoll", pollId);
                return;
            }
            // First polling cycle, trigger a "block" events
            if (this._emitted.block === -2) this._emitted.block = blockNumber - 1;
            if (Math.abs(this._emitted.block - blockNumber) > 1000) {
                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
                this.emit("error", logger.makeError("network block skew detected", (0, _logger.Logger).errors.NETWORK_ERROR, {
                    blockNumber: blockNumber,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                }));
                this.emit("block", blockNumber);
            } else // Notify all listener for each block that has passed
            for(let i = this._emitted.block + 1; i <= blockNumber; i++)this.emit("block", i);
            // The emitted block was updated, check for obsolete events
            if (this._emitted.block !== blockNumber) {
                this._emitted.block = blockNumber;
                Object.keys(this._emitted).forEach((key)=>{
                    // The block event does not expire
                    if (key === "block") return;
                    // The block we were at when we emitted this event
                    const eventBlockNumber = this._emitted[key];
                    // We cannot garbage collect pending transactions or blocks here
                    // They should be garbage collected by the Provider when setting
                    // "pending" events
                    if (eventBlockNumber === "pending") return;
                    // Evict any transaction hashes or block hashes over 12 blocks
                    // old, since they should not return null anyways
                    if (blockNumber - eventBlockNumber > 12) delete this._emitted[key];
                });
            }
            // First polling cycle
            if (this._lastBlockNumber === -2) this._lastBlockNumber = blockNumber - 1;
            // Find all transaction hashes we are waiting on
            this._events.forEach((event)=>{
                switch(event.type){
                    case "tx":
                        {
                            const hash = event.hash;
                            let runner = this.getTransactionReceipt(hash).then((receipt)=>{
                                if (!receipt || receipt.blockNumber == null) return null;
                                this._emitted["t:" + hash] = receipt.blockNumber;
                                this.emit(hash, receipt);
                                return null;
                            }).catch((error)=>{
                                this.emit("error", error);
                            });
                            runners.push(runner);
                            break;
                        }
                    case "filter":
                        // We only allow a single getLogs to be in-flight at a time
                        if (!event._inflight) {
                            event._inflight = true;
                            // This is the first filter for this event, so we want to
                            // restrict events to events that happened no earlier than now
                            if (event._lastBlockNumber === -2) event._lastBlockNumber = blockNumber - 1;
                            // Filter from the last *known* event; due to load-balancing
                            // and some nodes returning updated block numbers before
                            // indexing events, a logs result with 0 entries cannot be
                            // trusted and we must retry a range which includes it again
                            const filter = event.filter;
                            filter.fromBlock = event._lastBlockNumber + 1;
                            filter.toBlock = blockNumber;
                            // Prevent fitler ranges from growing too wild, since it is quite
                            // likely there just haven't been any events to move the lastBlockNumber.
                            const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
                            if (minFromBlock > filter.fromBlock) filter.fromBlock = minFromBlock;
                            if (filter.fromBlock < 0) filter.fromBlock = 0;
                            const runner = this.getLogs(filter).then((logs)=>{
                                // Allow the next getLogs
                                event._inflight = false;
                                if (logs.length === 0) return;
                                logs.forEach((log)=>{
                                    // Only when we get an event for a given block number
                                    // can we trust the events are indexed
                                    if (log.blockNumber > event._lastBlockNumber) event._lastBlockNumber = log.blockNumber;
                                    // Make sure we stall requests to fetch blocks and txs
                                    this._emitted["b:" + log.blockHash] = log.blockNumber;
                                    this._emitted["t:" + log.transactionHash] = log.blockNumber;
                                    this.emit(filter, log);
                                });
                            }).catch((error)=>{
                                this.emit("error", error);
                                // Allow another getLogs (the range was not updated)
                                event._inflight = false;
                            });
                            runners.push(runner);
                        }
                        break;
                }
            });
            this._lastBlockNumber = blockNumber;
            // Once all events for this loop have been processed, emit "didPoll"
            Promise.all(runners).then(()=>{
                this.emit("didPoll", pollId);
            }).catch((error)=>{
                this.emit("error", error);
            });
            return;
        });
    }
    // Deprecated; do not use this
    resetEventsBlock(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) this.poll();
    }
    get network() {
        return this._network;
    }
    // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            return logger.throwError("provider does not support network detection", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork"
            });
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            const network = yield this._ready();
            // Make sure we are still connected to the same network; this is
            // only an external call for backends which can have the underlying
            // network change spontaneously
            const currentNetwork = yield this.detectNetwork();
            if (network.chainId !== currentNetwork.chainId) {
                // We are allowing network changes, things can get complex fast;
                // make sure you know what you are doing if you use "any"
                if (this.anyNetwork) {
                    this._network = currentNetwork;
                    // Reset all internal block number guards and caches
                    this._lastBlockNumber = -2;
                    this._fastBlockNumber = null;
                    this._fastBlockNumberPromise = null;
                    this._fastQueryDate = 0;
                    this._emitted.block = -2;
                    this._maxInternalBlockNumber = -1024;
                    this._internalBlockNumber = null;
                    // The "network" event MUST happen before this method resolves
                    // so any events have a chance to unregister, so we stall an
                    // additional event loop before returning from /this/ call
                    this.emit("network", currentNetwork, network);
                    yield stall(0);
                    return this._network;
                }
                const error = logger.makeError("underlying network changed", (0, _logger.Logger).errors.NETWORK_ERROR, {
                    event: "changed",
                    network: network,
                    detectedNetwork: currentNetwork
                });
                this.emit("error", error);
                throw error;
            }
            return network;
        });
    }
    get blockNumber() {
        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber)=>{
            this._setFastBlockNumber(blockNumber);
        }, (error)=>{});
        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
    }
    get polling() {
        return this._poller != null;
    }
    set polling(value) {
        if (value && !this._poller) {
            this._poller = setInterval(()=>{
                this.poll();
            }, this.pollingInterval);
            if (!this._bootstrapPoll) this._bootstrapPoll = setTimeout(()=>{
                this.poll();
                // We block additional polls until the polling interval
                // is done, to prevent overwhelming the poll function
                this._bootstrapPoll = setTimeout(()=>{
                    // If polling was disabled, something may require a poke
                    // since starting the bootstrap poll and it was disabled
                    if (!this._poller) this.poll();
                    // Clear out the bootstrap so we can do another
                    this._bootstrapPoll = null;
                }, this.pollingInterval);
            }, 0);
        } else if (!value && this._poller) {
            clearInterval(this._poller);
            this._poller = null;
        }
    }
    get pollingInterval() {
        return this._pollingInterval;
    }
    set pollingInterval(value) {
        if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) throw new Error("invalid polling interval");
        this._pollingInterval = value;
        if (this._poller) {
            clearInterval(this._poller);
            this._poller = setInterval(()=>{
                this.poll();
            }, this._pollingInterval);
        }
    }
    _getFastBlockNumber() {
        const now = getTime();
        // Stale block number, request a newer value
        if (now - this._fastQueryDate > 2 * this._pollingInterval) {
            this._fastQueryDate = now;
            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber)=>{
                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) this._fastBlockNumber = blockNumber;
                return this._fastBlockNumber;
            });
        }
        return this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(blockNumber) {
        // Older block, maybe a stale request
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) return;
        // Update the time we updated the blocknumber
        this._fastQueryDate = getTime();
        // Newer block number, use  it
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
            this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter(this, void 0, void 0, function*() {
            return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
        });
    }
    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter(this, void 0, void 0, function*() {
            const receipt = yield this.getTransactionReceipt(transactionHash);
            // Receipt is already good
            if ((receipt ? receipt.confirmations : 0) >= confirmations) return receipt;
            // Poll until the receipt is good...
            return new Promise((resolve, reject)=>{
                const cancelFuncs = [];
                let done = false;
                const alreadyDone = function() {
                    if (done) return true;
                    done = true;
                    cancelFuncs.forEach((func)=>{
                        func();
                    });
                    return false;
                };
                const minedHandler = (receipt)=>{
                    if (receipt.confirmations < confirmations) return;
                    if (alreadyDone()) return;
                    resolve(receipt);
                };
                this.on(transactionHash, minedHandler);
                cancelFuncs.push(()=>{
                    this.removeListener(transactionHash, minedHandler);
                });
                if (replaceable) {
                    let lastBlockNumber = replaceable.startBlock;
                    let scannedBlock = null;
                    const replaceHandler = (blockNumber)=>__awaiter(this, void 0, void 0, function*() {
                            if (done) return;
                            // Wait 1 second; this is only used in the case of a fault, so
                            // we will trade off a little bit of latency for more consistent
                            // results and fewer JSON-RPC calls
                            yield stall(1000);
                            this.getTransactionCount(replaceable.from).then((nonce)=>__awaiter(this, void 0, void 0, function*() {
                                    if (done) return;
                                    if (nonce <= replaceable.nonce) lastBlockNumber = blockNumber;
                                    else {
                                        // First check if the transaction was mined
                                        {
                                            const mined = yield this.getTransaction(transactionHash);
                                            if (mined && mined.blockNumber != null) return;
                                        }
                                        // First time scanning. We start a little earlier for some
                                        // wiggle room here to handle the eventually consistent nature
                                        // of blockchain (e.g. the getTransactionCount was for a
                                        // different block)
                                        if (scannedBlock == null) {
                                            scannedBlock = lastBlockNumber - 3;
                                            if (scannedBlock < replaceable.startBlock) scannedBlock = replaceable.startBlock;
                                        }
                                        while(scannedBlock <= blockNumber){
                                            if (done) return;
                                            const block = yield this.getBlockWithTransactions(scannedBlock);
                                            for(let ti = 0; ti < block.transactions.length; ti++){
                                                const tx = block.transactions[ti];
                                                // Successfully mined!
                                                if (tx.hash === transactionHash) return;
                                                // Matches our transaction from and nonce; its a replacement
                                                if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                                                    if (done) return;
                                                    // Get the receipt of the replacement
                                                    const receipt = yield this.waitForTransaction(tx.hash, confirmations);
                                                    // Already resolved or rejected (prolly a timeout)
                                                    if (alreadyDone()) return;
                                                    // The reason we were replaced
                                                    let reason = "replaced";
                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) reason = "repriced";
                                                    else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) reason = "cancelled";
                                                    // Explain why we were replaced
                                                    reject(logger.makeError("transaction was replaced", (0, _logger.Logger).errors.TRANSACTION_REPLACED, {
                                                        cancelled: reason === "replaced" || reason === "cancelled",
                                                        reason,
                                                        replacement: this._wrapTransaction(tx),
                                                        hash: transactionHash,
                                                        receipt
                                                    }));
                                                    return;
                                                }
                                            }
                                            scannedBlock++;
                                        }
                                    }
                                    if (done) return;
                                    this.once("block", replaceHandler);
                                }), (error)=>{
                                if (done) return;
                                this.once("block", replaceHandler);
                            });
                        });
                    if (done) return;
                    this.once("block", replaceHandler);
                    cancelFuncs.push(()=>{
                        this.removeListener("block", replaceHandler);
                    });
                }
                if (typeof timeout === "number" && timeout > 0) {
                    const timer = setTimeout(()=>{
                        if (alreadyDone()) return;
                        reject(logger.makeError("timeout exceeded", (0, _logger.Logger).errors.TIMEOUT, {
                            timeout: timeout
                        }));
                    }, timeout);
                    if (timer.unref) timer.unref();
                    cancelFuncs.push(()=>{
                        clearTimeout(timer);
                    });
                }
            });
        });
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function*() {
            return this._getInternalBlockNumber(0);
        });
    }
    getGasPrice() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const result = yield this.perform("getGasPrice", {});
            try {
                return (0, _bignumber.BigNumber).from(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result,
                    error
                });
            }
        });
    }
    getBalance(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getBalance", params);
            try {
                return (0, _bignumber.BigNumber).from(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getBalance",
                    params,
                    result,
                    error
                });
            }
        });
    }
    getTransactionCount(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getTransactionCount", params);
            try {
                return (0, _bignumber.BigNumber).from(result).toNumber();
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params,
                    result,
                    error
                });
            }
        });
    }
    getCode(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getCode", params);
            try {
                return (0, _bytes.hexlify)(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getCode",
                    params,
                    result,
                    error
                });
            }
        });
    }
    getStorageAt(addressOrName, position, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag),
                position: Promise.resolve(position).then((p)=>(0, _bytes.hexValue)(p))
            });
            const result = yield this.perform("getStorageAt", params);
            try {
                return (0, _bytes.hexlify)(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params,
                    result,
                    error
                });
            }
        });
    }
    // This should be called by any subclass wrapping a TransactionResponse
    _wrapTransaction(tx, hash, startBlock) {
        if (hash != null && (0, _bytes.hexDataLength)(hash) !== 32) throw new Error("invalid response - sendTransaction");
        const result = tx;
        // Check the hash we expect is the same as the hash the server reported
        if (hash != null && tx.hash !== hash) logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", (0, _logger.Logger).errors.UNKNOWN_ERROR, {
            expectedHash: tx.hash,
            returnedHash: hash
        });
        result.wait = (confirms, timeout)=>__awaiter(this, void 0, void 0, function*() {
                if (confirms == null) confirms = 1;
                if (timeout == null) timeout = 0;
                // Get the details to detect replacement
                let replacement = undefined;
                if (confirms !== 0 && startBlock != null) replacement = {
                    data: tx.data,
                    from: tx.from,
                    nonce: tx.nonce,
                    to: tx.to,
                    value: tx.value,
                    startBlock
                };
                const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
                if (receipt == null && confirms === 0) return null;
                // No longer pending, allow the polling loop to garbage collect this
                this._emitted["t:" + tx.hash] = receipt.blockNumber;
                if (receipt.status === 0) logger.throwError("transaction failed", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    transactionHash: tx.hash,
                    transaction: tx,
                    receipt: receipt
                });
                return receipt;
            });
        return result;
    }
    sendTransaction(signedTransaction) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const hexTx = yield Promise.resolve(signedTransaction).then((t)=>(0, _bytes.hexlify)(t));
            const tx = this.formatter.transaction(signedTransaction);
            if (tx.confirmations == null) tx.confirmations = 0;
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            try {
                const hash = yield this.perform("sendTransaction", {
                    signedTransaction: hexTx
                });
                return this._wrapTransaction(tx, hash, blockNumber);
            } catch (error) {
                error.transaction = tx;
                error.transactionHash = tx.hash;
                throw error;
            }
        });
    }
    _getTransactionRequest(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            const values = yield transaction;
            const tx = {};
            [
                "from",
                "to"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v ? this._getAddress(v) : null);
            });
            [
                "gasLimit",
                "gasPrice",
                "maxFeePerGas",
                "maxPriorityFeePerGas",
                "value"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0, _bignumber.BigNumber).from(v) : null);
            });
            [
                "type"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v != null ? v : null);
            });
            if (values.accessList) tx.accessList = this.formatter.accessList(values.accessList);
            [
                "data"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0, _bytes.hexlify)(v) : null);
            });
            return this.formatter.transactionRequest((yield (0, _properties.resolveProperties)(tx)));
        });
    }
    _getFilter(filter) {
        return __awaiter(this, void 0, void 0, function*() {
            filter = yield filter;
            const result = {};
            if (filter.address != null) result.address = this._getAddress(filter.address);
            [
                "blockHash",
                "topics"
            ].forEach((key)=>{
                if (filter[key] == null) return;
                result[key] = filter[key];
            });
            [
                "fromBlock",
                "toBlock"
            ].forEach((key)=>{
                if (filter[key] == null) return;
                result[key] = this._getBlockTag(filter[key]);
            });
            return this.formatter.filter((yield (0, _properties.resolveProperties)(result)));
        });
    }
    _call(transaction, blockTag, attempt) {
        return __awaiter(this, void 0, void 0, function*() {
            if (attempt >= MAX_CCIP_REDIRECTS) logger.throwError("CCIP read exceeded maximum redirections", (0, _logger.Logger).errors.SERVER_ERROR, {
                redirects: attempt,
                transaction
            });
            const txSender = transaction.to;
            const result = yield this.perform("call", {
                transaction,
                blockTag
            });
            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)
            if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (0, _bytes.hexDataLength)(result) % 32 === 4) try {
                const data = (0, _bytes.hexDataSlice)(result, 4);
                // Check the sender of the OffchainLookup matches the transaction
                const sender = (0, _bytes.hexDataSlice)(data, 0, 32);
                if (!(0, _bignumber.BigNumber).from(sender).eq(txSender)) logger.throwError("CCIP Read sender did not match", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                });
                // Read the URLs from the response
                const urls = [];
                const urlsOffset = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(data, 32, 64)).toNumber();
                const urlsLength = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();
                const urlsData = (0, _bytes.hexDataSlice)(data, urlsOffset + 32);
                for(let u = 0; u < urlsLength; u++){
                    const url = _parseString(urlsData, u * 32);
                    if (url == null) logger.throwError("CCIP Read contained corrupt URL string", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                        name: "OffchainLookup",
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        transaction,
                        data: result
                    });
                    urls.push(url);
                }
                // Get the CCIP calldata to forward
                const calldata = _parseBytes(data, 64);
                // Get the callbackSelector (bytes4)
                if (!(0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(data, 100, 128)).isZero()) logger.throwError("CCIP Read callback selector included junk", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                });
                const callbackSelector = (0, _bytes.hexDataSlice)(data, 96, 100);
                // Get the extra data to send back to the contract as context
                const extraData = _parseBytes(data, 128);
                const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
                if (ccipResult == null) logger.throwError("CCIP Read disabled or provided no URLs", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                });
                const tx = {
                    to: txSender,
                    data: (0, _bytes.hexConcat)([
                        callbackSelector,
                        encodeBytes([
                            ccipResult,
                            extraData
                        ])
                    ])
                };
                return this._call(tx, blockTag, attempt + 1);
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.SERVER_ERROR) throw error;
            }
            try {
                return (0, _bytes.hexlify)(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "call",
                    params: {
                        transaction,
                        blockTag
                    },
                    result,
                    error
                });
            }
        });
    }
    call(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const resolved = yield (0, _properties.resolveProperties)({
                transaction: this._getTransactionRequest(transaction),
                blockTag: this._getBlockTag(blockTag),
                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
            });
            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
        });
    }
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                transaction: this._getTransactionRequest(transaction)
            });
            const result = yield this.perform("estimateGas", params);
            try {
                return (0, _bignumber.BigNumber).from(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params,
                    result,
                    error
                });
            }
        });
    }
    _getAddress(addressOrName) {
        return __awaiter(this, void 0, void 0, function*() {
            addressOrName = yield addressOrName;
            if (typeof addressOrName !== "string") logger.throwArgumentError("invalid address or ENS name", "name", addressOrName);
            const address = yield this.resolveName(addressOrName);
            if (address == null) logger.throwError("ENS name not configured", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: `resolveName(${JSON.stringify(addressOrName)})`
            });
            return address;
        });
    }
    _getBlock(blockHashOrBlockTag, includeTransactions) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            blockHashOrBlockTag = yield blockHashOrBlockTag;
            // If blockTag is a number (not "latest", etc), this is the block number
            let blockNumber = -128;
            const params = {
                includeTransactions: !!includeTransactions
            };
            if ((0, _bytes.isHexString)(blockHashOrBlockTag, 32)) params.blockHash = blockHashOrBlockTag;
            else try {
                params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
                if ((0, _bytes.isHexString)(params.blockTag)) blockNumber = parseInt(params.blockTag.substring(2), 16);
            } catch (error) {
                logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
            }
            return (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                    const block = yield this.perform("getBlock", params);
                    // Block was not found
                    if (block == null) {
                        // For blockhashes, if we didn't say it existed, that blockhash may
                        // not exist. If we did see it though, perhaps from a log, we know
                        // it exists, and this node is just not caught up yet.
                        if (params.blockHash != null) {
                            if (this._emitted["b:" + params.blockHash] == null) return null;
                        }
                        // For block tags, if we are asking for a future block, we return null
                        if (params.blockTag != null) {
                            if (blockNumber > this._emitted.block) return null;
                        }
                        // Retry on the next block
                        return undefined;
                    }
                    // Add transactions
                    if (includeTransactions) {
                        let blockNumber = null;
                        for(let i = 0; i < block.transactions.length; i++){
                            const tx = block.transactions[i];
                            if (tx.blockNumber == null) tx.confirmations = 0;
                            else if (tx.confirmations == null) {
                                if (blockNumber == null) blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                                // Add the confirmations using the fast block number (pessimistic)
                                let confirmations = blockNumber - tx.blockNumber + 1;
                                if (confirmations <= 0) confirmations = 1;
                                tx.confirmations = confirmations;
                            }
                        }
                        const blockWithTxs = this.formatter.blockWithTransactions(block);
                        blockWithTxs.transactions = blockWithTxs.transactions.map((tx)=>this._wrapTransaction(tx));
                        return blockWithTxs;
                    }
                    return this.formatter.block(block);
                }), {
                oncePoll: this
            });
        });
    }
    getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
    }
    getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
    }
    getTransaction(transactionHash) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = {
                transactionHash: this.formatter.hash(transactionHash, true)
            };
            return (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                    const result = yield this.perform("getTransaction", params);
                    if (result == null) {
                        if (this._emitted["t:" + transactionHash] == null) return null;
                        return undefined;
                    }
                    const tx = this.formatter.transactionResponse(result);
                    if (tx.blockNumber == null) tx.confirmations = 0;
                    else if (tx.confirmations == null) {
                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                        // Add the confirmations using the fast block number (pessimistic)
                        let confirmations = blockNumber - tx.blockNumber + 1;
                        if (confirmations <= 0) confirmations = 1;
                        tx.confirmations = confirmations;
                    }
                    return this._wrapTransaction(tx);
                }), {
                oncePoll: this
            });
        });
    }
    getTransactionReceipt(transactionHash) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = {
                transactionHash: this.formatter.hash(transactionHash, true)
            };
            return (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                    const result = yield this.perform("getTransactionReceipt", params);
                    if (result == null) {
                        if (this._emitted["t:" + transactionHash] == null) return null;
                        return undefined;
                    }
                    // "geth-etc" returns receipts before they are ready
                    if (result.blockHash == null) return undefined;
                    const receipt = this.formatter.receipt(result);
                    if (receipt.blockNumber == null) receipt.confirmations = 0;
                    else if (receipt.confirmations == null) {
                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                        // Add the confirmations using the fast block number (pessimistic)
                        let confirmations = blockNumber - receipt.blockNumber + 1;
                        if (confirmations <= 0) confirmations = 1;
                        receipt.confirmations = confirmations;
                    }
                    return receipt;
                }), {
                oncePoll: this
            });
        });
    }
    getLogs(filter) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                filter: this._getFilter(filter)
            });
            const logs = yield this.perform("getLogs", params);
            logs.forEach((log)=>{
                if (log.removed == null) log.removed = false;
            });
            return (0, _formatter.Formatter).arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
        });
    }
    getEtherPrice() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            return this.perform("getEtherPrice", {});
        });
    }
    _getBlockTag(blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            blockTag = yield blockTag;
            if (typeof blockTag === "number" && blockTag < 0) {
                if (blockTag % 1) logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                blockNumber += blockTag;
                if (blockNumber < 0) blockNumber = 0;
                return this.formatter.blockTag(blockNumber);
            }
            return this.formatter.blockTag(blockTag);
        });
    }
    getResolver(name) {
        return __awaiter(this, void 0, void 0, function*() {
            let currentName = name;
            while(true){
                if (currentName === "" || currentName === ".") return null;
                // Optimization since the eth node cannot change and does
                // not have a wildcard resolver
                if (name !== "eth" && currentName === "eth") return null;
                // Check the current node for a resolver
                const addr = yield this._getResolver(currentName, "getResolver");
                // Found a resolver!
                if (addr != null) {
                    const resolver = new Resolver(this, addr, name);
                    // Legacy resolver found, using EIP-2544 so it isn't safe to use
                    if (currentName !== name && !(yield resolver.supportsWildcard())) return null;
                    return resolver;
                }
                // Get the parent node
                currentName = currentName.split(".").slice(1).join(".");
            }
        });
    }
    _getResolver(name, operation) {
        return __awaiter(this, void 0, void 0, function*() {
            if (operation == null) operation = "ENS";
            const network = yield this.getNetwork();
            // No ENS...
            if (!network.ensAddress) logger.throwError("network does not support ENS", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation,
                network: network.name
            });
            try {
                // keccak256("resolver(bytes32)")
                const addrData = yield this.call({
                    to: network.ensAddress,
                    data: "0x0178b8bf" + (0, _hash.namehash)(name).substring(2)
                });
                return this.formatter.callAddress(addrData);
            } catch (error) {
            // ENS registry cannot throw errors on resolver(bytes32)
            }
            return null;
        });
    }
    resolveName(name) {
        return __awaiter(this, void 0, void 0, function*() {
            name = yield name;
            // If it is already an address, nothing to resolve
            try {
                return Promise.resolve(this.formatter.address(name));
            } catch (error) {
                // If is is a hexstring, the address is bad (See #694)
                if ((0, _bytes.isHexString)(name)) throw error;
            }
            if (typeof name !== "string") logger.throwArgumentError("invalid ENS name", "name", name);
            // Get the addr from the resolver
            const resolver = yield this.getResolver(name);
            if (!resolver) return null;
            return yield resolver.getAddress();
        });
    }
    lookupAddress(address) {
        return __awaiter(this, void 0, void 0, function*() {
            address = yield address;
            address = this.formatter.address(address);
            const node = address.substring(2).toLowerCase() + ".addr.reverse";
            const resolverAddr = yield this._getResolver(node, "lookupAddress");
            if (resolverAddr == null) return null;
            // keccak("name(bytes32)")
            const name = _parseString((yield this.call({
                to: resolverAddr,
                data: "0x691f3431" + (0, _hash.namehash)(node).substring(2)
            })), 0);
            const addr = yield this.resolveName(name);
            if (addr != address) return null;
            return name;
        });
    }
    getAvatar(nameOrAddress) {
        return __awaiter(this, void 0, void 0, function*() {
            let resolver = null;
            if ((0, _bytes.isHexString)(nameOrAddress)) {
                // Address; reverse lookup
                const address = this.formatter.address(nameOrAddress);
                const node = address.substring(2).toLowerCase() + ".addr.reverse";
                const resolverAddress = yield this._getResolver(node, "getAvatar");
                if (!resolverAddress) return null;
                // Try resolving the avatar against the addr.reverse resolver
                resolver = new Resolver(this, resolverAddress, node);
                try {
                    const avatar = yield resolver.getAvatar();
                    if (avatar) return avatar.url;
                } catch (error) {
                    if (error.code !== (0, _logger.Logger).errors.CALL_EXCEPTION) throw error;
                }
                // Try getting the name and performing forward lookup; allowing wildcards
                try {
                    // keccak("name(bytes32)")
                    const name = _parseString((yield this.call({
                        to: resolverAddress,
                        data: "0x691f3431" + (0, _hash.namehash)(node).substring(2)
                    })), 0);
                    resolver = yield this.getResolver(name);
                } catch (error) {
                    if (error.code !== (0, _logger.Logger).errors.CALL_EXCEPTION) throw error;
                    return null;
                }
            } else {
                // ENS name; forward lookup with wildcard
                resolver = yield this.getResolver(nameOrAddress);
                if (!resolver) return null;
            }
            const avatar = yield resolver.getAvatar();
            if (avatar == null) return null;
            return avatar.url;
        });
    }
    perform(method, params) {
        return logger.throwError(method + " not implemented", (0, _logger.Logger).errors.NOT_IMPLEMENTED, {
            operation: method
        });
    }
    _startEvent(event) {
        this.polling = this._events.filter((e)=>e.pollable()).length > 0;
    }
    _stopEvent(event) {
        this.polling = this._events.filter((e)=>e.pollable()).length > 0;
    }
    _addEventListener(eventName, listener, once) {
        const event = new Event(getEventTag(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
    }
    on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
    }
    once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
    }
    emit(eventName, ...args) {
        let result = false;
        let stopped = [];
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event)=>{
            if (event.tag !== eventTag) return true;
            setTimeout(()=>{
                event.listener.apply(this, args);
            }, 0);
            result = true;
            if (event.once) {
                stopped.push(event);
                return false;
            }
            return true;
        });
        stopped.forEach((event)=>{
            this._stopEvent(event);
        });
        return result;
    }
    listenerCount(eventName) {
        if (!eventName) return this._events.length;
        let eventTag = getEventTag(eventName);
        return this._events.filter((event)=>{
            return event.tag === eventTag;
        }).length;
    }
    listeners(eventName) {
        if (eventName == null) return this._events.map((event)=>event.listener);
        let eventTag = getEventTag(eventName);
        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);
    }
    off(eventName, listener) {
        if (listener == null) return this.removeAllListeners(eventName);
        const stopped = [];
        let found = false;
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event)=>{
            if (event.tag !== eventTag || event.listener != listener) return true;
            if (found) return true;
            found = true;
            stopped.push(event);
            return false;
        });
        stopped.forEach((event)=>{
            this._stopEvent(event);
        });
        return this;
    }
    removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
            stopped = this._events;
            this._events = [];
        } else {
            const eventTag = getEventTag(eventName);
            this._events = this._events.filter((event)=>{
                if (event.tag !== eventTag) return true;
                stopped.push(event);
                return false;
            });
        }
        stopped.forEach((event)=>{
            this._stopEvent(event);
        });
        return this;
    }
}

},{"@ethersproject/abstract-provider":"g1jr1","@ethersproject/base64":"329Wu","@ethersproject/basex":"dm2o4","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/constants":"gKbDE","@ethersproject/hash":"7JYPm","@ethersproject/networks":"6JNhW","@ethersproject/properties":"h3GJb","@ethersproject/sha2":"k4R8k","@ethersproject/strings":"5TGFZ","@ethersproject/web":"5yjI3","bech32":"2C5n6","@ethersproject/logger":"hLvB2","./_version":"6PYAk","./formatter":"ZfOHh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5yjI3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized
parcelHelpers.export(exports, "_fetchData", ()=>_fetchData);
parcelHelpers.export(exports, "fetchJson", ()=>fetchJson);
parcelHelpers.export(exports, "poll", ()=>poll);
var _base64 = require("@ethersproject/base64");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _strings = require("@ethersproject/strings");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _geturl = require("./geturl");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
function staller(duration) {
    return new Promise((resolve)=>{
        setTimeout(resolve, duration);
    });
}
function bodyify(value, type) {
    if (value == null) return null;
    if (typeof value === "string") return value;
    if ((0, _bytes.isBytesLike)(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) try {
            return (0, _strings.toUtf8String)(value);
        } catch (error) {}
        return (0, _bytes.hexlify)(value);
    }
    return value;
}
function unpercent(value) {
    return (0, _strings.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{
        return String.fromCharCode(parseInt(code, 16));
    }));
}
function _fetchData(connection, body, processFunc) {
    // How many times to retry in the event of a throttle
    const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
    logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
    const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
    logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
    const headers = {};
    let url = null;
    // @TODO: Allow ConnectionInfo to override some of these values
    const options = {
        method: "GET"
    };
    let allow304 = false;
    let timeout = 120000;
    if (typeof connection === "string") url = connection;
    else if (typeof connection === "object") {
        if (connection == null || connection.url == null) logger.throwArgumentError("missing URL", "connection.url", connection);
        url = connection.url;
        if (typeof connection.timeout === "number" && connection.timeout > 0) timeout = connection.timeout;
        if (connection.headers) for(const key in connection.headers){
            headers[key.toLowerCase()] = {
                key: key,
                value: String(connection.headers[key])
            };
            if ([
                "if-none-match",
                "if-modified-since"
            ].indexOf(key.toLowerCase()) >= 0) allow304 = true;
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
            if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) logger.throwError("basic authentication requires a secure https url", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "url",
                url: url,
                user: connection.user,
                password: "[REDACTED]"
            });
            const authorization = connection.user + ":" + connection.password;
            headers["authorization"] = {
                key: "Authorization",
                value: "Basic " + (0, _base64.encode)((0, _strings.toUtf8Bytes)(authorization))
            };
        }
        if (connection.skipFetchSetup != null) options.skipFetchSetup = !!connection.skipFetchSetup;
        if (connection.fetchOptions != null) options.fetchOptions = (0, _properties.shallowCopy)(connection.fetchOptions);
    }
    const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
    const dataMatch = url ? url.match(reData) : null;
    if (dataMatch) try {
        const response = {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
                "content-type": dataMatch[1] || "text/plain"
            },
            body: dataMatch[2] ? (0, _base64.decode)(dataMatch[3]) : unpercent(dataMatch[3])
        };
        let result = response.body;
        if (processFunc) result = processFunc(response.body, response);
        return Promise.resolve(result);
    } catch (error) {
        logger.throwError("processing response error", (0, _logger.Logger).errors.SERVER_ERROR, {
            body: bodyify(dataMatch[1], dataMatch[2]),
            error: error,
            requestBody: null,
            requestMethod: "GET",
            url: url
        });
    }
    if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) headers["content-type"] = {
            key: "Content-Type",
            value: "application/octet-stream"
        };
        if (headers["content-length"] == null) headers["content-length"] = {
            key: "Content-Length",
            value: String(body.length)
        };
    }
    const flatHeaders = {};
    Object.keys(headers).forEach((key)=>{
        const header = headers[key];
        flatHeaders[header.key] = header.value;
    });
    options.headers = flatHeaders;
    const runningTimeout = function() {
        let timer = null;
        const promise = new Promise(function(resolve, reject) {
            if (timeout) timer = setTimeout(()=>{
                if (timer == null) return;
                timer = null;
                reject(logger.makeError("timeout", (0, _logger.Logger).errors.TIMEOUT, {
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    timeout: timeout,
                    url: url
                }));
            }, timeout);
        });
        const cancel = function() {
            if (timer == null) return;
            clearTimeout(timer);
            timer = null;
        };
        return {
            promise,
            cancel
        };
    }();
    const runningFetch = function() {
        return __awaiter(this, void 0, void 0, function*() {
            for(let attempt = 0; attempt < attemptLimit; attempt++){
                let response = null;
                try {
                    response = yield (0, _geturl.getUrl)(url, options);
                    if (attempt < attemptLimit) {
                        if (response.statusCode === 301 || response.statusCode === 302) {
                            // Redirection; for now we only support absolute locataions
                            const location = response.headers.location || "";
                            if (options.method === "GET" && location.match(/^https:/)) {
                                url = response.headers.location;
                                continue;
                            }
                        } else if (response.statusCode === 429) {
                            // Exponential back-off throttling
                            let tryAgain = true;
                            if (throttleCallback) tryAgain = yield throttleCallback(attempt, url);
                            if (tryAgain) {
                                let stall = 0;
                                const retryAfter = response.headers["retry-after"];
                                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) stall = parseInt(retryAfter) * 1000;
                                else stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                                //console.log("Stalling 429");
                                yield staller(stall);
                                continue;
                            }
                        }
                    }
                } catch (error) {
                    response = error.response;
                    if (response == null) {
                        runningTimeout.cancel();
                        logger.throwError("missing response", (0, _logger.Logger).errors.SERVER_ERROR, {
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            serverError: error,
                            url: url
                        });
                    }
                }
                let body = response.body;
                if (allow304 && response.statusCode === 304) body = null;
                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
                    runningTimeout.cancel();
                    logger.throwError("bad response", (0, _logger.Logger).errors.SERVER_ERROR, {
                        status: response.statusCode,
                        headers: response.headers,
                        body: bodyify(body, response.headers ? response.headers["content-type"] : null),
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        url: url
                    });
                }
                if (processFunc) try {
                    const result = yield processFunc(body, response);
                    runningTimeout.cancel();
                    return result;
                } catch (error) {
                    // Allow the processFunc to trigger a throttle
                    if (error.throttleRetry && attempt < attemptLimit) {
                        let tryAgain = true;
                        if (throttleCallback) tryAgain = yield throttleCallback(attempt, url);
                        if (tryAgain) {
                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                            //console.log("Stalling callback");
                            yield staller(timeout);
                            continue;
                        }
                    }
                    runningTimeout.cancel();
                    logger.throwError("processing response error", (0, _logger.Logger).errors.SERVER_ERROR, {
                        body: bodyify(body, response.headers ? response.headers["content-type"] : null),
                        error: error,
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        url: url
                    });
                }
                runningTimeout.cancel();
                // If we had a processFunc, it either returned a T or threw above.
                // The "body" is now a Uint8Array.
                return body;
            }
            return logger.throwError("failed response", (0, _logger.Logger).errors.SERVER_ERROR, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url: url
            });
        });
    }();
    return Promise.race([
        runningTimeout.promise,
        runningFetch
    ]);
}
function fetchJson(connection, json, processFunc) {
    let processJsonFunc = (value, response)=>{
        let result = null;
        if (value != null) try {
            result = JSON.parse((0, _strings.toUtf8String)(value));
        } catch (error) {
            logger.throwError("invalid JSON", (0, _logger.Logger).errors.SERVER_ERROR, {
                body: value,
                error: error
            });
        }
        if (processFunc) result = processFunc(result, response);
        return result;
    };
    // If we have json to send, we must
    // - add content-type of application/json (unless already overridden)
    // - convert the json to bytes
    let body = null;
    if (json != null) {
        body = (0, _strings.toUtf8Bytes)(json);
        // Create a connection with the content-type set for JSON
        const updated = typeof connection === "string" ? {
            url: connection
        } : (0, _properties.shallowCopy)(connection);
        if (updated.headers) {
            const hasContentType = Object.keys(updated.headers).filter((k)=>k.toLowerCase() === "content-type").length !== 0;
            if (!hasContentType) {
                updated.headers = (0, _properties.shallowCopy)(updated.headers);
                updated.headers["content-type"] = "application/json";
            }
        } else updated.headers = {
            "content-type": "application/json"
        };
        connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
    if (!options) options = {};
    options = (0, _properties.shallowCopy)(options);
    if (options.floor == null) options.floor = 0;
    if (options.ceiling == null) options.ceiling = 10000;
    if (options.interval == null) options.interval = 250;
    return new Promise(function(resolve, reject) {
        let timer = null;
        let done = false;
        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.
        const cancel = ()=>{
            if (done) return false;
            done = true;
            if (timer) clearTimeout(timer);
            return true;
        };
        if (options.timeout) timer = setTimeout(()=>{
            if (cancel()) reject(new Error("timeout"));
        }, options.timeout);
        const retryLimit = options.retryLimit;
        let attempt = 0;
        function check() {
            return func().then(function(result) {
                // If we have a result, or are allowed null then we're done
                if (result !== undefined) {
                    if (cancel()) resolve(result);
                } else if (options.oncePoll) options.oncePoll.once("poll", check);
                else if (options.onceBlock) options.onceBlock.once("block", check);
                else if (!done) {
                    attempt++;
                    if (attempt > retryLimit) {
                        if (cancel()) reject(new Error("retry limit reached"));
                        return;
                    }
                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                    if (timeout < options.floor) timeout = options.floor;
                    if (timeout > options.ceiling) timeout = options.ceiling;
                    setTimeout(check, timeout);
                }
                return null;
            }, function(error) {
                if (cancel()) reject(error);
            });
        }
        check();
    });
}

},{"@ethersproject/base64":"329Wu","@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@ethersproject/strings":"5TGFZ","@ethersproject/logger":"hLvB2","./_version":"6HtXu","./geturl":"gsrWY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6HtXu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "web/5.7.1";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gsrWY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getUrl", ()=>getUrl);
var _bytes = require("@ethersproject/bytes");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getUrl(href, options) {
    return __awaiter(this, void 0, void 0, function*() {
        if (options == null) options = {};
        const request = {
            method: options.method || "GET",
            headers: options.headers || {},
            body: options.body || undefined
        };
        if (options.skipFetchSetup !== true) {
            request.mode = "cors"; // no-cors, cors, *same-origin
            request.cache = "no-cache"; // *default, no-cache, reload, force-cache, only-if-cached
            request.credentials = "same-origin"; // include, *same-origin, omit
            request.redirect = "follow"; // manual, *follow, error
            request.referrer = "client"; // no-referrer, *client
        }
        if (options.fetchOptions != null) {
            const opts = options.fetchOptions;
            if (opts.mode) request.mode = opts.mode;
            if (opts.cache) request.cache = opts.cache;
            if (opts.credentials) request.credentials = opts.credentials;
            if (opts.redirect) request.redirect = opts.redirect;
            if (opts.referrer) request.referrer = opts.referrer;
        }
        const response = yield fetch(href, request);
        const body = yield response.arrayBuffer();
        const headers = {};
        if (response.headers.forEach) response.headers.forEach((value, key)=>{
            headers[key.toLowerCase()] = value;
        });
        else response.headers.keys().forEach((key)=>{
            headers[key.toLowerCase()] = response.headers.get(key);
        });
        return {
            headers: headers,
            statusCode: response.status,
            statusMessage: response.statusText,
            body: (0, _bytes.arrayify)(new Uint8Array(body))
        };
    });
}

},{"@ethersproject/bytes":"htrqZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2C5n6":[function(require,module,exports) {
"use strict";
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
// pre-compute lookup table
var ALPHABET_MAP = {};
for(var z = 0; z < ALPHABET.length; z++){
    var x = ALPHABET.charAt(z);
    if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + " is ambiguous");
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    var b = pre >> 25;
    return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
    var chk = 1;
    for(var i = 0; i < prefix.length; ++i){
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for(i = 0; i < prefix.length; ++i){
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 0x1f;
    }
    return chk;
}
function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
    prefix = prefix.toLowerCase();
    // determine chk mod
    var chk = prefixChk(prefix);
    if (typeof chk === "string") throw new Error(chk);
    var result = prefix + "1";
    for(var i = 0; i < words.length; ++i){
        var x = words[i];
        if (x >> 5 !== 0) throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x;
        result += ALPHABET.charAt(x);
    }
    for(i = 0; i < 6; ++i)chk = polymodStep(chk);
    chk ^= 1;
    for(i = 0; i < 6; ++i){
        var v = chk >> (5 - i) * 5 & 0x1f;
        result += ALPHABET.charAt(v);
    }
    return result;
}
function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + " too short";
    if (str.length > LIMIT) return "Exceeds length limit";
    // don't allow mixed case
    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return "Mixed-case string " + str;
    str = lowered;
    var split = str.lastIndexOf("1");
    if (split === -1) return "No separator character for " + str;
    if (split === 0) return "Missing prefix for " + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return "Data too short";
    var chk = prefixChk(prefix);
    if (typeof chk === "string") return chk;
    var words = [];
    for(var i = 0; i < wordChars.length; ++i){
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === undefined) return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        // not in the checksum?
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
    }
    if (chk !== 1) return "Invalid checksum for " + str;
    return {
        prefix: prefix,
        words: words
    };
}
function decodeUnsafe() {
    var res = __decode.apply(null, arguments);
    if (typeof res === "object") return res;
}
function decode(str) {
    var res = __decode.apply(null, arguments);
    if (typeof res === "object") return res;
    throw new Error(res);
}
function convert(data, inBits, outBits, pad) {
    var value = 0;
    var bits = 0;
    var maxV = (1 << outBits) - 1;
    var result = [];
    for(var i = 0; i < data.length; ++i){
        value = value << inBits | data[i];
        bits += inBits;
        while(bits >= outBits){
            bits -= outBits;
            result.push(value >> bits & maxV);
        }
    }
    if (pad) {
        if (bits > 0) result.push(value << outBits - bits & maxV);
    } else {
        if (bits >= inBits) return "Excess padding";
        if (value << outBits - bits & maxV) return "Non-zero padding";
    }
    return result;
}
function toWordsUnsafe(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
}
function toWords(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
function fromWordsUnsafe(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
}
function fromWords(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
module.exports = {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWordsUnsafe: toWordsUnsafe,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
};

},{}],"6PYAk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "providers/5.7.2";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ZfOHh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Formatter", ()=>Formatter);
parcelHelpers.export(exports, "isCommunityResourcable", ()=>isCommunityResourcable);
parcelHelpers.export(exports, "isCommunityResource", ()=>isCommunityResource);
parcelHelpers.export(exports, "showThrottleMessage", ()=>showThrottleMessage);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _constants = require("@ethersproject/constants");
var _properties = require("@ethersproject/properties");
var _transactions = require("@ethersproject/transactions");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
class Formatter {
    constructor(){
        this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
        const formats = {};
        const address = this.address.bind(this);
        const bigNumber = this.bigNumber.bind(this);
        const blockTag = this.blockTag.bind(this);
        const data = this.data.bind(this);
        const hash = this.hash.bind(this);
        const hex = this.hex.bind(this);
        const number = this.number.bind(this);
        const type = this.type.bind(this);
        const strictData = (v)=>{
            return this.data(v, true);
        };
        formats.transaction = {
            hash: hash,
            type: type,
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
            blockHash: Formatter.allowNull(hash, null),
            blockNumber: Formatter.allowNull(number, null),
            transactionIndex: Formatter.allowNull(number, null),
            confirmations: Formatter.allowNull(number, null),
            from: address,
            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
            // must be set
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            gasLimit: bigNumber,
            to: Formatter.allowNull(address, null),
            value: bigNumber,
            nonce: number,
            data: data,
            r: Formatter.allowNull(this.uint256),
            s: Formatter.allowNull(this.uint256),
            v: Formatter.allowNull(number),
            creates: Formatter.allowNull(address, null),
            raw: Formatter.allowNull(data)
        };
        formats.transactionRequest = {
            from: Formatter.allowNull(address),
            nonce: Formatter.allowNull(number),
            gasLimit: Formatter.allowNull(bigNumber),
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            to: Formatter.allowNull(address),
            value: Formatter.allowNull(bigNumber),
            data: Formatter.allowNull(strictData),
            type: Formatter.allowNull(number),
            accessList: Formatter.allowNull(this.accessList.bind(this), null)
        };
        formats.receiptLog = {
            transactionIndex: number,
            blockNumber: number,
            transactionHash: hash,
            address: address,
            topics: Formatter.arrayOf(hash),
            data: data,
            logIndex: number,
            blockHash: hash
        };
        formats.receipt = {
            to: Formatter.allowNull(this.address, null),
            from: Formatter.allowNull(this.address, null),
            contractAddress: Formatter.allowNull(address, null),
            transactionIndex: number,
            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
            root: Formatter.allowNull(hex),
            gasUsed: bigNumber,
            logsBloom: Formatter.allowNull(data),
            blockHash: hash,
            transactionHash: hash,
            logs: Formatter.arrayOf(this.receiptLog.bind(this)),
            blockNumber: number,
            confirmations: Formatter.allowNull(number, null),
            cumulativeGasUsed: bigNumber,
            effectiveGasPrice: Formatter.allowNull(bigNumber),
            status: Formatter.allowNull(number),
            type: type
        };
        formats.block = {
            hash: Formatter.allowNull(hash),
            parentHash: hash,
            number: number,
            timestamp: number,
            nonce: Formatter.allowNull(hex),
            difficulty: this.difficulty.bind(this),
            gasLimit: bigNumber,
            gasUsed: bigNumber,
            miner: Formatter.allowNull(address),
            extraData: data,
            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
            baseFeePerGas: Formatter.allowNull(bigNumber)
        };
        formats.blockWithTransactions = (0, _properties.shallowCopy)(formats.block);
        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
            fromBlock: Formatter.allowNull(blockTag, undefined),
            toBlock: Formatter.allowNull(blockTag, undefined),
            blockHash: Formatter.allowNull(hash, undefined),
            address: Formatter.allowNull(address, undefined),
            topics: Formatter.allowNull(this.topics.bind(this), undefined)
        };
        formats.filterLog = {
            blockNumber: Formatter.allowNull(number),
            blockHash: Formatter.allowNull(hash),
            transactionIndex: number,
            removed: Formatter.allowNull(this.boolean.bind(this)),
            address: address,
            data: Formatter.allowFalsish(data, "0x"),
            topics: Formatter.arrayOf(hash),
            transactionHash: hash,
            logIndex: number
        };
        return formats;
    }
    accessList(accessList) {
        return (0, _transactions.accessListify)(accessList || []);
    }
    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
    // Strict! Used on input.
    number(number) {
        if (number === "0x") return 0;
        return (0, _bignumber.BigNumber).from(number).toNumber();
    }
    type(number) {
        if (number === "0x" || number == null) return 0;
        return (0, _bignumber.BigNumber).from(number).toNumber();
    }
    // Strict! Used on input.
    bigNumber(value) {
        return (0, _bignumber.BigNumber).from(value);
    }
    // Requires a boolean, "true" or  "false"; returns a boolean
    boolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "string") {
            value = value.toLowerCase();
            if (value === "true") return true;
            if (value === "false") return false;
        }
        throw new Error("invalid boolean - " + value);
    }
    hex(value, strict) {
        if (typeof value === "string") {
            if (!strict && value.substring(0, 2) !== "0x") value = "0x" + value;
            if ((0, _bytes.isHexString)(value)) return value.toLowerCase();
        }
        return logger.throwArgumentError("invalid hash", "value", value);
    }
    data(value, strict) {
        const result = this.hex(value, strict);
        if (result.length % 2 !== 0) throw new Error("invalid data; odd-length - " + value);
        return result;
    }
    // Requires an address
    // Strict! Used on input.
    address(value) {
        return (0, _address.getAddress)(value);
    }
    callAddress(value) {
        if (!(0, _bytes.isHexString)(value, 32)) return null;
        const address = (0, _address.getAddress)((0, _bytes.hexDataSlice)(value, 12));
        return address === (0, _constants.AddressZero) ? null : address;
    }
    contractAddress(value) {
        return (0, _address.getContractAddress)(value);
    }
    // Strict! Used on input.
    blockTag(blockTag) {
        if (blockTag == null) return "latest";
        if (blockTag === "earliest") return "0x0";
        switch(blockTag){
            case "earliest":
                return "0x0";
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
                return blockTag;
        }
        if (typeof blockTag === "number" || (0, _bytes.isHexString)(blockTag)) return (0, _bytes.hexValue)(blockTag);
        throw new Error("invalid blockTag");
    }
    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
    hash(value, strict) {
        const result = this.hex(value, strict);
        if ((0, _bytes.hexDataLength)(result) !== 32) return logger.throwArgumentError("invalid hash", "value", value);
        return result;
    }
    // Returns the difficulty as a number, or if too large (i.e. PoA network) null
    difficulty(value) {
        if (value == null) return null;
        const v = (0, _bignumber.BigNumber).from(value);
        try {
            return v.toNumber();
        } catch (error) {}
        return null;
    }
    uint256(value) {
        if (!(0, _bytes.isHexString)(value)) throw new Error("invalid uint256");
        return (0, _bytes.hexZeroPad)(value, 32);
    }
    _block(value, format) {
        if (value.author != null && value.miner == null) value.miner = value.author;
        // The difficulty may need to come from _difficulty in recursed blocks
        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
        const result = Formatter.check(format, value);
        result._difficulty = difficulty == null ? null : (0, _bignumber.BigNumber).from(difficulty);
        return result;
    }
    block(value) {
        return this._block(value, this.formats.block);
    }
    blockWithTransactions(value) {
        return this._block(value, this.formats.blockWithTransactions);
    }
    // Strict! Used on input.
    transactionRequest(value) {
        return Formatter.check(this.formats.transactionRequest, value);
    }
    transactionResponse(transaction) {
        // Rename gas to gasLimit
        if (transaction.gas != null && transaction.gasLimit == null) transaction.gasLimit = transaction.gas;
        // Some clients (TestRPC) do strange things like return 0x0 for the
        // 0 address; correct this to be a real address
        if (transaction.to && (0, _bignumber.BigNumber).from(transaction.to).isZero()) transaction.to = "0x0000000000000000000000000000000000000000";
        // Rename input to data
        if (transaction.input != null && transaction.data == null) transaction.data = transaction.input;
        // If to and creates are empty, populate the creates from the transaction
        if (transaction.to == null && transaction.creates == null) transaction.creates = this.contractAddress(transaction);
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) transaction.accessList = [];
        const result = Formatter.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
            let chainId = transaction.chainId;
            if ((0, _bytes.isHexString)(chainId)) chainId = (0, _bignumber.BigNumber).from(chainId).toNumber();
            result.chainId = chainId;
        } else {
            let chainId = transaction.networkId;
            // geth-etc returns chainId
            if (chainId == null && result.v == null) chainId = transaction.chainId;
            if ((0, _bytes.isHexString)(chainId)) chainId = (0, _bignumber.BigNumber).from(chainId).toNumber();
            if (typeof chainId !== "number" && result.v != null) {
                chainId = (result.v - 35) / 2;
                if (chainId < 0) chainId = 0;
                chainId = parseInt(chainId);
            }
            if (typeof chainId !== "number") chainId = 0;
            result.chainId = chainId;
        }
        // 0x0000... should actually be null
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") result.blockHash = null;
        return result;
    }
    transaction(value) {
        return (0, _transactions.parse)(value);
    }
    receiptLog(value) {
        return Formatter.check(this.formats.receiptLog, value);
    }
    receipt(value) {
        const result = Formatter.check(this.formats.receipt, value);
        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it
        if (result.root != null) {
            if (result.root.length <= 4) {
                // Could be 0x00, 0x0, 0x01 or 0x1
                const value = (0, _bignumber.BigNumber).from(result.root).toNumber();
                if (value === 0 || value === 1) {
                    // Make sure if both are specified, they match
                    if (result.status != null && result.status !== value) logger.throwArgumentError("alt-root-status/status mismatch", "value", {
                        root: result.root,
                        status: result.status
                    });
                    result.status = value;
                    delete result.root;
                } else logger.throwArgumentError("invalid alt-root-status", "value.root", result.root);
            } else if (result.root.length !== 66) // Must be a valid bytes32
            logger.throwArgumentError("invalid root hash", "value.root", result.root);
        }
        if (result.status != null) result.byzantium = true;
        return result;
    }
    topics(value) {
        if (Array.isArray(value)) return value.map((v)=>this.topics(v));
        else if (value != null) return this.hash(value, true);
        return null;
    }
    filter(value) {
        return Formatter.check(this.formats.filter, value);
    }
    filterLog(value) {
        return Formatter.check(this.formats.filterLog, value);
    }
    static check(format, object) {
        const result = {};
        for(const key in format)try {
            const value = format[key](object[key]);
            if (value !== undefined) result[key] = value;
        } catch (error) {
            error.checkKey = key;
            error.checkValue = object[key];
            throw error;
        }
        return result;
    }
    // if value is null-ish, nullValue is returned
    static allowNull(format, nullValue) {
        return function(value) {
            if (value == null) return nullValue;
            return format(value);
        };
    }
    // If value is false-ish, replaceValue is returned
    static allowFalsish(format, replaceValue) {
        return function(value) {
            if (!value) return replaceValue;
            return format(value);
        };
    }
    // Requires an Array satisfying check
    static arrayOf(format) {
        return function(array) {
            if (!Array.isArray(array)) throw new Error("not an array");
            const result = [];
            array.forEach(function(value) {
                result.push(format(value));
            });
            return result;
        };
    }
}
function isCommunityResourcable(value) {
    return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
    return isCommunityResourcable(value) && value.isCommunityResource();
}
// Show the throttle message only once
let throttleMessage = false;
function showThrottleMessage() {
    if (throttleMessage) return;
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https://docs.ethers.io/api-keys/");
    console.log("==========================");
}

},{"@ethersproject/address":"ggdAz","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/constants":"gKbDE","@ethersproject/properties":"h3GJb","@ethersproject/transactions":"d1ust","@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jD4Nf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlchemyWebSocketProvider", ()=>AlchemyWebSocketProvider);
parcelHelpers.export(exports, "AlchemyProvider", ()=>AlchemyProvider);
var _properties = require("@ethersproject/properties");
var _formatter = require("./formatter");
var _websocketProvider = require("./websocket-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
// This key was provided to ethers.js by Alchemy to be used by the
// default provider, but it is recommended that for your own
// production environments, that you acquire your own API key at:
//   https://dashboard.alchemyapi.io
const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends (0, _websocketProvider.WebSocketProvider) {
    constructor(network, apiKey){
        const provider = new AlchemyProvider(network, apiKey);
        const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
        super(url, provider.network);
        (0, _properties.defineReadOnly)(this, "apiKey", provider.apiKey);
    }
    isCommunityResource() {
        return this.apiKey === defaultApiKey;
    }
}
class AlchemyProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getWebSocketProvider(network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        if (apiKey == null) return defaultApiKey;
        if (apiKey && typeof apiKey !== "string") logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        return apiKey;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network.name){
            case "homestead":
                host = "eth-mainnet.alchemyapi.io/v2/";
                break;
            case "goerli":
                host = "eth-goerli.g.alchemy.com/v2/";
                break;
            case "matic":
                host = "polygon-mainnet.g.alchemy.com/v2/";
                break;
            case "maticmum":
                host = "polygon-mumbai.g.alchemy.com/v2/";
                break;
            case "arbitrum":
                host = "arb-mainnet.g.alchemy.com/v2/";
                break;
            case "arbitrum-goerli":
                host = "arb-goerli.g.alchemy.com/v2/";
                break;
            case "optimism":
                host = "opt-mainnet.g.alchemy.com/v2/";
                break;
            case "optimism-goerli":
                host = "opt-goerli.g.alchemy.com/v2/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
            allowGzip: true,
            url: "https://" + host + apiKey,
            throttleCallback: (attempt, url)=>{
                if (apiKey === defaultApiKey) (0, _formatter.showThrottleMessage)();
                return Promise.resolve(true);
            }
        };
    }
    isCommunityResource() {
        return this.apiKey === defaultApiKey;
    }
}

},{"@ethersproject/properties":"h3GJb","./formatter":"ZfOHh","./websocket-provider":"9KF9f","@ethersproject/logger":"hLvB2","./_version":"6PYAk","./url-json-rpc-provider":"9CTqA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9KF9f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub
parcelHelpers.export(exports, "WebSocketProvider", ()=>WebSocketProvider);
var _bignumber = require("@ethersproject/bignumber");
var _properties = require("@ethersproject/properties");
var _jsonRpcProvider = require("./json-rpc-provider");
var _ws = require("./ws");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */ let NextId = 1;
class WebSocketProvider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    constructor(url, network){
        // This will be added in the future; please open an issue to expedite
        if (network === "any") logger.throwError("WebSocketProvider does not support 'any' network yet", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "network:any"
        });
        if (typeof url === "string") super(url, network);
        else super("_websocket", network);
        this._pollingInterval = -1;
        this._wsReady = false;
        if (typeof url === "string") (0, _properties.defineReadOnly)(this, "_websocket", new (0, _ws.WebSocket)(this.connection.url));
        else (0, _properties.defineReadOnly)(this, "_websocket", url);
        (0, _properties.defineReadOnly)(this, "_requests", {});
        (0, _properties.defineReadOnly)(this, "_subs", {});
        (0, _properties.defineReadOnly)(this, "_subIds", {});
        (0, _properties.defineReadOnly)(this, "_detectNetwork", super.detectNetwork());
        // Stall sending requests until the socket is open...
        this.websocket.onopen = ()=>{
            this._wsReady = true;
            Object.keys(this._requests).forEach((id)=>{
                this.websocket.send(this._requests[id].payload);
            });
        };
        this.websocket.onmessage = (messageEvent)=>{
            const data = messageEvent.data;
            const result = JSON.parse(data);
            if (result.id != null) {
                const id = String(result.id);
                const request = this._requests[id];
                delete this._requests[id];
                if (result.result !== undefined) {
                    request.callback(null, result.result);
                    this.emit("debug", {
                        action: "response",
                        request: JSON.parse(request.payload),
                        response: result.result,
                        provider: this
                    });
                } else {
                    let error = null;
                    if (result.error) {
                        error = new Error(result.error.message || "unknown error");
                        (0, _properties.defineReadOnly)(error, "code", result.error.code || null);
                        (0, _properties.defineReadOnly)(error, "response", data);
                    } else error = new Error("unknown error");
                    request.callback(error, undefined);
                    this.emit("debug", {
                        action: "response",
                        error: error,
                        request: JSON.parse(request.payload),
                        provider: this
                    });
                }
            } else if (result.method === "eth_subscription") {
                // Subscription...
                const sub = this._subs[result.params.subscription];
                if (sub) //this.emit.apply(this,                  );
                sub.processFunc(result.params.result);
            } else console.warn("this should not happen");
        };
        // This Provider does not actually poll, but we want to trigger
        // poll events for things that depend on them (like stalling for
        // block and transaction lookups)
        const fauxPoll = setInterval(()=>{
            this.emit("poll");
        }, 1000);
        if (fauxPoll.unref) fauxPoll.unref();
    }
    // Cannot narrow the type of _websocket, as that is not backwards compatible
    // so we add a getter and let the WebSocket be a public API.
    get websocket() {
        return this._websocket;
    }
    detectNetwork() {
        return this._detectNetwork;
    }
    get pollingInterval() {
        return 0;
    }
    resetEventsBlock(blockNumber) {
        logger.throwError("cannot reset events block on WebSocketProvider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "resetEventBlock"
        });
    }
    set pollingInterval(value) {
        logger.throwError("cannot set polling interval on WebSocketProvider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function*() {
            return null;
        });
    }
    set polling(value) {
        if (!value) return;
        logger.throwError("cannot set polling on WebSocketProvider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
        });
    }
    send(method, params) {
        const rid = NextId++;
        return new Promise((resolve, reject)=>{
            function callback(error, result) {
                if (error) return reject(error);
                return resolve(result);
            }
            const payload = JSON.stringify({
                method: method,
                params: params,
                id: rid,
                jsonrpc: "2.0"
            });
            this.emit("debug", {
                action: "request",
                request: JSON.parse(payload),
                provider: this
            });
            this._requests[String(rid)] = {
                callback,
                payload
            };
            if (this._wsReady) this.websocket.send(payload);
        });
    }
    static defaultUrl() {
        return "ws://localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
        return __awaiter(this, void 0, void 0, function*() {
            let subIdPromise = this._subIds[tag];
            if (subIdPromise == null) {
                subIdPromise = Promise.all(param).then((param)=>{
                    return this.send("eth_subscribe", param);
                });
                this._subIds[tag] = subIdPromise;
            }
            const subId = yield subIdPromise;
            this._subs[subId] = {
                tag,
                processFunc
            };
        });
    }
    _startEvent(event) {
        switch(event.type){
            case "block":
                this._subscribe("block", [
                    "newHeads"
                ], (result)=>{
                    const blockNumber = (0, _bignumber.BigNumber).from(result.number).toNumber();
                    this._emitted.block = blockNumber;
                    this.emit("block", blockNumber);
                });
                break;
            case "pending":
                this._subscribe("pending", [
                    "newPendingTransactions"
                ], (result)=>{
                    this.emit("pending", result);
                });
                break;
            case "filter":
                this._subscribe(event.tag, [
                    "logs",
                    this._getFilter(event.filter)
                ], (result)=>{
                    if (result.removed == null) result.removed = false;
                    this.emit(event.filter, this.formatter.filterLog(result));
                });
                break;
            case "tx":
                {
                    const emitReceipt = (event)=>{
                        const hash = event.hash;
                        this.getTransactionReceipt(hash).then((receipt)=>{
                            if (!receipt) return;
                            this.emit(hash, receipt);
                        });
                    };
                    // In case it is already mined
                    emitReceipt(event);
                    // To keep things simple, we start up a single newHeads subscription
                    // to keep an eye out for transactions we are watching for.
                    // Starting a subscription for an event (i.e. "tx") that is already
                    // running is (basically) a nop.
                    this._subscribe("tx", [
                        "newHeads"
                    ], (result)=>{
                        this._events.filter((e)=>e.type === "tx").forEach(emitReceipt);
                    });
                    break;
                }
            // Nothing is needed
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
                break;
            default:
                console.log("unhandled:", event);
                break;
        }
    }
    _stopEvent(event) {
        let tag = event.tag;
        if (event.type === "tx") {
            // There are remaining transaction event listeners
            if (this._events.filter((e)=>e.type === "tx").length) return;
            tag = "tx";
        } else if (this.listenerCount(event.event)) // There are remaining event listeners
        return;
        const subId = this._subIds[tag];
        if (!subId) return;
        delete this._subIds[tag];
        subId.then((subId)=>{
            if (!this._subs[subId]) return;
            delete this._subs[subId];
            this.send("eth_unsubscribe", [
                subId
            ]);
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function*() {
            // Wait until we have connected before trying to disconnect
            if (this.websocket.readyState === (0, _ws.WebSocket).CONNECTING) yield new Promise((resolve)=>{
                this.websocket.onopen = function() {
                    resolve(true);
                };
                this.websocket.onerror = function() {
                    resolve(false);
                };
            });
            // Hangup
            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
            this.websocket.close(1000);
        });
    }
}

},{"@ethersproject/bignumber":"ckYYW","@ethersproject/properties":"h3GJb","./json-rpc-provider":"1sWtk","./ws":"d41Wa","@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1sWtk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JsonRpcSigner", ()=>JsonRpcSigner);
parcelHelpers.export(exports, "JsonRpcProvider", ()=>JsonRpcProvider);
var _abstractSigner = require("@ethersproject/abstract-signer");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _hash = require("@ethersproject/hash");
var _properties = require("@ethersproject/properties");
var _strings = require("@ethersproject/strings");
var _transactions = require("@ethersproject/transactions");
var _web = require("@ethersproject/web");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _baseProvider = require("./base-provider");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const errorGas = [
    "call",
    "estimateGas"
];
function spelunk(value, requireData) {
    if (value == null) return null;
    // These *are* the droids we're looking for.
    if (typeof value.message === "string" && value.message.match("reverted")) {
        const data = (0, _bytes.isHexString)(value.data) ? value.data : null;
        if (!requireData || data) return {
            message: value.message,
            data
        };
    }
    // Spelunk further...
    if (typeof value === "object") {
        for(const key in value){
            const result = spelunk(value[key], requireData);
            if (result) return result;
        }
        return null;
    }
    // Might be a JSON string we can further descend...
    if (typeof value === "string") try {
        return spelunk(JSON.parse(value), requireData);
    } catch (error) {}
    return null;
}
function checkError(method, error, params) {
    const transaction = params.transaction || params.signedTransaction;
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call") {
        const result = spelunk(error, true);
        if (result) return result.data;
        // Nothing descriptive..
        logger.throwError("missing revert data in call exception; Transaction reverted without a reason string", (0, _logger.Logger).errors.CALL_EXCEPTION, {
            data: "0x",
            transaction,
            error
        });
    }
    if (method === "estimateGas") {
        // Try to find something, with a preference on SERVER_ERROR body
        let result = spelunk(error.body, false);
        if (result == null) result = spelunk(error, false);
        // Found "reverted", this is a CALL_EXCEPTION
        if (result) logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
            reason: result.message,
            method,
            transaction,
            error
        });
    }
    // @TODO: Should we spelunk for message too?
    let message = error.message;
    if (error.code === (0, _logger.Logger).errors.SERVER_ERROR && error.error && typeof error.error.message === "string") message = error.error.message;
    else if (typeof error.body === "string") message = error.body;
    else if (typeof error.responseText === "string") message = error.responseText;
    message = (message || "").toLowerCase();
    // "insufficient funds for gas * price + value + cost(data)"
    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) logger.throwError("insufficient funds for intrinsic transaction cost", (0, _logger.Logger).errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
    });
    // "nonce too low"
    if (message.match(/nonce (is )?too low/i)) logger.throwError("nonce has already been used", (0, _logger.Logger).errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
    });
    // "replacement transaction underpriced"
    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) logger.throwError("replacement fee too low", (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
    });
    // "replacement transaction underpriced"
    if (message.match(/only replay-protected/i)) logger.throwError("legacy pre-eip-155 transactions not supported", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        error,
        method,
        transaction
    });
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
    });
    throw error;
}
function timer(timeout) {
    return new Promise(function(resolve) {
        setTimeout(resolve, timeout);
    });
}
function getResult(payload) {
    if (payload.error) {
        // @TODO: not any
        const error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
    }
    return payload.result;
}
function getLowerCase(value) {
    if (value) return value.toLowerCase();
    return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends (0, _abstractSigner.Signer) {
    constructor(constructorGuard, provider, addressOrIndex){
        super();
        if (constructorGuard !== _constructorGuard) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        (0, _properties.defineReadOnly)(this, "provider", provider);
        if (addressOrIndex == null) addressOrIndex = 0;
        if (typeof addressOrIndex === "string") {
            (0, _properties.defineReadOnly)(this, "_address", this.provider.formatter.address(addressOrIndex));
            (0, _properties.defineReadOnly)(this, "_index", null);
        } else if (typeof addressOrIndex === "number") {
            (0, _properties.defineReadOnly)(this, "_index", addressOrIndex);
            (0, _properties.defineReadOnly)(this, "_address", null);
        } else logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
    connect(provider) {
        return logger.throwError("cannot alter JSON-RPC Signer connection", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        });
    }
    connectUnchecked() {
        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
    }
    getAddress() {
        if (this._address) return Promise.resolve(this._address);
        return this.provider.send("eth_accounts", []).then((accounts)=>{
            if (accounts.length <= this._index) logger.throwError("unknown account #" + this._index, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "getAddress"
            });
            return this.provider.formatter.address(accounts[this._index]);
        });
    }
    sendUncheckedTransaction(transaction) {
        transaction = (0, _properties.shallowCopy)(transaction);
        const fromAddress = this.getAddress().then((address)=>{
            if (address) address = address.toLowerCase();
            return address;
        });
        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
        // wishes to use this, it is easy to specify explicitly, otherwise
        // we look it up for them.
        if (transaction.gasLimit == null) {
            const estimate = (0, _properties.shallowCopy)(transaction);
            estimate.from = fromAddress;
            transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) transaction.to = Promise.resolve(transaction.to).then((to)=>__awaiter(this, void 0, void 0, function*() {
                if (to == null) return null;
                const address = yield this.provider.resolveName(to);
                if (address == null) logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                return address;
            }));
        return (0, _properties.resolveProperties)({
            tx: (0, _properties.resolveProperties)(transaction),
            sender: fromAddress
        }).then(({ tx, sender })=>{
            if (tx.from != null) {
                if (tx.from.toLowerCase() !== sender) logger.throwArgumentError("from address mismatch", "transaction", transaction);
            } else tx.from = sender;
            const hexTx = this.provider.constructor.hexlifyTransaction(tx, {
                from: true
            });
            return this.provider.send("eth_sendTransaction", [
                hexTx
            ]).then((hash)=>{
                return hash;
            }, (error)=>{
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected transaction", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "sendTransaction",
                    transaction: tx
                });
                return checkError("sendTransaction", error, hexTx);
            });
        });
    }
    signTransaction(transaction) {
        return logger.throwError("signing transactions is unsupported", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        });
    }
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            // This cannot be mined any earlier than any recent block
            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
            // Send the transaction
            const hash = yield this.sendUncheckedTransaction(transaction);
            try {
                // Unfortunately, JSON-RPC only provides and opaque transaction hash
                // for a response, and we need the actual transaction, so we poll
                // for it; it should show up very quickly
                return yield (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                        const tx = yield this.provider.getTransaction(hash);
                        if (tx === null) return undefined;
                        return this.provider._wrapTransaction(tx, hash, blockNumber);
                    }), {
                    oncePoll: this.provider
                });
            } catch (error) {
                error.transactionHash = hash;
                throw error;
            }
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function*() {
            const data = typeof message === "string" ? (0, _strings.toUtf8Bytes)(message) : message;
            const address = yield this.getAddress();
            try {
                return yield this.provider.send("personal_sign", [
                    (0, _bytes.hexlify)(data),
                    address.toLowerCase()
                ]);
            } catch (error) {
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected signing", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "signMessage",
                    from: address,
                    messageData: message
                });
                throw error;
            }
        });
    }
    _legacySignMessage(message) {
        return __awaiter(this, void 0, void 0, function*() {
            const data = typeof message === "string" ? (0, _strings.toUtf8Bytes)(message) : message;
            const address = yield this.getAddress();
            try {
                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
                return yield this.provider.send("eth_sign", [
                    address.toLowerCase(),
                    (0, _bytes.hexlify)(data)
                ]);
            } catch (error) {
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected signing", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "_legacySignMessage",
                    from: address,
                    messageData: message
                });
                throw error;
            }
        });
    }
    _signTypedData(domain, types, value) {
        return __awaiter(this, void 0, void 0, function*() {
            // Populate any ENS names (in-place)
            const populated = yield (0, _hash._TypedDataEncoder).resolveNames(domain, types, value, (name)=>{
                return this.provider.resolveName(name);
            });
            const address = yield this.getAddress();
            try {
                return yield this.provider.send("eth_signTypedData_v4", [
                    address.toLowerCase(),
                    JSON.stringify((0, _hash._TypedDataEncoder).getPayload(populated.domain, types, populated.value))
                ]);
            } catch (error) {
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected signing", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "_signTypedData",
                    from: address,
                    messageData: {
                        domain: populated.domain,
                        types,
                        value: populated.value
                    }
                });
                throw error;
            }
        });
    }
    unlock(password) {
        return __awaiter(this, void 0, void 0, function*() {
            const provider = this.provider;
            const address = yield this.getAddress();
            return provider.send("personal_unlockAccount", [
                address.toLowerCase(),
                password,
                null
            ]);
        });
    }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
    sendTransaction(transaction) {
        return this.sendUncheckedTransaction(transaction).then((hash)=>{
            return {
                hash: hash,
                nonce: null,
                gasLimit: null,
                gasPrice: null,
                data: null,
                value: null,
                chainId: null,
                confirmations: 0,
                from: null,
                wait: (confirmations)=>{
                    return this.provider.waitForTransaction(hash, confirmations);
                }
            };
        });
    }
}
const allowedTransactionKeys = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true
};
class JsonRpcProvider extends (0, _baseProvider.BaseProvider) {
    constructor(url, network){
        let networkOrReady = network;
        // The network is unknown, query the JSON-RPC for it
        if (networkOrReady == null) networkOrReady = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                this.detectNetwork().then((network)=>{
                    resolve(network);
                }, (error)=>{
                    reject(error);
                });
            }, 0);
        });
        super(networkOrReady);
        // Default URL
        if (!url) url = (0, _properties.getStatic)(this.constructor, "defaultUrl")();
        if (typeof url === "string") (0, _properties.defineReadOnly)(this, "connection", Object.freeze({
            url: url
        }));
        else (0, _properties.defineReadOnly)(this, "connection", Object.freeze((0, _properties.shallowCopy)(url)));
        this._nextId = 42;
    }
    get _cache() {
        if (this._eventLoopCache == null) this._eventLoopCache = {};
        return this._eventLoopCache;
    }
    static defaultUrl() {
        return "http://localhost:8545";
    }
    detectNetwork() {
        if (!this._cache["detectNetwork"]) {
            this._cache["detectNetwork"] = this._uncachedDetectNetwork();
            // Clear this cache at the beginning of the next event loop
            setTimeout(()=>{
                this._cache["detectNetwork"] = null;
            }, 0);
        }
        return this._cache["detectNetwork"];
    }
    _uncachedDetectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            yield timer(0);
            let chainId = null;
            try {
                chainId = yield this.send("eth_chainId", []);
            } catch (error) {
                try {
                    chainId = yield this.send("net_version", []);
                } catch (error) {}
            }
            if (chainId != null) {
                const getNetwork = (0, _properties.getStatic)(this.constructor, "getNetwork");
                try {
                    return getNetwork((0, _bignumber.BigNumber).from(chainId).toNumber());
                } catch (error) {
                    return logger.throwError("could not detect network", (0, _logger.Logger).errors.NETWORK_ERROR, {
                        chainId: chainId,
                        event: "invalidNetwork",
                        serverError: error
                    });
                }
            }
            return logger.throwError("could not detect network", (0, _logger.Logger).errors.NETWORK_ERROR, {
                event: "noNetwork"
            });
        });
    }
    getSigner(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
    }
    getUncheckedSigner(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
    }
    listAccounts() {
        return this.send("eth_accounts", []).then((accounts)=>{
            return accounts.map((a)=>this.formatter.address(a));
        });
    }
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: this._nextId++,
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: (0, _properties.deepCopy)(request),
            provider: this
        });
        // We can expand this in the future to any call, but for now these
        // are the biggest wins and do not require any serializing parameters.
        const cache = [
            "eth_chainId",
            "eth_blockNumber"
        ].indexOf(method) >= 0;
        if (cache && this._cache[method]) return this._cache[method];
        const result = (0, _web.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result)=>{
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });
            return result;
        }, (error)=>{
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });
            throw error;
        });
        // Cache the fetch, but clear it on the next event loop
        if (cache) {
            this._cache[method] = result;
            setTimeout(()=>{
                this._cache[method] = null;
            }, 0);
        }
        return result;
    }
    prepareRequest(method, params) {
        switch(method){
            case "getBlockNumber":
                return [
                    "eth_blockNumber",
                    []
                ];
            case "getGasPrice":
                return [
                    "eth_gasPrice",
                    []
                ];
            case "getBalance":
                return [
                    "eth_getBalance",
                    [
                        getLowerCase(params.address),
                        params.blockTag
                    ]
                ];
            case "getTransactionCount":
                return [
                    "eth_getTransactionCount",
                    [
                        getLowerCase(params.address),
                        params.blockTag
                    ]
                ];
            case "getCode":
                return [
                    "eth_getCode",
                    [
                        getLowerCase(params.address),
                        params.blockTag
                    ]
                ];
            case "getStorageAt":
                return [
                    "eth_getStorageAt",
                    [
                        getLowerCase(params.address),
                        (0, _bytes.hexZeroPad)(params.position, 32),
                        params.blockTag
                    ]
                ];
            case "sendTransaction":
                return [
                    "eth_sendRawTransaction",
                    [
                        params.signedTransaction
                    ]
                ];
            case "getBlock":
                if (params.blockTag) return [
                    "eth_getBlockByNumber",
                    [
                        params.blockTag,
                        !!params.includeTransactions
                    ]
                ];
                else if (params.blockHash) return [
                    "eth_getBlockByHash",
                    [
                        params.blockHash,
                        !!params.includeTransactions
                    ]
                ];
                return null;
            case "getTransaction":
                return [
                    "eth_getTransactionByHash",
                    [
                        params.transactionHash
                    ]
                ];
            case "getTransactionReceipt":
                return [
                    "eth_getTransactionReceipt",
                    [
                        params.transactionHash
                    ]
                ];
            case "call":
                {
                    const hexlifyTransaction = (0, _properties.getStatic)(this.constructor, "hexlifyTransaction");
                    return [
                        "eth_call",
                        [
                            hexlifyTransaction(params.transaction, {
                                from: true
                            }),
                            params.blockTag
                        ]
                    ];
                }
            case "estimateGas":
                {
                    const hexlifyTransaction = (0, _properties.getStatic)(this.constructor, "hexlifyTransaction");
                    return [
                        "eth_estimateGas",
                        [
                            hexlifyTransaction(params.transaction, {
                                from: true
                            })
                        ]
                    ];
                }
            case "getLogs":
                if (params.filter && params.filter.address != null) params.filter.address = getLowerCase(params.filter.address);
                return [
                    "eth_getLogs",
                    [
                        params.filter
                    ]
                ];
            default:
                break;
        }
        return null;
    }
    perform(method, params) {
        return __awaiter(this, void 0, void 0, function*() {
            // Legacy networks do not like the type field being passed along (which
            // is fair), so we delete type if it is 0 and a non-EIP-1559 network
            if (method === "call" || method === "estimateGas") {
                const tx = params.transaction;
                if (tx && tx.type != null && (0, _bignumber.BigNumber).from(tx.type).isZero()) // If there are no EIP-1559 properties, it might be non-EIP-1559
                {
                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                        const feeData = yield this.getFeeData();
                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                            // Network doesn't know about EIP-1559 (and hence type)
                            params = (0, _properties.shallowCopy)(params);
                            params.transaction = (0, _properties.shallowCopy)(tx);
                            delete params.transaction.type;
                        }
                    }
                }
            }
            const args = this.prepareRequest(method, params);
            if (args == null) logger.throwError(method + " not implemented", (0, _logger.Logger).errors.NOT_IMPLEMENTED, {
                operation: method
            });
            try {
                return yield this.send(args[0], args[1]);
            } catch (error) {
                return checkError(method, error, params);
            }
        });
    }
    _startEvent(event) {
        if (event.tag === "pending") this._startPending();
        super._startEvent(event);
    }
    _startPending() {
        if (this._pendingFilter != null) return;
        const self = this;
        const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function(filterId) {
            function poll() {
                self.send("eth_getFilterChanges", [
                    filterId
                ]).then(function(hashes) {
                    if (self._pendingFilter != pendingFilter) return null;
                    let seq = Promise.resolve();
                    hashes.forEach(function(hash) {
                        // @TODO: This should be garbage collected at some point... How? When?
                        self._emitted["t:" + hash.toLowerCase()] = "pending";
                        seq = seq.then(function() {
                            return self.getTransaction(hash).then(function(tx) {
                                self.emit("pending", tx);
                                return null;
                            });
                        });
                    });
                    return seq.then(function() {
                        return timer(1000);
                    });
                }).then(function() {
                    if (self._pendingFilter != pendingFilter) {
                        self.send("eth_uninstallFilter", [
                            filterId
                        ]);
                        return;
                    }
                    setTimeout(function() {
                        poll();
                    }, 0);
                    return null;
                }).catch((error)=>{});
            }
            poll();
            return filterId;
        }).catch((error)=>{});
    }
    _stopEvent(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) this._pendingFilter = null;
        super._stopEvent(event);
    }
    // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.
    static hexlifyTransaction(transaction, allowExtra) {
        // Check only allowed properties are given
        const allowed = (0, _properties.shallowCopy)(allowedTransactionKeys);
        if (allowExtra) {
            for(const key in allowExtra)if (allowExtra[key]) allowed[key] = true;
        }
        (0, _properties.checkProperties)(transaction, allowed);
        const result = {};
        // JSON-RPC now requires numeric values to be "quantity" values
        [
            "chainId",
            "gasLimit",
            "gasPrice",
            "type",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "nonce",
            "value"
        ].forEach(function(key) {
            if (transaction[key] == null) return;
            const value = (0, _bytes.hexValue)((0, _bignumber.BigNumber).from(transaction[key]));
            if (key === "gasLimit") key = "gas";
            result[key] = value;
        });
        [
            "from",
            "to",
            "data"
        ].forEach(function(key) {
            if (transaction[key] == null) return;
            result[key] = (0, _bytes.hexlify)(transaction[key]);
        });
        if (transaction.accessList) result["accessList"] = (0, _transactions.accessListify)(transaction.accessList);
        return result;
    }
}

},{"@ethersproject/abstract-signer":"g9Ey5","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/hash":"7JYPm","@ethersproject/properties":"h3GJb","@ethersproject/strings":"5TGFZ","@ethersproject/transactions":"d1ust","@ethersproject/web":"5yjI3","@ethersproject/logger":"hLvB2","./_version":"6PYAk","./base-provider":"7OFAa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d41Wa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
//export default WS;
//module.exports = WS;
parcelHelpers.export(exports, "WebSocket", ()=>WS);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
let WS = null;
try {
    WS = WebSocket;
    if (WS == null) throw new Error("inject please");
} catch (error) {
    const logger = new (0, _logger.Logger)((0, _version.version));
    WS = function() {
        logger.throwError("WebSockets not supported in this environment", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new WebSocket()"
        });
    };
}

},{"@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9CTqA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// A StaticJsonRpcProvider is useful when you *know* for certain that
// the backend will never change, as it never calls eth_chainId to
// verify its backend. However, if the backend does change, the effects
// are undefined and may include:
// - inconsistent results
// - locking up the UI
// - block skew warnings
// - wrong results
// If the network is not explicit (i.e. auto-detection is expected), the
// node MUST be running and available to respond to requests BEFORE this
// is instantiated.
parcelHelpers.export(exports, "StaticJsonRpcProvider", ()=>StaticJsonRpcProvider);
parcelHelpers.export(exports, "UrlJsonRpcProvider", ()=>UrlJsonRpcProvider);
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _jsonRpcProvider = require("./json-rpc-provider");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
class StaticJsonRpcProvider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    detectNetwork() {
        const _super = Object.create(null, {
            detectNetwork: {
                get: ()=>super.detectNetwork
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            let network = this.network;
            if (network == null) {
                network = yield _super.detectNetwork.call(this);
                if (!network) logger.throwError("no network detected", (0, _logger.Logger).errors.UNKNOWN_ERROR, {});
                // If still not set, set it
                if (this._network == null) {
                    // A static network does not support "any"
                    (0, _properties.defineReadOnly)(this, "_network", network);
                    this.emit("network", network, null);
                }
            }
            return network;
        });
    }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
    constructor(network, apiKey){
        logger.checkAbstract(new.target, UrlJsonRpcProvider);
        // Normalize the Network and API Key
        network = (0, _properties.getStatic)(new.target, "getNetwork")(network);
        apiKey = (0, _properties.getStatic)(new.target, "getApiKey")(apiKey);
        const connection = (0, _properties.getStatic)(new.target, "getUrl")(network, apiKey);
        super(connection, network);
        if (typeof apiKey === "string") (0, _properties.defineReadOnly)(this, "apiKey", apiKey);
        else if (apiKey != null) Object.keys(apiKey).forEach((key)=>{
            (0, _properties.defineReadOnly)(this, key, apiKey[key]);
        });
    }
    _startPending() {
        logger.warn("WARNING: API provider does not support pending filters");
    }
    isCommunityResource() {
        return false;
    }
    getSigner(address) {
        return logger.throwError("API provider does not support signing", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "getSigner"
        });
    }
    listAccounts() {
        return Promise.resolve([]);
    }
    // Return a defaultApiKey if null, otherwise validate the API key
    static getApiKey(apiKey) {
        return apiKey;
    }
    // Returns the url or connection for the given network and API key. The
    // API key will have been sanitized by the getApiKey first, so any validation
    // or transformations can be done there.
    static getUrl(network, apiKey) {
        return logger.throwError("not implemented; sub-classes must override getUrl", (0, _logger.Logger).errors.NOT_IMPLEMENTED, {
            operation: "getUrl"
        });
    }
}

},{"@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"6PYAk","./json-rpc-provider":"1sWtk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cKap1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnkrProvider", ()=>AnkrProvider);
var _formatter = require("./formatter");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
const logger = new (0, _logger.Logger)((0, _version.version));
const defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
    switch(name){
        case "homestead":
            return "rpc.ankr.com/eth/";
        case "ropsten":
            return "rpc.ankr.com/eth_ropsten/";
        case "rinkeby":
            return "rpc.ankr.com/eth_rinkeby/";
        case "goerli":
            return "rpc.ankr.com/eth_goerli/";
        case "matic":
            return "rpc.ankr.com/polygon/";
        case "arbitrum":
            return "rpc.ankr.com/arbitrum/";
    }
    return logger.throwArgumentError("unsupported network", "name", name);
}
class AnkrProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    isCommunityResource() {
        return this.apiKey === defaultApiKey;
    }
    static getApiKey(apiKey) {
        if (apiKey == null) return defaultApiKey;
        return apiKey;
    }
    static getUrl(network, apiKey) {
        if (apiKey == null) apiKey = defaultApiKey;
        const connection = {
            allowGzip: true,
            url: "https://" + getHost(network.name) + apiKey,
            throttleCallback: (attempt, url)=>{
                if (apiKey.apiKey === defaultApiKey) (0, _formatter.showThrottleMessage)();
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    }
}

},{"./formatter":"ZfOHh","./url-json-rpc-provider":"9CTqA","@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9VKg2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CloudflareProvider", ()=>CloudflareProvider);
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
class CloudflareProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getApiKey(apiKey) {
        if (apiKey != null) logger.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        return null;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network.name){
            case "homestead":
                host = "https://cloudflare-eth.com/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: {
                get: ()=>super.perform
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            // The Cloudflare provider does not support eth_blockNumber,
            // so we get the latest block and pull it from that
            if (method === "getBlockNumber") {
                const block = yield _super.perform.call(this, "getBlock", {
                    blockTag: "latest"
                });
                return block.number;
            }
            return _super.perform.call(this, method, params);
        });
    }
}

},{"./url-json-rpc-provider":"9CTqA","@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"arYKc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EtherscanProvider", ()=>EtherscanProvider);
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _transactions = require("@ethersproject/transactions");
var _web = require("@ethersproject/web");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _baseProvider = require("./base-provider");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
// The transaction has already been sanitized by the calls in Provider
function getTransactionPostData(transaction) {
    const result = {};
    for(let key in transaction){
        if (transaction[key] == null) continue;
        let value = transaction[key];
        if (key === "type" && value === 0) continue;
        // Quantity-types require no leading zero, unless 0
        if (({
            type: true,
            gasLimit: true,
            gasPrice: true,
            maxFeePerGs: true,
            maxPriorityFeePerGas: true,
            nonce: true,
            value: true
        })[key]) value = (0, _bytes.hexValue)((0, _bytes.hexlify)(value));
        else if (key === "accessList") value = "[" + (0, _transactions.accessListify)(value).map((set)=>{
            return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
        else value = (0, _bytes.hexlify)(value);
        result[key] = value;
    }
    return result;
}
function getResult(result) {
    // getLogs, getHistory have weird success responses
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) return result.result;
    if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) error.throttleRetry = true;
        throw error;
    }
    return result.result;
}
function getJsonResult(result) {
    // This response indicates we are being throttled
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        const error = new Error("throttled response");
        error.result = JSON.stringify(result);
        error.throttleRetry = true;
        throw error;
    }
    if (result.jsonrpc != "2.0") {
        // @TODO: not any
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        throw error;
    }
    if (result.error) {
        // @TODO: not any
        const error = new Error(result.error.message || "unknown error");
        if (result.error.code) error.code = result.error.code;
        if (result.error.data) error.data = result.error.data;
        throw error;
    }
    return result.result;
}
// The blockTag was normalized as a string by the Provider pre-perform operations
function checkLogTag(blockTag) {
    if (blockTag === "pending") throw new Error("pending not supported");
    if (blockTag === "latest") return blockTag;
    return parseInt(blockTag.substring(2), 16);
}
function checkError(method, error, transaction) {
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call" && error.code === (0, _logger.Logger).errors.SERVER_ERROR) {
        const e = error.error;
        // Etherscan keeps changing their string
        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
            // Etherscan prefixes the data like "Reverted 0x1234"
            let data = e.data;
            if (data) data = "0x" + data.replace(/^.*0x/i, "");
            if ((0, _bytes.isHexString)(data)) return data;
            logger.throwError("missing revert data in call exception", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                error,
                data: "0x"
            });
        }
    }
    // Get the message from any nested error structure
    let message = error.message;
    if (error.code === (0, _logger.Logger).errors.SERVER_ERROR) {
        if (error.error && typeof error.error.message === "string") message = error.error.message;
        else if (typeof error.body === "string") message = error.body;
        else if (typeof error.responseText === "string") message = error.responseText;
    }
    message = (message || "").toLowerCase();
    // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"
    if (message.match(/insufficient funds/)) logger.throwError("insufficient funds for intrinsic transaction cost", (0, _logger.Logger).errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
    });
    // "Transaction with the same hash was already imported."
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) logger.throwError("nonce has already been used", (0, _logger.Logger).errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
    });
    // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."
    if (message.match(/another transaction with same nonce/)) logger.throwError("replacement fee too low", (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
    });
    if (message.match(/execution failed due to an exception|execution reverted/)) logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
    });
    throw error;
}
class EtherscanProvider extends (0, _baseProvider.BaseProvider) {
    constructor(network, apiKey){
        super(network);
        (0, _properties.defineReadOnly)(this, "baseUrl", this.getBaseUrl());
        (0, _properties.defineReadOnly)(this, "apiKey", apiKey || null);
    }
    getBaseUrl() {
        switch(this.network ? this.network.name : "invalid"){
            case "homestead":
                return "https://api.etherscan.io";
            case "goerli":
                return "https://api-goerli.etherscan.io";
            case "sepolia":
                return "https://api-sepolia.etherscan.io";
            case "matic":
                return "https://api.polygonscan.com";
            case "maticmum":
                return "https://api-testnet.polygonscan.com";
            case "arbitrum":
                return "https://api.arbiscan.io";
            case "arbitrum-goerli":
                return "https://api-goerli.arbiscan.io";
            case "optimism":
                return "https://api-optimistic.etherscan.io";
            case "optimism-goerli":
                return "https://api-goerli-optimistic.etherscan.io";
            default:
        }
        return logger.throwArgumentError("unsupported network", "network", this.network.name);
    }
    getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key)=>{
            const value = params[key];
            if (value != null) accum += `&${key}=${value}`;
            return accum;
        }, "");
        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
    }
    getPostUrl() {
        return `${this.baseUrl}/api`;
    }
    getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
    }
    fetch(module, params, post) {
        return __awaiter(this, void 0, void 0, function*() {
            const url = post ? this.getPostUrl() : this.getUrl(module, params);
            const payload = post ? this.getPostData(module, params) : null;
            const procFunc = module === "proxy" ? getJsonResult : getResult;
            this.emit("debug", {
                action: "request",
                request: url,
                provider: this
            });
            const connection = {
                url: url,
                throttleSlotInterval: 1000,
                throttleCallback: (attempt, url)=>{
                    if (this.isCommunityResource()) (0, _formatter.showThrottleMessage)();
                    return Promise.resolve(true);
                }
            };
            let payloadStr = null;
            if (payload) {
                connection.headers = {
                    "content-type": "application/x-www-form-urlencoded; charset=UTF-8"
                };
                payloadStr = Object.keys(payload).map((key)=>{
                    return `${key}=${payload[key]}`;
                }).join("&");
            }
            const result = yield (0, _web.fetchJson)(connection, payloadStr, procFunc || getJsonResult);
            this.emit("debug", {
                action: "response",
                request: url,
                response: (0, _properties.deepCopy)(result),
                provider: this
            });
            return result;
        });
    }
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.network;
        });
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: {
                get: ()=>super.perform
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            switch(method){
                case "getBlockNumber":
                    return this.fetch("proxy", {
                        action: "eth_blockNumber"
                    });
                case "getGasPrice":
                    return this.fetch("proxy", {
                        action: "eth_gasPrice"
                    });
                case "getBalance":
                    // Returns base-10 result
                    return this.fetch("account", {
                        action: "balance",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getTransactionCount":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionCount",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getCode":
                    return this.fetch("proxy", {
                        action: "eth_getCode",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getStorageAt":
                    return this.fetch("proxy", {
                        action: "eth_getStorageAt",
                        address: params.address,
                        position: params.position,
                        tag: params.blockTag
                    });
                case "sendTransaction":
                    return this.fetch("proxy", {
                        action: "eth_sendRawTransaction",
                        hex: params.signedTransaction
                    }, true).catch((error)=>{
                        return checkError("sendTransaction", error, params.signedTransaction);
                    });
                case "getBlock":
                    if (params.blockTag) return this.fetch("proxy", {
                        action: "eth_getBlockByNumber",
                        tag: params.blockTag,
                        boolean: params.includeTransactions ? "true" : "false"
                    });
                    throw new Error("getBlock by blockHash not implemented");
                case "getTransaction":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionByHash",
                        txhash: params.transactionHash
                    });
                case "getTransactionReceipt":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionReceipt",
                        txhash: params.transactionHash
                    });
                case "call":
                    {
                        if (params.blockTag !== "latest") throw new Error("EtherscanProvider does not support blockTag for call");
                        const postData = getTransactionPostData(params.transaction);
                        postData.module = "proxy";
                        postData.action = "eth_call";
                        try {
                            return yield this.fetch("proxy", postData, true);
                        } catch (error) {
                            return checkError("call", error, params.transaction);
                        }
                    }
                case "estimateGas":
                    {
                        const postData = getTransactionPostData(params.transaction);
                        postData.module = "proxy";
                        postData.action = "eth_estimateGas";
                        try {
                            return yield this.fetch("proxy", postData, true);
                        } catch (error) {
                            return checkError("estimateGas", error, params.transaction);
                        }
                    }
                case "getLogs":
                    {
                        const args = {
                            action: "getLogs"
                        };
                        if (params.filter.fromBlock) args.fromBlock = checkLogTag(params.filter.fromBlock);
                        if (params.filter.toBlock) args.toBlock = checkLogTag(params.filter.toBlock);
                        if (params.filter.address) args.address = params.filter.address;
                        // @TODO: We can handle slightly more complicated logs using the logs API
                        if (params.filter.topics && params.filter.topics.length > 0) {
                            if (params.filter.topics.length > 1) logger.throwError("unsupported topic count", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                                topics: params.filter.topics
                            });
                            if (params.filter.topics.length === 1) {
                                const topic0 = params.filter.topics[0];
                                if (typeof topic0 !== "string" || topic0.length !== 66) logger.throwError("unsupported topic format", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                                    topic0: topic0
                                });
                                args.topic0 = topic0;
                            }
                        }
                        const logs = yield this.fetch("logs", args);
                        // Cache txHash => blockHash
                        let blocks = {};
                        // Add any missing blockHash to the logs
                        for(let i = 0; i < logs.length; i++){
                            const log = logs[i];
                            if (log.blockHash != null) continue;
                            if (blocks[log.blockNumber] == null) {
                                const block = yield this.getBlock(log.blockNumber);
                                if (block) blocks[log.blockNumber] = block.hash;
                            }
                            log.blockHash = blocks[log.blockNumber];
                        }
                        return logs;
                    }
                case "getEtherPrice":
                    if (this.network.name !== "homestead") return 0.0;
                    return parseFloat((yield this.fetch("stats", {
                        action: "ethprice"
                    })).ethusd);
                default:
                    break;
            }
            return _super.perform.call(this, method, params);
        });
    }
    // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000
    getHistory(addressOrName, startBlock, endBlock) {
        return __awaiter(this, void 0, void 0, function*() {
            const params = {
                action: "txlist",
                address: yield this.resolveName(addressOrName),
                startblock: startBlock == null ? 0 : startBlock,
                endblock: endBlock == null ? 99999999 : endBlock,
                sort: "asc"
            };
            const result = yield this.fetch("account", params);
            return result.map((tx)=>{
                [
                    "contractAddress",
                    "to"
                ].forEach(function(key) {
                    if (tx[key] == "") delete tx[key];
                });
                if (tx.creates == null && tx.contractAddress != null) tx.creates = tx.contractAddress;
                const item = this.formatter.transactionResponse(tx);
                if (tx.timeStamp) item.timestamp = parseInt(tx.timeStamp);
                return item;
            });
        });
    }
    isCommunityResource() {
        return this.apiKey == null;
    }
}

},{"@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@ethersproject/transactions":"d1ust","@ethersproject/web":"5yjI3","./formatter":"ZfOHh","@ethersproject/logger":"hLvB2","./_version":"6PYAk","./base-provider":"7OFAa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2wNFK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FallbackProvider", ()=>FallbackProvider);
var _abstractProvider = require("@ethersproject/abstract-provider");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _random = require("@ethersproject/random");
var _web = require("@ethersproject/web");
var _baseProvider = require("./base-provider");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
function now() {
    return new Date().getTime();
}
// Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.
function checkNetworks(networks) {
    let result = null;
    for(let i = 0; i < networks.length; i++){
        const network = networks[i];
        // Null! We do not know our network; bail.
        if (network == null) return null;
        if (result) // Make sure the network matches the previous networks
        {
            if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) logger.throwArgumentError("provider mismatch", "networks", networks);
        } else result = network;
    }
    return result;
}
function median(values, maxDelta) {
    values = values.slice().sort();
    const middle = Math.floor(values.length / 2);
    // Odd length; take the middle
    if (values.length % 2) return values[middle];
    // Even length; take the average of the two middle
    const a = values[middle - 1], b = values[middle];
    if (maxDelta != null && Math.abs(a - b) > maxDelta) return null;
    return (a + b) / 2;
}
function serialize(value) {
    if (value === null) return "null";
    else if (typeof value === "number" || typeof value === "boolean") return JSON.stringify(value);
    else if (typeof value === "string") return value;
    else if ((0, _bignumber.BigNumber).isBigNumber(value)) return value.toString();
    else if (Array.isArray(value)) return JSON.stringify(value.map((i)=>serialize(i)));
    else if (typeof value === "object") {
        const keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map((key)=>{
            let v = value[key];
            if (typeof v === "function") v = "[function]";
            else v = serialize(v);
            return JSON.stringify(key) + ":" + v;
        }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof value);
}
// Next request ID to use for emitting debug info
let nextRid = 1;
function stall(duration) {
    let cancel = null;
    let timer = null;
    let promise = new Promise((resolve)=>{
        cancel = function() {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            resolve();
        };
        timer = setTimeout(cancel, duration);
    });
    const wait = (func)=>{
        promise = promise.then(func);
        return promise;
    };
    function getPromise() {
        return promise;
    }
    return {
        cancel,
        getPromise,
        wait
    };
}
const ForwardErrors = [
    (0, _logger.Logger).errors.CALL_EXCEPTION,
    (0, _logger.Logger).errors.INSUFFICIENT_FUNDS,
    (0, _logger.Logger).errors.NONCE_EXPIRED,
    (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED,
    (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT
];
const ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction"
];
function exposeDebugConfig(config, now) {
    const result = {
        weight: config.weight
    };
    Object.defineProperty(result, "provider", {
        get: ()=>config.provider
    });
    if (config.start) result.start = config.start;
    if (now) result.duration = now - config.start;
    if (config.done) {
        if (config.error) result.error = config.error;
        else result.result = config.result || null;
    }
    return result;
}
function normalizedTally(normalize, quorum) {
    return function(configs) {
        // Count the votes for each result
        const tally = {};
        configs.forEach((c)=>{
            const value = normalize(c.result);
            if (!tally[value]) tally[value] = {
                count: 0,
                result: c.result
            };
            tally[value].count++;
        });
        // Check for a quorum on any given result
        const keys = Object.keys(tally);
        for(let i = 0; i < keys.length; i++){
            const check = tally[keys[i]];
            if (check.count >= quorum) return check.result;
        }
        // No quroum
        return undefined;
    };
}
function getProcessFunc(provider, method, params) {
    let normalize = serialize;
    switch(method){
        case "getBlockNumber":
            // Return the median value, unless there is (median + 1) is also
            // present, in which case that is probably true and the median
            // is going to be stale soon. In the event of a malicious node,
            // the lie will be true soon enough.
            return function(configs) {
                const values = configs.map((c)=>c.result);
                // Get the median block number
                let blockNumber = median(configs.map((c)=>c.result), 2);
                if (blockNumber == null) return undefined;
                blockNumber = Math.ceil(blockNumber);
                // If the next block height is present, its prolly safe to use
                if (values.indexOf(blockNumber + 1) >= 0) blockNumber++;
                // Don't ever roll back the blockNumber
                if (blockNumber >= provider._highestBlockNumber) provider._highestBlockNumber = blockNumber;
                return provider._highestBlockNumber;
            };
        case "getGasPrice":
            // Return the middle (round index up) value, similar to median
            // but do not average even entries and choose the higher.
            // Malicious actors must compromise 50% of the nodes to lie.
            return function(configs) {
                const values = configs.map((c)=>c.result);
                values.sort();
                return values[Math.floor(values.length / 2)];
            };
        case "getEtherPrice":
            // Returns the median price. Malicious actors must compromise at
            // least 50% of the nodes to lie (in a meaningful way).
            return function(configs) {
                return median(configs.map((c)=>c.result));
            };
        // No additional normalizing required; serialize is enough
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getTransaction":
        case "getTransactionReceipt":
            normalize = function(tx) {
                if (tx == null) return null;
                tx = (0, _properties.shallowCopy)(tx);
                tx.confirmations = -1;
                return serialize(tx);
            };
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getBlock":
            // We drop the confirmations from transactions as it is approximate
            if (params.includeTransactions) normalize = function(block) {
                if (block == null) return null;
                block = (0, _properties.shallowCopy)(block);
                block.transactions = block.transactions.map((tx)=>{
                    tx = (0, _properties.shallowCopy)(tx);
                    tx.confirmations = -1;
                    return tx;
                });
                return serialize(block);
            };
            else normalize = function(block) {
                if (block == null) return null;
                return serialize(block);
            };
            break;
        default:
            throw new Error("unknown method: " + method);
    }
    // Return the result if and only if the expected quorum is
    // satisfied and agreed upon for the final result.
    return normalizedTally(normalize, provider.quorum);
}
// If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.
function waitForSync(config, blockNumber) {
    return __awaiter(this, void 0, void 0, function*() {
        const provider = config.provider;
        if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) return provider;
        return (0, _web.poll)(()=>{
            return new Promise((resolve, reject)=>{
                setTimeout(function() {
                    // We are synced
                    if (provider.blockNumber >= blockNumber) return resolve(provider);
                    // We're done; just quit
                    if (config.cancelled) return resolve(null);
                    // Try again, next block
                    return resolve(undefined);
                }, 0);
            });
        }, {
            oncePoll: provider
        });
    });
}
function getRunner(config, currentBlockNumber, method, params) {
    return __awaiter(this, void 0, void 0, function*() {
        let provider = config.provider;
        switch(method){
            case "getBlockNumber":
            case "getGasPrice":
                return provider[method]();
            case "getEtherPrice":
                if (provider.getEtherPrice) return provider.getEtherPrice();
                break;
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                return provider[method](params.address, params.blockTag || "latest");
            case "getStorageAt":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
            case "getBlock":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
            case "call":
            case "estimateGas":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                if (method === "call" && params.blockTag) return provider[method](params.transaction, params.blockTag);
                return provider[method](params.transaction);
            case "getTransaction":
            case "getTransactionReceipt":
                return provider[method](params.transactionHash);
            case "getLogs":
                {
                    let filter = params.filter;
                    if (filter.fromBlock && (0, _bytes.isHexString)(filter.fromBlock) || filter.toBlock && (0, _bytes.isHexString)(filter.toBlock)) provider = yield waitForSync(config, currentBlockNumber);
                    return provider.getLogs(filter);
                }
        }
        return logger.throwError("unknown method error", (0, _logger.Logger).errors.UNKNOWN_ERROR, {
            method: method,
            params: params
        });
    });
}
class FallbackProvider extends (0, _baseProvider.BaseProvider) {
    constructor(providers, quorum){
        if (providers.length === 0) logger.throwArgumentError("missing providers", "providers", providers);
        const providerConfigs = providers.map((configOrProvider, index)=>{
            if ((0, _abstractProvider.Provider).isProvider(configOrProvider)) {
                const stallTimeout = (0, _formatter.isCommunityResource)(configOrProvider) ? 2000 : 750;
                const priority = 1;
                return Object.freeze({
                    provider: configOrProvider,
                    weight: 1,
                    stallTimeout,
                    priority
                });
            }
            const config = (0, _properties.shallowCopy)(configOrProvider);
            if (config.priority == null) config.priority = 1;
            if (config.stallTimeout == null) config.stallTimeout = (0, _formatter.isCommunityResource)(configOrProvider) ? 2000 : 750;
            if (config.weight == null) config.weight = 1;
            const weight = config.weight;
            if (weight % 1 || weight > 512 || weight < 1) logger.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
            return Object.freeze(config);
        });
        const total = providerConfigs.reduce((accum, c)=>accum + c.weight, 0);
        if (quorum == null) quorum = total / 2;
        else if (quorum > total) logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        // Are all providers' networks are known
        let networkOrReady = checkNetworks(providerConfigs.map((c)=>c.provider.network));
        // Not all networks are known; we must stall
        if (networkOrReady == null) networkOrReady = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                this.detectNetwork().then(resolve, reject);
            }, 0);
        });
        super(networkOrReady);
        // Preserve a copy, so we do not get mutated
        (0, _properties.defineReadOnly)(this, "providerConfigs", Object.freeze(providerConfigs));
        (0, _properties.defineReadOnly)(this, "quorum", quorum);
        this._highestBlockNumber = -1;
    }
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            const networks = yield Promise.all(this.providerConfigs.map((c)=>c.provider.getNetwork()));
            return checkNetworks(networks);
        });
    }
    perform(method, params) {
        return __awaiter(this, void 0, void 0, function*() {
            // Sending transactions is special; always broadcast it to all backends
            if (method === "sendTransaction") {
                const results = yield Promise.all(this.providerConfigs.map((c)=>{
                    return c.provider.sendTransaction(params.signedTransaction).then((result)=>{
                        return result.hash;
                    }, (error)=>{
                        return error;
                    });
                }));
                // Any success is good enough (other errors are likely "already seen" errors
                for(let i = 0; i < results.length; i++){
                    const result = results[i];
                    if (typeof result === "string") return result;
                }
                // They were all an error; pick the first error
                throw results[0];
            }
            // We need to make sure we are in sync with our backends, so we need
            // to know this before we can make a lot of calls
            if (this._highestBlockNumber === -1 && method !== "getBlockNumber") yield this.getBlockNumber();
            const processFunc = getProcessFunc(this, method, params);
            // Shuffle the providers and then sort them by their priority; we
            // shallowCopy them since we will store the result in them too
            const configs = (0, _random.shuffled)(this.providerConfigs.map((0, _properties.shallowCopy)));
            configs.sort((a, b)=>a.priority - b.priority);
            const currentBlockNumber = this._highestBlockNumber;
            let i = 0;
            let first = true;
            while(true){
                const t0 = now();
                // Compute the inflight weight (exclude anything past)
                let inflightWeight = configs.filter((c)=>c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c)=>accum + c.weight, 0);
                // Start running enough to meet quorum
                while(inflightWeight < this.quorum && i < configs.length){
                    const config = configs[i++];
                    const rid = nextRid++;
                    config.start = now();
                    config.staller = stall(config.stallTimeout);
                    config.staller.wait(()=>{
                        config.staller = null;
                    });
                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result)=>{
                        config.done = true;
                        config.result = result;
                        if (this.listenerCount("debug")) this.emit("debug", {
                            action: "request",
                            rid: rid,
                            backend: exposeDebugConfig(config, now()),
                            request: {
                                method: method,
                                params: (0, _properties.deepCopy)(params)
                            },
                            provider: this
                        });
                    }, (error)=>{
                        config.done = true;
                        config.error = error;
                        if (this.listenerCount("debug")) this.emit("debug", {
                            action: "request",
                            rid: rid,
                            backend: exposeDebugConfig(config, now()),
                            request: {
                                method: method,
                                params: (0, _properties.deepCopy)(params)
                            },
                            provider: this
                        });
                    });
                    if (this.listenerCount("debug")) this.emit("debug", {
                        action: "request",
                        rid: rid,
                        backend: exposeDebugConfig(config, null),
                        request: {
                            method: method,
                            params: (0, _properties.deepCopy)(params)
                        },
                        provider: this
                    });
                    inflightWeight += config.weight;
                }
                // Wait for anything meaningful to finish or stall out
                const waiting = [];
                configs.forEach((c)=>{
                    if (c.done || !c.runner) return;
                    waiting.push(c.runner);
                    if (c.staller) waiting.push(c.staller.getPromise());
                });
                if (waiting.length) yield Promise.race(waiting);
                // Check the quorum and process the results; the process function
                // may additionally decide the quorum is not met
                const results = configs.filter((c)=>c.done && c.error == null);
                if (results.length >= this.quorum) {
                    const result = processFunc(results);
                    if (result !== undefined) {
                        // Shut down any stallers
                        configs.forEach((c)=>{
                            if (c.staller) c.staller.cancel();
                            c.cancelled = true;
                        });
                        return result;
                    }
                    if (!first) yield stall(100).getPromise();
                    first = false;
                }
                // No result, check for errors that should be forwarded
                const errors = configs.reduce((accum, c)=>{
                    if (!c.done || c.error == null) return accum;
                    const code = c.error.code;
                    if (ForwardErrors.indexOf(code) >= 0) {
                        if (!accum[code]) accum[code] = {
                            error: c.error,
                            weight: 0
                        };
                        accum[code].weight += c.weight;
                    }
                    return accum;
                }, {});
                Object.keys(errors).forEach((errorCode)=>{
                    const tally = errors[errorCode];
                    if (tally.weight < this.quorum) return;
                    // Shut down any stallers
                    configs.forEach((c)=>{
                        if (c.staller) c.staller.cancel();
                        c.cancelled = true;
                    });
                    const e = tally.error;
                    const props = {};
                    ForwardProperties.forEach((name)=>{
                        if (e[name] == null) return;
                        props[name] = e[name];
                    });
                    logger.throwError(e.reason || e.message, errorCode, props);
                });
                // All configs have run to completion; we will never get more data
                if (configs.filter((c)=>!c.done).length === 0) break;
            }
            // Shut down any stallers; shouldn't be any
            configs.forEach((c)=>{
                if (c.staller) c.staller.cancel();
                c.cancelled = true;
            });
            return logger.throwError("failed to meet quorum", (0, _logger.Logger).errors.SERVER_ERROR, {
                method: method,
                params: params,
                //results: configs.map((c) => c.result),
                //errors: configs.map((c) => c.error),
                results: configs.map((c)=>exposeDebugConfig(c)),
                provider: this
            });
        });
    }
}

},{"@ethersproject/abstract-provider":"g1jr1","@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/properties":"h3GJb","@ethersproject/random":"7myQM","@ethersproject/web":"5yjI3","./base-provider":"7OFAa","./formatter":"ZfOHh","@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6WQjk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IpcProvider", ()=>IpcProvider);
"use strict";
const IpcProvider = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iqlOM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InfuraWebSocketProvider", ()=>InfuraWebSocketProvider);
parcelHelpers.export(exports, "InfuraProvider", ()=>InfuraProvider);
var _properties = require("@ethersproject/properties");
var _websocketProvider = require("./websocket-provider");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends (0, _websocketProvider.WebSocketProvider) {
    constructor(network, apiKey){
        const provider = new InfuraProvider(network, apiKey);
        const connection = provider.connection;
        if (connection.password) logger.throwError("INFURA WebSocket project secrets unsupported", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "InfuraProvider.getWebSocketProvider()"
        });
        const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, network);
        (0, _properties.defineReadOnly)(this, "apiKey", provider.projectId);
        (0, _properties.defineReadOnly)(this, "projectId", provider.projectId);
        (0, _properties.defineReadOnly)(this, "projectSecret", provider.projectSecret);
    }
    isCommunityResource() {
        return this.projectId === defaultProjectId;
    }
}
class InfuraProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getWebSocketProvider(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        const apiKeyObj = {
            apiKey: defaultProjectId,
            projectId: defaultProjectId,
            projectSecret: null
        };
        if (apiKey == null) return apiKeyObj;
        if (typeof apiKey === "string") apiKeyObj.projectId = apiKey;
        else if (apiKey.projectSecret != null) {
            logger.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
            logger.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
            apiKeyObj.projectId = apiKey.projectId;
            apiKeyObj.projectSecret = apiKey.projectSecret;
        } else if (apiKey.projectId) apiKeyObj.projectId = apiKey.projectId;
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network ? network.name : "unknown"){
            case "homestead":
                host = "mainnet.infura.io";
                break;
            case "goerli":
                host = "goerli.infura.io";
                break;
            case "sepolia":
                host = "sepolia.infura.io";
                break;
            case "matic":
                host = "polygon-mainnet.infura.io";
                break;
            case "maticmum":
                host = "polygon-mumbai.infura.io";
                break;
            case "optimism":
                host = "optimism-mainnet.infura.io";
                break;
            case "optimism-goerli":
                host = "optimism-goerli.infura.io";
                break;
            case "arbitrum":
                host = "arbitrum-mainnet.infura.io";
                break;
            case "arbitrum-goerli":
                host = "arbitrum-goerli.infura.io";
                break;
            default:
                logger.throwError("unsupported network", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        const connection = {
            allowGzip: true,
            url: "https://" + host + "/v3/" + apiKey.projectId,
            throttleCallback: (attempt, url)=>{
                if (apiKey.projectId === defaultProjectId) (0, _formatter.showThrottleMessage)();
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    }
    isCommunityResource() {
        return this.projectId === defaultProjectId;
    }
}

},{"@ethersproject/properties":"h3GJb","./websocket-provider":"9KF9f","./formatter":"ZfOHh","@ethersproject/logger":"hLvB2","./_version":"6PYAk","./url-json-rpc-provider":"9CTqA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hGNo4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Experimental
parcelHelpers.export(exports, "JsonRpcBatchProvider", ()=>JsonRpcBatchProvider);
var _properties = require("@ethersproject/properties");
var _web = require("@ethersproject/web");
var _jsonRpcProvider = require("./json-rpc-provider");
class JsonRpcBatchProvider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: this._nextId++,
            jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) this._pendingBatch = [];
        const inflightRequest = {
            request,
            resolve: null,
            reject: null
        };
        const promise = new Promise((resolve, reject)=>{
            inflightRequest.resolve = resolve;
            inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) // Schedule batch for next event loop + short duration
        this._pendingBatchAggregator = setTimeout(()=>{
            // Get teh current batch and clear it, so new requests
            // go into the next batch
            const batch = this._pendingBatch;
            this._pendingBatch = null;
            this._pendingBatchAggregator = null;
            // Get the request as an array of requests
            const request = batch.map((inflight)=>inflight.request);
            this.emit("debug", {
                action: "requestBatch",
                request: (0, _properties.deepCopy)(request),
                provider: this
            });
            return (0, _web.fetchJson)(this.connection, JSON.stringify(request)).then((result)=>{
                this.emit("debug", {
                    action: "response",
                    request: request,
                    response: result,
                    provider: this
                });
                // For each result, feed it to the correct Promise, depending
                // on whether it was a success or error
                batch.forEach((inflightRequest, index)=>{
                    const payload = result[index];
                    if (payload.error) {
                        const error = new Error(payload.error.message);
                        error.code = payload.error.code;
                        error.data = payload.error.data;
                        inflightRequest.reject(error);
                    } else inflightRequest.resolve(payload.result);
                });
            }, (error)=>{
                this.emit("debug", {
                    action: "response",
                    error: error,
                    request: request,
                    provider: this
                });
                batch.forEach((inflightRequest)=>{
                    inflightRequest.reject(error);
                });
            });
        }, 10);
        return promise;
    }
}

},{"@ethersproject/properties":"h3GJb","@ethersproject/web":"5yjI3","./json-rpc-provider":"1sWtk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8l5lW":[function(require,module,exports) {
/* istanbul ignore file */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NodesmithProvider", ()=>NodesmithProvider);
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
// Special API key provided by Nodesmith for ethers.js
const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getApiKey(apiKey) {
        if (apiKey && typeof apiKey !== "string") logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        return apiKey || defaultApiKey;
    }
    static getUrl(network, apiKey) {
        logger.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        let host = null;
        switch(network.name){
            case "homestead":
                host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
                break;
            case "ropsten":
                host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
                break;
            case "rinkeby":
                host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
                break;
            case "goerli":
                host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
                break;
            case "kovan":
                host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host + "?apiKey=" + apiKey;
    }
}

},{"./url-json-rpc-provider":"9CTqA","@ethersproject/logger":"hLvB2","./_version":"6PYAk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3a8Ys":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PocketProvider", ()=>PocketProvider);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
class PocketProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getApiKey(apiKey) {
        const apiKeyObj = {
            applicationId: null,
            loadBalancer: true,
            applicationSecretKey: null
        };
        // Parse applicationId and applicationSecretKey
        if (apiKey == null) apiKeyObj.applicationId = defaultApplicationId;
        else if (typeof apiKey === "string") apiKeyObj.applicationId = apiKey;
        else if (apiKey.applicationSecretKey != null) {
            apiKeyObj.applicationId = apiKey.applicationId;
            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
        } else if (apiKey.applicationId) apiKeyObj.applicationId = apiKey.applicationId;
        else logger.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network ? network.name : "unknown"){
            case "goerli":
                host = "eth-goerli.gateway.pokt.network";
                break;
            case "homestead":
                host = "eth-mainnet.gateway.pokt.network";
                break;
            case "kovan":
                host = "poa-kovan.gateway.pokt.network";
                break;
            case "matic":
                host = "poly-mainnet.gateway.pokt.network";
                break;
            case "maticmum":
                host = "polygon-mumbai-rpc.gateway.pokt.network";
                break;
            case "rinkeby":
                host = "eth-rinkeby.gateway.pokt.network";
                break;
            case "ropsten":
                host = "eth-ropsten.gateway.pokt.network";
                break;
            default:
                logger.throwError("unsupported network", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        const url = `https:/\/${host}/v1/lb/${apiKey.applicationId}`;
        const connection = {
            headers: {},
            url
        };
        if (apiKey.applicationSecretKey != null) {
            connection.user = "";
            connection.password = apiKey.applicationSecretKey;
        }
        return connection;
    }
    isCommunityResource() {
        return this.applicationId === defaultApplicationId;
    }
}

},{"@ethersproject/logger":"hLvB2","./_version":"6PYAk","./url-json-rpc-provider":"9CTqA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIjQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Web3Provider", ()=>Web3Provider);
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _jsonRpcProvider = require("./json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
    const fetcher = "Web3LegacyFetcher";
    return function(method, params) {
        const request = {
            method: method,
            params: params,
            id: _nextId++,
            jsonrpc: "2.0"
        };
        return new Promise((resolve, reject)=>{
            this.emit("debug", {
                action: "request",
                fetcher,
                request: (0, _properties.deepCopy)(request),
                provider: this
            });
            sendFunc(request, (error, response)=>{
                if (error) {
                    this.emit("debug", {
                        action: "response",
                        fetcher,
                        error,
                        request,
                        provider: this
                    });
                    return reject(error);
                }
                this.emit("debug", {
                    action: "response",
                    fetcher,
                    request,
                    response,
                    provider: this
                });
                if (response.error) {
                    const error = new Error(response.error.message);
                    error.code = response.error.code;
                    error.data = response.error.data;
                    return reject(error);
                }
                resolve(response.result);
            });
        });
    };
}
function buildEip1193Fetcher(provider) {
    return function(method, params) {
        if (params == null) params = [];
        const request = {
            method,
            params
        };
        this.emit("debug", {
            action: "request",
            fetcher: "Eip1193Fetcher",
            request: (0, _properties.deepCopy)(request),
            provider: this
        });
        return provider.request(request).then((response)=>{
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                response,
                provider: this
            });
            return response;
        }, (error)=>{
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                error,
                provider: this
            });
            throw error;
        });
    };
}
class Web3Provider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    constructor(provider, network){
        if (provider == null) logger.throwArgumentError("missing provider", "provider", provider);
        let path = null;
        let jsonRpcFetchFunc = null;
        let subprovider = null;
        if (typeof provider === "function") {
            path = "unknown:";
            jsonRpcFetchFunc = provider;
        } else {
            path = provider.host || provider.path || "";
            if (!path && provider.isMetaMask) path = "metamask";
            subprovider = provider;
            if (provider.request) {
                if (path === "") path = "eip-1193:";
                jsonRpcFetchFunc = buildEip1193Fetcher(provider);
            } else if (provider.sendAsync) jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
            else if (provider.send) jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
            else logger.throwArgumentError("unsupported provider", "provider", provider);
            if (!path) path = "unknown:";
        }
        super(path, network);
        (0, _properties.defineReadOnly)(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        (0, _properties.defineReadOnly)(this, "provider", subprovider);
    }
    send(method, params) {
        return this.jsonRpcFetchFunc(method, params);
    }
}

},{"@ethersproject/properties":"h3GJb","@ethersproject/logger":"hLvB2","./_version":"6PYAk","./json-rpc-provider":"1sWtk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VLBZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
////////////////////////
// Exports
parcelHelpers.export(exports, "AbiCoder", ()=>(0, _abi.AbiCoder));
parcelHelpers.export(exports, "defaultAbiCoder", ()=>(0, _abi.defaultAbiCoder));
parcelHelpers.export(exports, "Fragment", ()=>(0, _abi.Fragment));
parcelHelpers.export(exports, "ConstructorFragment", ()=>(0, _abi.ConstructorFragment));
parcelHelpers.export(exports, "ErrorFragment", ()=>(0, _abi.ErrorFragment));
parcelHelpers.export(exports, "EventFragment", ()=>(0, _abi.EventFragment));
parcelHelpers.export(exports, "FunctionFragment", ()=>(0, _abi.FunctionFragment));
parcelHelpers.export(exports, "ParamType", ()=>(0, _abi.ParamType));
parcelHelpers.export(exports, "FormatTypes", ()=>(0, _abi.FormatTypes));
parcelHelpers.export(exports, "checkResultErrors", ()=>(0, _abi.checkResultErrors));
parcelHelpers.export(exports, "Logger", ()=>(0, _logger.Logger));
parcelHelpers.export(exports, "RLP", ()=>_rlp);
parcelHelpers.export(exports, "_fetchData", ()=>(0, _web._fetchData));
parcelHelpers.export(exports, "fetchJson", ()=>(0, _web.fetchJson));
parcelHelpers.export(exports, "poll", ()=>(0, _web.poll));
parcelHelpers.export(exports, "checkProperties", ()=>(0, _properties.checkProperties));
parcelHelpers.export(exports, "deepCopy", ()=>(0, _properties.deepCopy));
parcelHelpers.export(exports, "defineReadOnly", ()=>(0, _properties.defineReadOnly));
parcelHelpers.export(exports, "getStatic", ()=>(0, _properties.getStatic));
parcelHelpers.export(exports, "resolveProperties", ()=>(0, _properties.resolveProperties));
parcelHelpers.export(exports, "shallowCopy", ()=>(0, _properties.shallowCopy));
parcelHelpers.export(exports, "arrayify", ()=>(0, _bytes.arrayify));
parcelHelpers.export(exports, "concat", ()=>(0, _bytes.concat));
parcelHelpers.export(exports, "stripZeros", ()=>(0, _bytes.stripZeros));
parcelHelpers.export(exports, "zeroPad", ()=>(0, _bytes.zeroPad));
parcelHelpers.export(exports, "isBytes", ()=>(0, _bytes.isBytes));
parcelHelpers.export(exports, "isBytesLike", ()=>(0, _bytes.isBytesLike));
parcelHelpers.export(exports, "defaultPath", ()=>(0, _hdnode.defaultPath));
parcelHelpers.export(exports, "HDNode", ()=>(0, _hdnode.HDNode));
parcelHelpers.export(exports, "SigningKey", ()=>(0, _signingKey.SigningKey));
parcelHelpers.export(exports, "Interface", ()=>(0, _abi.Interface));
parcelHelpers.export(exports, "LogDescription", ()=>(0, _abi.LogDescription));
parcelHelpers.export(exports, "TransactionDescription", ()=>(0, _abi.TransactionDescription));
parcelHelpers.export(exports, "base58", ()=>(0, _basex.Base58));
parcelHelpers.export(exports, "base64", ()=>_base64);
parcelHelpers.export(exports, "hexlify", ()=>(0, _bytes.hexlify));
parcelHelpers.export(exports, "isHexString", ()=>(0, _bytes.isHexString));
parcelHelpers.export(exports, "hexConcat", ()=>(0, _bytes.hexConcat));
parcelHelpers.export(exports, "hexStripZeros", ()=>(0, _bytes.hexStripZeros));
parcelHelpers.export(exports, "hexValue", ()=>(0, _bytes.hexValue));
parcelHelpers.export(exports, "hexZeroPad", ()=>(0, _bytes.hexZeroPad));
parcelHelpers.export(exports, "hexDataLength", ()=>(0, _bytes.hexDataLength));
parcelHelpers.export(exports, "hexDataSlice", ()=>(0, _bytes.hexDataSlice));
parcelHelpers.export(exports, "nameprep", ()=>(0, _strings.nameprep));
parcelHelpers.export(exports, "_toEscapedUtf8String", ()=>(0, _strings._toEscapedUtf8String));
parcelHelpers.export(exports, "toUtf8Bytes", ()=>(0, _strings.toUtf8Bytes));
parcelHelpers.export(exports, "toUtf8CodePoints", ()=>(0, _strings.toUtf8CodePoints));
parcelHelpers.export(exports, "toUtf8String", ()=>(0, _strings.toUtf8String));
parcelHelpers.export(exports, "Utf8ErrorFuncs", ()=>(0, _strings.Utf8ErrorFuncs));
parcelHelpers.export(exports, "formatBytes32String", ()=>(0, _strings.formatBytes32String));
parcelHelpers.export(exports, "parseBytes32String", ()=>(0, _strings.parseBytes32String));
parcelHelpers.export(exports, "dnsEncode", ()=>(0, _hash.dnsEncode));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _hash.hashMessage));
parcelHelpers.export(exports, "namehash", ()=>(0, _hash.namehash));
parcelHelpers.export(exports, "isValidName", ()=>(0, _hash.isValidName));
parcelHelpers.export(exports, "id", ()=>(0, _hash.id));
parcelHelpers.export(exports, "_TypedDataEncoder", ()=>(0, _hash._TypedDataEncoder));
parcelHelpers.export(exports, "getAddress", ()=>(0, _address.getAddress));
parcelHelpers.export(exports, "getIcapAddress", ()=>(0, _address.getIcapAddress));
parcelHelpers.export(exports, "getContractAddress", ()=>(0, _address.getContractAddress));
parcelHelpers.export(exports, "getCreate2Address", ()=>(0, _address.getCreate2Address));
parcelHelpers.export(exports, "isAddress", ()=>(0, _address.isAddress));
parcelHelpers.export(exports, "formatEther", ()=>(0, _units.formatEther));
parcelHelpers.export(exports, "parseEther", ()=>(0, _units.parseEther));
parcelHelpers.export(exports, "formatUnits", ()=>(0, _units.formatUnits));
parcelHelpers.export(exports, "parseUnits", ()=>(0, _units.parseUnits));
parcelHelpers.export(exports, "commify", ()=>(0, _units.commify));
parcelHelpers.export(exports, "computeHmac", ()=>(0, _sha2.computeHmac));
parcelHelpers.export(exports, "keccak256", ()=>(0, _keccak256.keccak256));
parcelHelpers.export(exports, "ripemd160", ()=>(0, _sha2.ripemd160));
parcelHelpers.export(exports, "sha256", ()=>(0, _sha2.sha256));
parcelHelpers.export(exports, "sha512", ()=>(0, _sha2.sha512));
parcelHelpers.export(exports, "randomBytes", ()=>(0, _random.randomBytes));
parcelHelpers.export(exports, "shuffled", ()=>(0, _random.shuffled));
parcelHelpers.export(exports, "solidityPack", ()=>(0, _solidity.pack));
parcelHelpers.export(exports, "solidityKeccak256", ()=>(0, _solidity.keccak256));
parcelHelpers.export(exports, "soliditySha256", ()=>(0, _solidity.sha256));
parcelHelpers.export(exports, "splitSignature", ()=>(0, _bytes.splitSignature));
parcelHelpers.export(exports, "joinSignature", ()=>(0, _bytes.joinSignature));
parcelHelpers.export(exports, "accessListify", ()=>(0, _transactions.accessListify));
parcelHelpers.export(exports, "parseTransaction", ()=>(0, _transactions.parse));
parcelHelpers.export(exports, "serializeTransaction", ()=>(0, _transactions.serialize));
parcelHelpers.export(exports, "TransactionTypes", ()=>(0, _transactions.TransactionTypes));
parcelHelpers.export(exports, "getJsonWalletAddress", ()=>(0, _jsonWallets.getJsonWalletAddress));
parcelHelpers.export(exports, "computeAddress", ()=>(0, _transactions.computeAddress));
parcelHelpers.export(exports, "recoverAddress", ()=>(0, _transactions.recoverAddress));
parcelHelpers.export(exports, "computePublicKey", ()=>(0, _signingKey.computePublicKey));
parcelHelpers.export(exports, "recoverPublicKey", ()=>(0, _signingKey.recoverPublicKey));
parcelHelpers.export(exports, "verifyMessage", ()=>(0, _wallet.verifyMessage));
parcelHelpers.export(exports, "verifyTypedData", ()=>(0, _wallet.verifyTypedData));
parcelHelpers.export(exports, "getAccountPath", ()=>(0, _hdnode.getAccountPath));
parcelHelpers.export(exports, "mnemonicToEntropy", ()=>(0, _hdnode.mnemonicToEntropy));
parcelHelpers.export(exports, "entropyToMnemonic", ()=>(0, _hdnode.entropyToMnemonic));
parcelHelpers.export(exports, "isValidMnemonic", ()=>(0, _hdnode.isValidMnemonic));
parcelHelpers.export(exports, "mnemonicToSeed", ()=>(0, _hdnode.mnemonicToSeed));
parcelHelpers.export(exports, "SupportedAlgorithm", ()=>////////////////////////
    // Enums
    (0, _sha2.SupportedAlgorithm));
parcelHelpers.export(exports, "UnicodeNormalizationForm", ()=>(0, _strings.UnicodeNormalizationForm));
parcelHelpers.export(exports, "Utf8ErrorReason", ()=>(0, _strings.Utf8ErrorReason));
parcelHelpers.export(exports, "Indexed", ()=>(0, _abi.Indexed));
var _abi = require("@ethersproject/abi");
var _address = require("@ethersproject/address");
var _base64 = require("@ethersproject/base64");
var _basex = require("@ethersproject/basex");
var _bytes = require("@ethersproject/bytes");
var _hash = require("@ethersproject/hash");
var _hdnode = require("@ethersproject/hdnode");
var _jsonWallets = require("@ethersproject/json-wallets");
var _keccak256 = require("@ethersproject/keccak256");
var _logger = require("@ethersproject/logger");
var _sha2 = require("@ethersproject/sha2");
var _solidity = require("@ethersproject/solidity");
var _random = require("@ethersproject/random");
var _properties = require("@ethersproject/properties");
var _rlp = require("@ethersproject/rlp");
var _signingKey = require("@ethersproject/signing-key");
var _strings = require("@ethersproject/strings");
var _transactions = require("@ethersproject/transactions");
var _units = require("@ethersproject/units");
var _wallet = require("@ethersproject/wallet");
var _web = require("@ethersproject/web");
"use strict";

},{"@ethersproject/abi":"fYeCq","@ethersproject/address":"ggdAz","@ethersproject/base64":"329Wu","@ethersproject/basex":"dm2o4","@ethersproject/bytes":"htrqZ","@ethersproject/hash":"7JYPm","@ethersproject/hdnode":"8PpMD","@ethersproject/json-wallets":"1qqTy","@ethersproject/keccak256":"hXDEv","@ethersproject/logger":"hLvB2","@ethersproject/sha2":"k4R8k","@ethersproject/solidity":"7K4RF","@ethersproject/random":"7myQM","@ethersproject/properties":"h3GJb","@ethersproject/rlp":"b2vlp","@ethersproject/signing-key":"krGB2","@ethersproject/strings":"5TGFZ","@ethersproject/transactions":"d1ust","@ethersproject/units":"kGZhx","@ethersproject/wallet":"2DfhD","@ethersproject/web":"5yjI3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7K4RF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// @TODO: Array Enum
parcelHelpers.export(exports, "pack", ()=>pack);
parcelHelpers.export(exports, "keccak256", ()=>keccak256);
parcelHelpers.export(exports, "sha256", ()=>sha256);
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _keccak256 = require("@ethersproject/keccak256");
var _sha2 = require("@ethersproject/sha2");
var _strings = require("@ethersproject/strings");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger = new (0, _logger.Logger)((0, _version.version));
function _pack(type, value, isArray) {
    switch(type){
        case "address":
            if (isArray) return (0, _bytes.zeroPad)(value, 32);
            return (0, _bytes.arrayify)(value);
        case "string":
            return (0, _strings.toUtf8Bytes)(value);
        case "bytes":
            return (0, _bytes.arrayify)(value);
        case "bool":
            value = value ? "0x01" : "0x00";
            if (isArray) return (0, _bytes.zeroPad)(value, 32);
            return (0, _bytes.arrayify)(value);
    }
    let match = type.match(regexNumber);
    if (match) {
        //let signed = (match[1] === "int")
        let size = parseInt(match[2] || "256");
        if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) logger.throwArgumentError("invalid number type", "type", type);
        if (isArray) size = 256;
        value = (0, _bignumber.BigNumber).from(value).toTwos(size);
        return (0, _bytes.zeroPad)(value, size / 8);
    }
    match = type.match(regexBytes);
    if (match) {
        const size = parseInt(match[1]);
        if (String(size) !== match[1] || size === 0 || size > 32) logger.throwArgumentError("invalid bytes type", "type", type);
        if ((0, _bytes.arrayify)(value).byteLength !== size) logger.throwArgumentError(`invalid value for ${type}`, "value", value);
        if (isArray) return (0, _bytes.arrayify)((value + Zeros).substring(0, 66));
        return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
        const baseType = match[1];
        const count = parseInt(match[2] || String(value.length));
        if (count != value.length) logger.throwArgumentError(`invalid array length for ${type}`, "value", value);
        const result = [];
        value.forEach(function(value) {
            result.push(_pack(baseType, value, true));
        });
        return (0, _bytes.concat)(result);
    }
    return logger.throwArgumentError("invalid type", "type", type);
}
function pack(types, values) {
    if (types.length != values.length) logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
    const tight = [];
    types.forEach(function(type, index) {
        tight.push(_pack(type, values[index]));
    });
    return (0, _bytes.hexlify)((0, _bytes.concat)(tight));
}
function keccak256(types, values) {
    return (0, _keccak256.keccak256)(pack(types, values));
}
function sha256(types, values) {
    return (0, _sha2.sha256)(pack(types, values));
}

},{"@ethersproject/bignumber":"ckYYW","@ethersproject/bytes":"htrqZ","@ethersproject/keccak256":"hXDEv","@ethersproject/sha2":"k4R8k","@ethersproject/strings":"5TGFZ","@ethersproject/logger":"hLvB2","./_version":"icbbC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"icbbC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "solidity/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kGZhx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Some environments have issues with RegEx that contain back-tracking, so we cannot
// use them.
parcelHelpers.export(exports, "commify", ()=>commify);
parcelHelpers.export(exports, "formatUnits", ()=>formatUnits);
parcelHelpers.export(exports, "parseUnits", ()=>parseUnits);
parcelHelpers.export(exports, "formatEther", ()=>formatEther);
parcelHelpers.export(exports, "parseEther", ()=>parseEther);
var _bignumber = require("@ethersproject/bignumber");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether"
];
function commify(value) {
    const comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") logger.throwArgumentError("invalid value", "value", value);
    // Make sure we have at least one whole digit (0 if none)
    let whole = comps[0];
    let negative = "";
    if (whole.substring(0, 1) === "-") {
        negative = "-";
        whole = whole.substring(1);
    }
    // Make sure we have at least 1 whole digit with no leading zeros
    while(whole.substring(0, 1) === "0")whole = whole.substring(1);
    if (whole === "") whole = "0";
    let suffix = "";
    if (comps.length === 2) suffix = "." + (comps[1] || "0");
    while(suffix.length > 2 && suffix[suffix.length - 1] === "0")suffix = suffix.substring(0, suffix.length - 1);
    const formatted = [];
    while(whole.length)if (whole.length <= 3) {
        formatted.unshift(whole);
        break;
    } else {
        const index = whole.length - 3;
        formatted.unshift(whole.substring(index));
        whole = whole.substring(0, index);
    }
    return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
    if (typeof unitName === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) unitName = 3 * index;
    }
    return (0, _bignumber.formatFixed)(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
    if (typeof value !== "string") logger.throwArgumentError("value must be a string", "value", value);
    if (typeof unitName === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) unitName = 3 * index;
    }
    return (0, _bignumber.parseFixed)(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
    return formatUnits(wei, 18);
}
function parseEther(ether) {
    return parseUnits(ether, 18);
}

},{"@ethersproject/bignumber":"ckYYW","@ethersproject/logger":"hLvB2","./_version":"i97hS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i97hS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "units/5.7.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aosLW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "ethers/5.7.2";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lOpRc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ETHAuth", ()=>ETHAuth);
parcelHelpers.export(exports, "ETHAuthEIP712Domain", ()=>ETHAuthEIP712Domain);
parcelHelpers.export(exports, "ETHAuthPrefix", ()=>ETHAuthPrefix);
parcelHelpers.export(exports, "ETHAuthVersion", ()=>ETHAuthVersion);
parcelHelpers.export(exports, "IsValidSignatureBytes32MagicValue", ()=>IsValidSignatureBytes32MagicValue);
parcelHelpers.export(exports, "Proof", ()=>Proof);
parcelHelpers.export(exports, "ValidateContractAccountProof", ()=>ValidateContractAccountProof);
parcelHelpers.export(exports, "ValidateEOAProof", ()=>ValidateEOAProof);
parcelHelpers.export(exports, "encodeTypedDataDigest", ()=>encodeTypedDataDigest);
parcelHelpers.export(exports, "encodeTypedDataHash", ()=>encodeTypedDataHash);
parcelHelpers.export(exports, "validateClaims", ()=>validateClaims);
var _ethers = require("ethers");
var _jsBase64 = require("js-base64");
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var encodeTypedDataHash = function(typedData) {
    return (0, _ethers.ethers).utils._TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message);
};
var encodeTypedDataDigest = function(typedData) {
    var hash = encodeTypedDataHash(typedData);
    var digest = (0, _ethers.ethers).utils.arrayify((0, _ethers.ethers).utils.keccak256(hash));
    return digest;
};
var Proof = /** @class */ function() {
    function Proof(args) {
        this.prefix = ETHAuthPrefix;
        this.address = (args === null || args === void 0 ? void 0 : args.address) ? args.address.toLowerCase() : "";
        this.claims = (args === null || args === void 0 ? void 0 : args.claims) ? args.claims : {
            app: "",
            iat: 0,
            exp: 0,
            v: ETHAuthVersion
        };
        this.signature = (args === null || args === void 0 ? void 0 : args.signature) ? args.signature : "";
        this.extra = (args === null || args === void 0 ? void 0 : args.extra) ? args.extra : "";
    }
    Proof.prototype.setIssuedAtNow = function() {
        this.claims.iat = Math.round(new Date().getTime() / 1000);
    };
    Proof.prototype.setExpiryIn = function(seconds) {
        this.claims.exp = Math.round(new Date().getTime() / 1000) + seconds;
    };
    Proof.prototype.validateClaims = function() {
        return validateClaims(this.claims);
    };
    Proof.prototype.messageDigest = function() {
        var isValid = this.validateClaims();
        if (isValid.err) throw isValid.err;
        return (0, _ethers.ethers).utils.arrayify(encodeTypedDataHash(this.messageTypedData()));
    };
    Proof.prototype.messageTypedData = function() {
        var domain = __assign({}, ETHAuthEIP712Domain);
        var types = {
            "Claims": []
        };
        var message = {};
        var typedData = {
            domain: domain,
            types: types,
            message: message
        };
        if (this.claims.app && this.claims.app.length > 0) {
            typedData.types.Claims.push({
                name: "app",
                type: "string"
            });
            typedData.message["app"] = this.claims.app;
        }
        if (this.claims.iat && this.claims.iat > 0) {
            typedData.types.Claims.push({
                name: "iat",
                type: "int64"
            });
            typedData.message["iat"] = this.claims.iat;
        }
        if (this.claims.exp && this.claims.exp > 0) {
            typedData.types.Claims.push({
                name: "exp",
                type: "int64"
            });
            typedData.message["exp"] = this.claims.exp;
        }
        if (this.claims.n && this.claims.n > 0) {
            typedData.types.Claims.push({
                name: "n",
                type: "uint64"
            });
            typedData.message["n"] = this.claims.n;
        }
        if (this.claims.typ && this.claims.typ.length > 0) {
            typedData.types.Claims.push({
                name: "typ",
                type: "string"
            });
            typedData.message["typ"] = this.claims.typ;
        }
        if (this.claims.ogn && this.claims.ogn.length > 0) {
            typedData.types.Claims.push({
                name: "ogn",
                type: "string"
            });
            typedData.message["ogn"] = this.claims.ogn;
        }
        if (this.claims.v && this.claims.v.length > 0) {
            typedData.types.Claims.push({
                name: "v",
                type: "string"
            });
            typedData.message["v"] = this.claims.v;
        }
        return typedData;
    };
    return Proof;
}();
var validateClaims = function(claims) {
    if (claims.app === "") return {
        ok: false,
        err: new Error("claims: app is empty")
    };
    var now = Math.round(new Date().getTime() / 1000);
    var drift = 300; // 5 minutes
    var max = 31536000 + drift; // 1 year
    if (claims.v === "") return {
        ok: false,
        err: new Error("claims: ethauth version is empty")
    };
    if (claims.iat && claims.iat !== 0 && (claims.iat > now + drift || claims.iat < now - max)) return {
        ok: false,
        err: new Error("claims: iat is invalid")
    };
    if (claims.exp < now - drift || claims.exp > now + max) return {
        ok: false,
        err: new Error("claims: token has expired")
    };
    return {
        ok: true
    };
};
// ValidateEOAProof verifies the account proof, testing if the proof claims have been signed with an
// EOA (externally owned account) and will return success/failture, the account address as a string, and any errors.
var ValidateEOAProof = function(provider, chainId, proof) {
    return __awaiter(void 0, void 0, void 0, function() {
        var messageDigest, address;
        return __generator(this, function(_a) {
            messageDigest = proof.messageDigest();
            address = (0, _ethers.ethers).utils.verifyMessage(messageDigest, proof.signature);
            if (address.slice(0, 2) === "0x" && address.length === 42 && address.toLowerCase() === proof.address.toLowerCase()) return [
                2 /*return*/ ,
                {
                    isValid: true,
                    address: proof.address
                }
            ];
            else return [
                2 /*return*/ ,
                {
                    isValid: false
                }
            ];
        });
    });
};
// ValidateContractAccountProof verifies the account proof, testing if the
// proof claims have been signed with a smart-contract based account by calling the EIP-1271
// method of the remote contract. This method will return success/failure, the
// account address as a string, and any errors. The wallet contract must be deployed in
// order for this call to be successful. In order test an undeployed smart-wallet, you
// will have to implement your own custom validator method.
var ValidateContractAccountProof = function(provider, chainId, proof) {
    return __awaiter(void 0, void 0, void 0, function() {
        var messageDigest, walletCode, abi, contract, isValidSignature;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    if (!provider || provider === undefined) return [
                        2 /*return*/ ,
                        {
                            isValid: false
                        }
                    ];
                    messageDigest = proof.messageDigest();
                    return [
                        4 /*yield*/ ,
                        provider.getCode(proof.address)
                    ];
                case 1:
                    walletCode = _a.sent();
                    if (walletCode === "0x" || walletCode.length <= 2) throw new Error("ValidateContractAccountProof failed. unable to fetch wallet contract code");
                    abi = [
                        "function isValidSignature(bytes32, bytes) public view returns (bytes4)"
                    ];
                    contract = new (0, _ethers.ethers).Contract(proof.address, abi, provider);
                    return [
                        4 /*yield*/ ,
                        contract.isValidSignature(messageDigest, (0, _ethers.ethers).utils.arrayify(proof.signature))
                    ];
                case 2:
                    isValidSignature = _a.sent();
                    if (isValidSignature === IsValidSignatureBytes32MagicValue) return [
                        2 /*return*/ ,
                        {
                            isValid: true,
                            address: proof.address
                        }
                    ];
                    else return [
                        2 /*return*/ ,
                        {
                            isValid: false
                        }
                    ];
            }
        });
    });
};
// IsValidSignatureBytes32 is the EIP-1271 magic value we test
var IsValidSignatureBytes32MagicValue = "0x1626ba7e";
var ETHAuthVersion = "1";
var ETHAuthPrefix = "eth";
var ETHAuthEIP712Domain = {
    name: "ETHAuth",
    version: ETHAuthVersion
};
var ETHAuth = /** @class */ function() {
    function ETHAuth() {
        var validators = [];
        for(var _i = 0; _i < arguments.length; _i++)validators[_i] = arguments[_i];
        var _this = this;
        this.configJsonRpcProvider = function(ethereumJsonRpcURL) {
            return __awaiter(_this, void 0, void 0, function() {
                var netVersion;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            this.provider = new (0, _ethers.ethers).providers.JsonRpcProvider(ethereumJsonRpcURL);
                            return [
                                4 /*yield*/ ,
                                this.provider.send("net_version", [])
                            ];
                        case 1:
                            netVersion = _a.sent();
                            this.chainId = parseInt(netVersion);
                            if (!this.chainId || this.chainId === 0 || (this.chainId, false)) throw new Error("ethauth: unable to get chainId");
                            this.ethereumJsonRpcURL = ethereumJsonRpcURL;
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        };
        this.configValidators = function() {
            var validators = [];
            for(var _i = 0; _i < arguments.length; _i++)validators[_i] = arguments[_i];
            if (validators.length == 0) throw new Error("validators list is empty");
            _this.validators = validators;
        };
        this.encodeProof = function(proof, skipSignatureValidation) {
            if (skipSignatureValidation === void 0) skipSignatureValidation = false;
            return __awaiter(_this, void 0, void 0, function() {
                var isValid, claimsJSON, proofString;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            if (proof.address.length !== 42 || proof.address.slice(0, 2) !== "0x") throw new Error("ethauth: invalid address");
                            if (proof.signature === "" || proof.signature.slice(0, 2) !== "0x") throw new Error("ethauth: invalid signature");
                            if (proof.extra && proof.extra.slice(0, 2) !== "0x") throw new Error("ethauth: invalid extra encoding, expecting hex data");
                            return [
                                4 /*yield*/ ,
                                this.validateProof(proof, skipSignatureValidation)
                            ];
                        case 1:
                            isValid = _a.sent();
                            if (!isValid) throw new Error("ethauth: proof is invalid");
                            claimsJSON = JSON.stringify(proof.claims);
                            proofString = ETHAuthPrefix + "." + proof.address.toLowerCase() + "." + (0, _jsBase64.Base64).encode(claimsJSON, true) + "." + proof.signature;
                            if (proof.extra && proof.extra.length > 0) proofString += "." + proof.extra;
                            return [
                                2 /*return*/ ,
                                proofString
                            ];
                    }
                });
            });
        };
        this.decodeProof = function(proofString, skipSignatureValidation) {
            if (skipSignatureValidation === void 0) skipSignatureValidation = false;
            return __awaiter(_this, void 0, void 0, function() {
                var parts, prefix, address, messageBase64, signature, extra, message, claims, proof, isValid;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            parts = proofString.split(".");
                            if (parts.length < 4 || parts.length > 5) throw new Error("ethauth: invalid proof string");
                            prefix = parts[0], address = parts[1], messageBase64 = parts[2], signature = parts[3], extra = parts[4];
                            // check prefix
                            if (prefix !== ETHAuthPrefix) throw new Error("ethauth: not an ethauth proof");
                            message = (0, _jsBase64.Base64).decode(messageBase64);
                            claims = JSON.parse(message);
                            proof = new Proof({
                                address: address,
                                claims: claims,
                                signature: signature,
                                extra: extra
                            });
                            return [
                                4 /*yield*/ ,
                                this.validateProof(proof, skipSignatureValidation)
                            ];
                        case 1:
                            isValid = _a.sent();
                            if (!isValid) throw new Error("ethauth: proof is invalid");
                            return [
                                2 /*return*/ ,
                                proof
                            ];
                    }
                });
            });
        };
        this.validateProof = function(proof, skipSignatureValidation) {
            if (skipSignatureValidation === void 0) skipSignatureValidation = false;
            return __awaiter(_this, void 0, void 0, function() {
                var isValidClaims, isValidSig;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            isValidClaims = this.validateProofClaims(proof);
                            if (isValidClaims.err) throw new Error("ethauth: proof claims are invalid ".concat(isValidClaims.err));
                            if (!(skipSignatureValidation !== true)) return [
                                3 /*break*/ ,
                                2
                            ];
                            return [
                                4 /*yield*/ ,
                                this.validateProofSignature(proof)
                            ];
                        case 1:
                            isValidSig = _a.sent();
                            if (isValidSig !== true) throw new Error("ethauth: proof signature is invalid");
                            _a.label = 2;
                        case 2:
                            return [
                                2 /*return*/ ,
                                true
                            ];
                    }
                });
            });
        };
        this.validateProofSignature = function(proof) {
            return __awaiter(_this, void 0, void 0, function() {
                var retIsValid, i, validator, isValid, i;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            retIsValid = [];
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < this.validators.length)) return [
                                3 /*break*/ ,
                                6
                            ];
                            _a.label = 2;
                        case 2:
                            _a.trys.push([
                                2,
                                4,
                                ,
                                5
                            ]);
                            validator = this.validators[i];
                            return [
                                4 /*yield*/ ,
                                validator(this.provider, this.chainId, proof)
                            ];
                        case 3:
                            isValid = _a.sent().isValid;
                            if (isValid === true) // preemptively return true if we've determined it to be valid
                            return [
                                2 /*return*/ ,
                                true
                            ];
                            retIsValid.push(isValid);
                            return [
                                3 /*break*/ ,
                                5
                            ];
                        case 4:
                            _a.sent();
                            retIsValid.push(false);
                            return [
                                3 /*break*/ ,
                                5
                            ];
                        case 5:
                            i++;
                            return [
                                3 /*break*/ ,
                                1
                            ];
                        case 6:
                            for(i = 0; i < retIsValid.length; i++){
                                if (retIsValid[i]) return [
                                    2 /*return*/ ,
                                    true
                                ];
                            }
                            return [
                                2 /*return*/ ,
                                false
                            ];
                    }
                });
            });
        };
        this.validateProofClaims = function(proof) {
            return proof.validateClaims();
        };
        if (validators.length == 0) this.validators = [
            ValidateEOAProof,
            ValidateContractAccountProof
        ];
        else this.validators = validators;
    }
    return ETHAuth;
}();

},{"ethers":"hdHML","js-base64":"9GjXb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9GjXb":[function(require,module,exports) {
/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// makecjs:CUT //
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
parcelHelpers.export(exports, "atob", ()=>_atob);
parcelHelpers.export(exports, "atobPolyfill", ()=>atobPolyfill);
parcelHelpers.export(exports, "btoa", ()=>_btoa);
parcelHelpers.export(exports, "btoaPolyfill", ()=>btoaPolyfill);
parcelHelpers.export(exports, "fromBase64", ()=>decode);
parcelHelpers.export(exports, "toBase64", ()=>encode);
parcelHelpers.export(exports, "utob", ()=>utob);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "encodeURI", ()=>encodeURI);
parcelHelpers.export(exports, "encodeURL", ()=>encodeURI);
parcelHelpers.export(exports, "btou", ()=>btou);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "isValid", ()=>isValid);
parcelHelpers.export(exports, "fromUint8Array", ()=>fromUint8Array);
parcelHelpers.export(exports, "toUint8Array", ()=>toUint8Array);
parcelHelpers.export(exports, "extendString", ()=>extendString);
parcelHelpers.export(exports, "extendUint8Array", ()=>extendUint8Array);
parcelHelpers.export(exports, "extendBuiltins", ()=>extendBuiltins);
// and finally,
parcelHelpers.export(exports, "Base64", ()=>gBase64);
var Buffer = require("50b6ce0789561b60").Buffer;
const version = "3.7.5";
/**
 * @deprecated use lowercase `version`.
 */ const VERSION = version;
const _hasatob = typeof atob === "function";
const _hasbtoa = typeof btoa === "function";
const _hasBuffer = typeof Buffer === "function";
const _TD = typeof TextDecoder === "function" ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === "function" ? new TextEncoder() : undefined;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a)=>{
    let tab = {};
    a.forEach((c, i)=>tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it)=>new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src)=>src.replace(/=/g, "").replace(/[+\/]/g, (m0)=>m0 == "+" ? "-" : "_");
const _tidyB64 = (s)=>s.replace(/[^A-Za-z0-9\+\/]/g, "");
/**
 * polyfill version of `btoa`
 */ const btoaPolyfill = (bin)=>{
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = "";
    const pad = bin.length % 3;
    for(let i = 0; i < bin.length;){
        if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */ const _btoa = _hasbtoa ? (bin)=>btoa(bin) : _hasBuffer ? (bin)=>Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a)=>Buffer.from(u8a).toString("base64") : (u8a)=>{
    // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
    const maxargs = 0x1000;
    let strs = [];
    for(let i = 0, l = u8a.length; i < l; i += maxargs)strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
    return _btoa(strs.join(""));
};
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */ const fromUint8Array = (u8a, urlsafe = false)=>urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c)=>{
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
    } else {
        var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
        return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */ const utob = (u)=>u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer ? (s)=>Buffer.from(s, "utf8").toString("base64") : _TE ? (s)=>_fromUint8Array(_TE.encode(s)) : (s)=>_btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */ const encode = (src, urlsafe = false)=>urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */ const encodeURI = (src)=>encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc)=>{
    switch(cccc.length){
        case 4:
            var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3), offset = cp - 0x10000;
            return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);
        case 3:
            return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
        default:
            return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */ const btou = (b)=>b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */ const atobPolyfill = (asc)=>{
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, "");
    if (!b64re.test(asc)) throw new TypeError("malformed base64.");
    asc += "==".slice(2 - (asc.length & 3));
    let u24, bin = "", r1, r2;
    for(let i = 0; i < asc.length;){
        u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */ const _atob = _hasatob ? (asc)=>atob(_tidyB64(asc)) : _hasBuffer ? (asc)=>Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
//
const _toUint8Array = _hasBuffer ? (a)=>_U8Afrom(Buffer.from(a, "base64")) : (a)=>_U8Afrom(_atob(a).split("").map((c)=>c.charCodeAt(0)));
/**
 * converts a Base64 string to a Uint8Array.
 */ const toUint8Array = (a)=>_toUint8Array(_unURI(a));
//
const _decode = _hasBuffer ? (a)=>Buffer.from(a, "base64").toString("utf8") : _TD ? (a)=>_TD.decode(_toUint8Array(a)) : (a)=>btou(_atob(a));
const _unURI = (a)=>_tidyB64(a.replace(/[-_]/g, (m0)=>m0 == "-" ? "+" : "/"));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */ const decode = (src)=>_decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */ const isValid = (src)=>{
    if (typeof src !== "string") return false;
    const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v)=>{
    return {
        value: v,
        enumerable: false,
        writable: true,
        configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */ const extendString = function() {
    const _add = (name, body)=>Object.defineProperty(String.prototype, name, _noEnum(body));
    _add("fromBase64", function() {
        return decode(this);
    });
    _add("toBase64", function(urlsafe) {
        return encode(this, urlsafe);
    });
    _add("toBase64URI", function() {
        return encode(this, true);
    });
    _add("toBase64URL", function() {
        return encode(this, true);
    });
    _add("toUint8Array", function() {
        return toUint8Array(this);
    });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */ const extendUint8Array = function() {
    const _add = (name, body)=>Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add("toBase64", function(urlsafe) {
        return fromUint8Array(this, urlsafe);
    });
    _add("toBase64URI", function() {
        return fromUint8Array(this, true);
    });
    _add("toBase64URL", function() {
        return fromUint8Array(this, true);
    });
};
/**
 * extend Builtin prototypes with relevant methods
 */ const extendBuiltins = ()=>{
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins
};

},{"50b6ce0789561b60":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01lBM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChainId", ()=>(0, _0XsequenceNetworkConstantsEsmJs.ChainId));
parcelHelpers.export(exports, "NetworkType", ()=>(0, _0XsequenceNetworkConstantsEsmJs.NetworkType));
parcelHelpers.export(exports, "networks", ()=>(0, _0XsequenceNetworkConstantsEsmJs.networks));
parcelHelpers.export(exports, "AllowProvider", ()=>AllowProvider);
parcelHelpers.export(exports, "CachedProvider", ()=>CachedProvider);
parcelHelpers.export(exports, "EagerProvider", ()=>EagerProvider);
parcelHelpers.export(exports, "JsonRpcExternalProvider", ()=>JsonRpcExternalProvider);
parcelHelpers.export(exports, "JsonRpcProvider", ()=>JsonRpcProvider);
parcelHelpers.export(exports, "JsonRpcRouter", ()=>JsonRpcRouter);
parcelHelpers.export(exports, "JsonRpcSender", ()=>JsonRpcSender);
parcelHelpers.export(exports, "JsonRpcVersion", ()=>JsonRpcVersion);
parcelHelpers.export(exports, "PublicProvider", ()=>PublicProvider);
parcelHelpers.export(exports, "SigningProvider", ()=>SigningProvider);
parcelHelpers.export(exports, "SingleflightMiddleware", ()=>SingleflightMiddleware);
parcelHelpers.export(exports, "allNetworks", ()=>allNetworks);
parcelHelpers.export(exports, "allowProviderMiddleware", ()=>allowProviderMiddleware);
parcelHelpers.export(exports, "checkNetworkConfig", ()=>checkNetworkConfig);
parcelHelpers.export(exports, "createJsonRpcMiddlewareStack", ()=>createJsonRpcMiddlewareStack);
parcelHelpers.export(exports, "ensureUniqueNetworks", ()=>ensureUniqueNetworks);
parcelHelpers.export(exports, "ensureValidNetworks", ()=>ensureValidNetworks);
parcelHelpers.export(exports, "exceptionProviderMiddleware", ()=>exceptionProviderMiddleware);
parcelHelpers.export(exports, "findNetworkConfig", ()=>findNetworkConfig);
parcelHelpers.export(exports, "findSupportedNetwork", ()=>findSupportedNetwork);
parcelHelpers.export(exports, "getChainId", ()=>getChainId);
parcelHelpers.export(exports, "indexerURL", ()=>indexerURL);
parcelHelpers.export(exports, "isJsonRpcHandler", ()=>isJsonRpcHandler);
parcelHelpers.export(exports, "isJsonRpcProvider", ()=>isJsonRpcProvider);
parcelHelpers.export(exports, "isNetworkConfig", ()=>isNetworkConfig);
parcelHelpers.export(exports, "isValidNetworkConfig", ()=>isValidNetworkConfig);
parcelHelpers.export(exports, "loggingProviderMiddleware", ()=>loggingProviderMiddleware);
parcelHelpers.export(exports, "maybeChainId", ()=>maybeChainId);
parcelHelpers.export(exports, "networkProviderMiddleware", ()=>networkProviderMiddleware);
parcelHelpers.export(exports, "networksIndex", ()=>networksIndex);
parcelHelpers.export(exports, "nodesURL", ()=>nodesURL);
parcelHelpers.export(exports, "relayerURL", ()=>relayerURL);
parcelHelpers.export(exports, "sortNetworks", ()=>sortNetworks);
parcelHelpers.export(exports, "stringTemplate", ()=>stringTemplate);
parcelHelpers.export(exports, "toChainIdNumber", ()=>toChainIdNumber);
parcelHelpers.export(exports, "updateNetworkConfig", ()=>updateNetworkConfig);
parcelHelpers.export(exports, "validateAndSortNetworks", ()=>validateAndSortNetworks);
var _0XsequenceNetworkConstantsEsmJs = require("../constants/dist/0xsequence-network-constants.esm.js");
var _ethers = require("ethers");
var _utils = require("@0xsequence/utils");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function isNetworkConfig(cand) {
    return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined;
}
const getChainId = (chainId)=>{
    if (typeof chainId === "number") return chainId;
    if (chainId.chainId) return chainId.chainId;
    return (0, _ethers.ethers).BigNumber.from(chainId).toNumber();
};
const maybeChainId = (chainId)=>{
    if (!chainId) return undefined;
    return getChainId(chainId);
};
const isValidNetworkConfig = (networkConfig, raise = false, skipRelayerCheck = false)=>{
    if (!networkConfig) throw new Error(`invalid network config: empty config`);
    const configs = [];
    if (Array.isArray(networkConfig)) configs.push(...networkConfig);
    else configs.push(networkConfig);
    if (configs.length === 0) {
        if (raise) throw new Error(`invalid network config: empty config`);
        return false;
    }
    // Ensure distinct chainId configs
    const chainIds = configs.map((c)=>c.chainId).sort();
    const dupes = chainIds.filter((c, i)=>chainIds.indexOf(c) !== i);
    if (dupes.length > 0) {
        if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
        return false;
    }
    // Downcase all network names
    configs.forEach((c)=>c.name = c.name.toLowerCase());
    // Ensure distinct network names
    const names = configs.map((c)=>c.name).sort();
    const nameDupes = names.filter((c, i)=>names.indexOf(c) !== i);
    if (nameDupes.length > 0) {
        if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`);
        return false;
    }
    // Ensure rpcUrl or provider is specified
    // Ensure relayerUrl or relayer is specified
    // Ensure one default chain
    // Ensure one auth chain
    let defaultChain = false;
    for(let i = 0; i < configs.length; i++){
        const c = configs[i];
        if ((!c.rpcUrl || c.rpcUrl === "") && !c.provider) {
            if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: rpcUrl or provider must be provided`);
            return false;
        }
        if (!skipRelayerCheck) {
            if (!c.relayer) {
                if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: relayer must be provided`);
                return false;
            }
        }
        if (c.isDefaultChain) {
            if (defaultChain) {
                if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: DefaultChain is already set by another config`);
                return false;
            }
            defaultChain = true;
        }
    }
    if (!defaultChain) {
        if (raise) throw new Error(`invalid network config: DefaultChain must be set`);
        return false;
    }
    return true;
};
const ensureValidNetworks = (networks, skipRelayerCheck = false)=>{
    isValidNetworkConfig(networks, true, skipRelayerCheck);
    return networks;
};
const ensureUniqueNetworks = (networks, raise = true)=>{
    const chainIds = networks.map((c)=>c.chainId).sort();
    const dupes = chainIds.filter((c, i)=>chainIds.indexOf(c) !== i);
    if (dupes.length > 0) {
        if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
        return false;
    }
    return true;
};
const updateNetworkConfig = (src, dest)=>{
    if (!src || !dest) return;
    if (!src.chainId && !src.name) throw new Error("failed to update network config: source config is missing chainId or name");
    if (src.chainId !== dest.chainId && src.name !== dest.name) throw new Error("failed to update network config: one of chainId or name must match");
    if (src.rpcUrl) {
        dest.rpcUrl = src.rpcUrl;
        dest.provider = undefined;
    }
    if (src.provider) dest.provider = src.provider;
    if (src.relayer) dest.relayer = src.relayer;
};
const validateAndSortNetworks = (networks)=>{
    return ensureValidNetworks(sortNetworks(networks));
};
const findNetworkConfig = (networks, chainId)=>{
    if (typeof chainId === "string") {
        if (chainId.startsWith("0x")) {
            const id = (0, _ethers.ethers).BigNumber.from(chainId).toNumber();
            return networks.find((n)=>n.chainId === id);
        } else return networks.find((n)=>n.name === chainId || `${n.chainId}` === chainId);
    } else if (typeof chainId === "number") return networks.find((n)=>n.chainId === chainId);
    else if (chainId.chainId) return networks.find((n)=>n.chainId === chainId.chainId);
    else if ((0, _ethers.ethers).BigNumber.isBigNumber(chainId)) {
        const id = chainId.toNumber();
        return networks.find((n)=>n.chainId === id);
    } else return undefined;
};
const checkNetworkConfig = (network, chainId)=>{
    if (!network) return false;
    if (network.name === chainId) return true;
    if (network.chainId === chainId) return true;
    return false;
};
const networksIndex = (networks)=>{
    const index = {};
    for(let i = 0; i < networks.length; i++)index[networks[i].name] = networks[i];
    return index;
};
// TODO: we should remove sortNetworks in the future but this is a breaking change for dapp integrations on older versions <-> wallet
// sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers
const sortNetworks = (networks)=>{
    if (!networks) return [];
    const config = networks.sort((a, b)=>{
        if (a.chainId === b.chainId) return 0;
        return a.chainId < b.chainId ? -1 : 1;
    });
    // DefaultChain goes first
    const defaultConfigIdx = config.findIndex((c)=>c.isDefaultChain);
    if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0]);
    return config;
};
const stringTemplate = (sTemplate, mData)=>{
    if (typeof sTemplate === "string") {
        mData = mData ? mData : {};
        return sTemplate.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(fullMath, grp) {
            let val = mData[grp];
            if (typeof val === "function") val = val();
            else if (val === null || val === undefined) val = "";
            else if (typeof val === "object" || typeof val === "symbol") val = val.toString();
            else val = val.valueOf();
            return val;
        });
    }
    return "";
};
const indexerURL = (network)=>stringTemplate("https://${network}-indexer.sequence.app", {
        network
    });
const relayerURL = (network)=>stringTemplate("https://${network}-relayer.sequence.app", {
        network
    });
const nodesURL = (network)=>stringTemplate("https://nodes.sequence.app/${network}", {
        network
    });
function findSupportedNetwork(chainIdOrName) {
    return findNetworkConfig(allNetworks, chainIdOrName);
}
function toChainIdNumber(chainIdLike) {
    if ((0, _ethers.ethers).BigNumber.isBigNumber(chainIdLike)) return chainIdLike;
    if ((0, _utils.isBigNumberish)(chainIdLike)) return (0, _ethers.ethers).BigNumber.from(chainIdLike);
    return (0, _ethers.ethers).BigNumber.from(chainIdLike.chainId);
}
const genUrls = (network)=>{
    const rpcUrl = nodesURL(network);
    return {
        rpcUrl,
        relayer: {
            url: relayerURL(network),
            provider: {
                url: rpcUrl
            }
        },
        indexerUrl: indexerURL(network)
    };
};
const allNetworks = validateAndSortNetworks([
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).POLYGON], genUrls("polygon"), {
        isDefaultChain: true,
        isAuthChain: true
    }),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).MAINNET], genUrls("mainnet")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).BSC], genUrls("bsc")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).AVALANCHE], genUrls("avalanche")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).ARBITRUM], genUrls("arbitrum")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).ARBITRUM_NOVA], genUrls("arbitrum-nova")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).OPTIMISM], genUrls("optimism")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).OPTIMISM_SEPOLIA], genUrls("optimism-sepolia")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).POLYGON_ZKEVM], genUrls("polygon-zkevm")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).GNOSIS], genUrls("gnosis")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).RINKEBY], genUrls("rinkeby"), {
        disabled: true
    }),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).GOERLI], genUrls("goerli"), {
        disabled: true
    }),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).SEPOLIA], genUrls("sepolia")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).POLYGON_MUMBAI], genUrls("mumbai")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).BSC_TESTNET], genUrls("bsc-testnet")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).ARBITRUM_SEPOLIA], genUrls("arbitrum-sepolia")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).BASE], genUrls("base")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).BASE_SEPOLIA], genUrls("base-sepolia")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).HOMEVERSE_TESTNET], genUrls("homeverse-testnet")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).AVALANCHE_TESTNET], genUrls("avalanche-testnet")),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).HARDHAT], {
        rpcUrl: "http://localhost:8545",
        relayer: {
            url: "http://localhost:3000",
            provider: {
                url: "http://localhost:8545"
            }
        }
    }),
    _extends({}, (0, _0XsequenceNetworkConstantsEsmJs.networks)[(0, _0XsequenceNetworkConstantsEsmJs.ChainId).HARDHAT_2], {
        rpcUrl: "http://localhost:9545",
        relayer: {
            url: "http://localhost:3000",
            provider: {
                url: "http://localhost:9545"
            }
        }
    })
]);
const JsonRpcVersion = "2.0";
// EIP-1193 function signature
class JsonRpcRouter {
    constructor(middlewares, sender){
        this.sender = void 0;
        this.handler = void 0;
        this.sender = sender;
        if (middlewares) this.setMiddleware(middlewares);
    }
    setMiddleware(middlewares) {
        this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender.sendAsync);
    }
    sendAsync(request, callback, chainId) {
        try {
            this.handler(request, callback, chainId);
        } catch (err) {
            callback(err, undefined);
        }
    }
}
const createJsonRpcMiddlewareStack = (middlewares, handler)=>{
    if (middlewares.length === 0) return handler;
    const toMiddleware = (v)=>{
        if (v.sendAsyncMiddleware) return v.sendAsyncMiddleware;
        else return v;
    };
    let chain;
    chain = toMiddleware(middlewares[middlewares.length - 1])(handler);
    for(let i = middlewares.length - 2; i >= 0; i--)chain = toMiddleware(middlewares[i])(chain);
    return chain;
};
function isJsonRpcProvider(cand) {
    return cand !== undefined && cand.send !== undefined && cand.constructor.defaultUrl !== undefined && cand.detectNetwork !== undefined && cand.getSigner !== undefined && cand.perform !== undefined;
}
function isJsonRpcHandler(cand) {
    return cand !== undefined && cand.sendAsync !== undefined;
}
let _nextId = 0;
class JsonRpcSender {
    constructor(provider, defaultChainId){
        this.send = void 0;
        this.request = void 0;
        this.defaultChainId = void 0;
        this.sendAsync = (request, callback, chainId)=>{
            this.send(request.method, request.params, chainId || this.defaultChainId).then((r)=>{
                callback(undefined, {
                    jsonrpc: "2.0",
                    id: request.id,
                    result: r
                });
            }).catch((e)=>{
                callback(e, undefined);
            });
        };
        this.defaultChainId = defaultChainId;
        if (isJsonRpcProvider(provider)) // we can ignore defaultChainId for JsonRpcProviders as they are already chain-bound
        this.send = provider.send.bind(provider);
        else if (isJsonRpcHandler(provider)) this.send = (method, params, chainId)=>{
            return new Promise((resolve, reject)=>{
                provider.sendAsync({
                    // TODO: really shouldn't have to set these here?
                    jsonrpc: JsonRpcVersion,
                    id: ++_nextId,
                    method,
                    params
                }, (error, response)=>{
                    if (error) reject(error);
                    else if (response) resolve(response.result);
                    else resolve(undefined);
                }, chainId || this.defaultChainId);
            });
        };
        else this.send = provider;
        this.request = (request, chainId)=>{
            return this.send(request.method, request.params, chainId);
        };
    }
}
class JsonRpcExternalProvider {
    constructor(provider){
        this.provider = provider;
        this.sendAsync = (request, callback)=>{
            this.provider.send(request.method, request.params).then((r)=>{
                callback(undefined, {
                    jsonrpc: "2.0",
                    id: request.id,
                    result: r
                });
            }).catch((e)=>{
                callback(e, undefined);
            });
        };
        this.send = this.sendAsync;
    }
}
class AllowProvider {
    constructor(isAllowedFunc){
        this.sendAsyncMiddleware = void 0;
        this.isAllowedFunc = void 0;
        if (isAllowedFunc) this.isAllowedFunc = isAllowedFunc;
        else this.isAllowedFunc = (request)=>true;
        this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
    }
    setIsAllowedFunc(fn) {
        this.isAllowedFunc = fn;
        this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
    }
}
const allowProviderMiddleware = (isAllowed)=>(next)=>{
        return (request, callback, chainId)=>{
            // ensure precondition is met or do not allow the request to continue
            if (!isAllowed(request)) throw new Error("allowProvider middleware precondition is unmet.");
            // request is allowed. keep going..
            next(request, callback, chainId);
        };
    };
class CachedProvider {
    constructor(options){
        // cachableJsonRpcMethods which can be permanently cached for lifetime
        // of the provider.
        this.cachableJsonRpcMethods = [
            "net_version",
            "eth_chainId",
            "eth_accounts",
            "sequence_getWalletContext",
            "sequence_getNetworks"
        ];
        // cachableJsonRpcMethodsByBlock which can be temporarily cached for a short
        // period of time, essentially by block time. As we support chains fast blocks,
        // we keep the values here cachable only for 1.5 seconds. This is still useful to
        // memoize the calls within app-code that calls out to fetch these values within
        // a short period of time.
        this.cachableJsonRpcMethodsByBlock = [
            "eth_call",
            "eth_getCode"
        ];
        // cache for life-time of provider (unless explicitly cleared)
        this.cache = void 0;
        // cache by block, simulated by using a 1 second life-time
        this.cacheByBlock = void 0;
        this.cacheByBlockResetLock = false;
        // onUpdateCallback callback to be notified when cache values are set.
        this.onUpdateCallback = void 0;
        // defaultChainId is used for default chain select with used with multi-chain provider
        this.defaultChainId = void 0;
        this.sendAsyncMiddleware = (next)=>{
            return (request, callback, chainId)=>{
                // Respond early with cached result
                if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
                    const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);
                    const result = this.getCacheValue(key);
                    if (result && result !== "") {
                        callback(undefined, {
                            jsonrpc: "2.0",
                            id: request.id,
                            result: result
                        });
                        return;
                    }
                }
                // Continue down the handler chain
                next(request, (error, response, chainId)=>{
                    // Store result in cache and continue
                    if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
                        if (response && response.result && this.shouldCacheResponse(request, response)) {
                            // cache the value
                            const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);
                            if (this.cachableJsonRpcMethods.includes(request.method)) this.setCacheValue(key, response.result);
                            else this.setCacheByBlockValue(key, response.result);
                        }
                    }
                    // Exec next handler
                    callback(error, response);
                }, chainId || this.defaultChainId);
            };
        };
        this.cacheKey = (method, params, chainId)=>{
            let key = "";
            if (chainId) key = `${chainId}:${method}:`;
            else key = `:${method}:`;
            if (!params || params.length === 0) return key + "[]";
            return key + JSON.stringify(params);
        };
        this.getCache = ()=>this.cache;
        this.setCache = (cache)=>{
            this.cache = cache;
            if (this.onUpdateCallback) this.onUpdateCallback();
        };
        this.getCacheValue = (key)=>{
            if (this.cache[key]) return this.cache[key];
            if (this.cacheByBlock[key]) return this.cacheByBlock[key];
            return undefined;
        };
        this.setCacheValue = (key, value)=>{
            this.cache[key] = value;
            if (this.onUpdateCallback) this.onUpdateCallback(key, value);
        };
        this.setCacheByBlockValue = (key, value)=>{
            this.cacheByBlock[key] = value;
            // clear the cacheByBlock once every X period of time
            if (!this.cacheByBlockResetLock) {
                this.cacheByBlockResetLock = true;
                setTimeout(()=>{
                    this.cacheByBlockResetLock = false;
                    this.cacheByBlock = {};
                }, 1500); // 1.5 second cache lifetime
            }
        };
        this.shouldCacheResponse = (request, response)=>{
            // skip if we do not have response result
            if (!response || !response.result) return false;
            // skip caching eth_getCode where resposne value is '0x' or empty
            if (request.method === "eth_getCode" && response.result.length <= 2) return false;
            // all good -- signal to cache the result
            return true;
        };
        this.clearCache = ()=>{
            this.cache = {};
            this.cacheByBlock = {};
        };
        this.cache = {};
        this.cacheByBlock = {};
        this.defaultChainId = options == null ? void 0 : options.defaultChainId;
        if (!(options != null && options.blockCache)) this.cachableJsonRpcMethodsByBlock = [];
        else if ((options == null ? void 0 : options.blockCache) !== true) this.cachableJsonRpcMethodsByBlock = options == null ? void 0 : options.blockCache;
    }
    onUpdate(callback) {
        this.onUpdateCallback = callback;
    }
}
// EagerProvider will eagerly respond to a provider request from pre-initialized data values.
//
// This is useful for saving a few remote calls for responses we're already expecting when
// communicating to a specific network provider.
class EagerProvider {
    constructor(options){
        this.options = void 0;
        this.sendAsyncMiddleware = (next)=>{
            return (request, callback, chainId)=>{
                const { id, method } = request;
                switch(method){
                    case "net_version":
                        if (this.options.chainId) {
                            callback(undefined, {
                                jsonrpc: "2.0",
                                id: id,
                                result: `${this.options.chainId}`
                            });
                            return;
                        }
                        break;
                    case "eth_chainId":
                        if (this.options.chainId) {
                            callback(undefined, {
                                jsonrpc: "2.0",
                                id: id,
                                result: (0, _ethers.ethers).utils.hexlify(this.options.chainId)
                            });
                            return;
                        }
                        break;
                    case "eth_accounts":
                        if (this.options.accountAddress) {
                            callback(undefined, {
                                jsonrpc: "2.0",
                                id: id,
                                result: [
                                    (0, _ethers.ethers).utils.getAddress(this.options.accountAddress)
                                ]
                            });
                            return;
                        }
                        break;
                    case "sequence_getWalletContext":
                        if (this.options.walletContext) {
                            callback(undefined, {
                                jsonrpc: "2.0",
                                id: id,
                                result: this.options.walletContext
                            });
                            return;
                        }
                        break;
                }
                next(request, callback, chainId);
            };
        };
        this.options = options;
    }
}
const exceptionProviderMiddleware = (next)=>{
    return (request, callback, chainId)=>{
        next(request, (error, response)=>{
            if (!error && response && response.error) {
                if (typeof response.error === "string") throw new Error(response.error);
                else throw new Error(response.error.message);
            }
            callback(error, response);
        }, chainId);
    };
};
// TODO: rename to loggerMiddleware
const loggingProviderMiddleware = (next)=>{
    return (request, callback, chainId)=>{
        const chainIdLabel = chainId ? ` chainId:${chainId}` : "";
        (0, _utils.logger).info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params);
        next(request, (error, response)=>{
            if (error) (0, _utils.logger).warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error);
            else (0, _utils.logger).info(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `response:`, response);
            callback(error, response);
        }, chainId);
    };
};
const networkProviderMiddleware = (getChainId)=>(next)=>{
        return (request, callback, chainId)=>{
            const networkChainId = getChainId(request);
            const { id, method } = request;
            switch(method){
                case "net_version":
                    callback(undefined, {
                        jsonrpc: "2.0",
                        id: id,
                        result: `${networkChainId}`
                    });
                    return;
                case "eth_chainId":
                    callback(undefined, {
                        jsonrpc: "2.0",
                        id: id,
                        result: (0, _ethers.ethers).utils.hexlify(networkChainId)
                    });
                    return;
            }
            // request is allowed. keep going..
            next(request, callback, chainId);
        };
    };
const SignerJsonRpcMethods = [
    "personal_sign",
    "eth_sign",
    "eth_signTypedData",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "eth_sendRawTransaction",
    "sequence_sign",
    // sequence-aware personal_sign
    "sequence_signTypedData_v4",
    // sequence-aware eth_signTypedData_v4
    "sequence_getWalletContext",
    "sequence_getWalletConfig",
    "sequence_getWalletState",
    "sequence_getNetworks",
    "sequence_updateConfig",
    "sequence_publishConfig",
    "sequence_gasRefundOptions",
    "sequence_getNonce",
    "sequence_relay",
    "eth_decrypt",
    "eth_getEncryptionPublicKey",
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode"
];
class SigningProvider {
    constructor(provider){
        this.provider = void 0;
        this.sendAsyncMiddleware = (next)=>{
            return (request, callback, chainId)=>{
                // Forward signing requests to the signing provider
                if (SignerJsonRpcMethods.includes(request.method)) {
                    this.provider.sendAsync(request, callback, chainId);
                    return;
                }
                // Continue to next handler
                next(request, callback, chainId);
            };
        };
        this.provider = provider;
    }
}
class PublicProvider {
    constructor(rpcUrl){
        this.privateJsonRpcMethods = [
            "net_version",
            "eth_chainId",
            "eth_accounts",
            ...SignerJsonRpcMethods
        ];
        this.provider = void 0;
        this.rpcUrl = void 0;
        this.sendAsyncMiddleware = (next)=>{
            return (request, callback)=>{
                // When provider is configured, send non-private methods to our local public provider
                if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {
                    this.provider.send(request.method, request.params).then((r)=>{
                        callback(undefined, {
                            jsonrpc: "2.0",
                            id: request.id,
                            result: r
                        });
                    }).catch((e)=>callback(e));
                    return;
                }
                // Continue to next handler
                (0, _utils.logger).debug("[public-provider] sending request to signer window", request.method);
                next(request, callback);
            };
        };
        if (rpcUrl) this.setRpcUrl(rpcUrl);
    }
    getRpcUrl() {
        return this.rpcUrl;
    }
    setRpcUrl(rpcUrl) {
        if (!rpcUrl || rpcUrl === "") {
            this.rpcUrl = undefined;
            this.provider = undefined;
        } else {
            this.rpcUrl = rpcUrl;
            // TODO: maybe use @0xsequence/network JsonRpcProvider here instead,
            // which supports better caching.
            this.provider = new (0, _ethers.providers).JsonRpcProvider(rpcUrl);
        }
    }
}
class SingleflightMiddleware {
    constructor(){
        this.singleflightJsonRpcMethods = [
            "eth_chainId",
            "net_version",
            "eth_call",
            "eth_getCode",
            "eth_blockNumber",
            "eth_getBalance",
            "eth_getStorageAt",
            "eth_getTransactionCount",
            "eth_getBlockTransactionCountByHash",
            "eth_getBlockTransactionCountByNumber",
            "eth_getUncleCountByBlockHash",
            "eth_getUncleCountByBlockNumber",
            "eth_getBlockByHash",
            "eth_getBlockByNumber",
            "eth_getTransactionByHash",
            "eth_getTransactionByBlockHashAndIndex",
            "eth_getTransactionByBlockNumberAndIndex",
            "eth_getTransactionReceipt",
            "eth_getUncleByBlockHashAndIndex",
            "eth_getUncleByBlockNumberAndIndex",
            "eth_getLogs"
        ];
        this.inflight = void 0;
        this.sendAsyncMiddleware = (next)=>{
            return (request, callback, chainId)=>{
                // continue to next handler if method isn't part of methods list
                if (!this.singleflightJsonRpcMethods.includes(request.method)) {
                    next(request, callback, chainId);
                    return;
                }
                const key = this.requestKey(request.method, request.params || [], chainId);
                if (!this.inflight[key]) // first request -- init the empty list
                this.inflight[key] = [];
                else {
                    // already in-flight, add the callback to the list and return
                    this.inflight[key].push({
                        id: request.id,
                        callback
                    });
                    return;
                }
                // Continue down the handler chain
                next(request, (error, response, chainId)=>{
                    // callback the original request
                    callback(error, response);
                    // callback all other requests of the same kind in queue, with the
                    // same response result as from the first response.
                    for(let i = 0; i < this.inflight[key].length; i++){
                        const sub = this.inflight[key][i];
                        if (error) sub.callback(error, response);
                        else if (response) sub.callback(undefined, {
                            jsonrpc: "2.0",
                            id: sub.id,
                            result: response.result
                        });
                    }
                    // clear request key
                    delete this.inflight[key];
                }, chainId);
            };
        };
        this.requestKey = (method, params, chainId)=>{
            let key = "";
            if (chainId) key = `${chainId}:${method}:`;
            else key = `:${method}:`;
            if (!params || params.length === 0) return key + "[]";
            return key + JSON.stringify(params);
        };
        this.inflight = {};
    }
}
// JsonRpcProvider with a middleware stack. By default it will use a simple caching middleware.
class JsonRpcProvider extends (0, _ethers.ethers).providers.JsonRpcProvider {
    constructor(url, options){
        super(url, options == null ? void 0 : options.chainId);
        this._chainId = void 0;
        this._sender = void 0;
        this.send = (method, params)=>{
            return this._sender.send(method, params);
        };
        this.fetch = (method, params)=>{
            const request = {
                method: method,
                params: params,
                id: this._nextId++,
                jsonrpc: "2.0"
            };
            const result = (0, _ethers.ethers).utils.fetchJson(this.connection, JSON.stringify(request), getResult).then((result)=>{
                return result;
            }, (error)=>{
                throw error;
            });
            return result;
        };
        const chainId = options == null ? void 0 : options.chainId;
        const middlewares = options == null ? void 0 : options.middlewares;
        const blockCache = options == null ? void 0 : options.blockCache;
        this._chainId = chainId;
        // NOTE: it will either use the middleware stack passed to the constructor
        // or it will use the default caching middleware provider. It does not concat them,
        // so if you set middlewares, make sure you set the caching middleware yourself if you'd
        // like to keep using it.
        const router = new JsonRpcRouter(middlewares != null ? middlewares : [
            // loggingProviderMiddleware,
            new EagerProvider({
                chainId
            }),
            new SingleflightMiddleware(),
            new CachedProvider({
                defaultChainId: chainId,
                blockCache: blockCache
            })
        ], new JsonRpcSender(this.fetch, chainId));
        this._sender = new JsonRpcSender(router, chainId);
    }
    async getNetwork() {
        const chainId = this._chainId;
        if (chainId) {
            const network = (0, _0XsequenceNetworkConstantsEsmJs.networks)[chainId];
            const name = (network == null ? void 0 : network.name) || "";
            const ensAddress = network == null ? void 0 : network.ensAddress;
            return {
                name: name,
                chainId: chainId,
                ensAddress: ensAddress
            };
        } else {
            const chainIdHex = await this.send("eth_chainId", []);
            this._chainId = (0, _ethers.ethers).BigNumber.from(chainIdHex).toNumber();
            return this.getNetwork();
        }
    }
}
function getResult(payload) {
    if (payload.error) {
        // @TODO: not any
        const error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
    }
    return payload.result;
}

},{"../constants/dist/0xsequence-network-constants.esm.js":"9TjTm","ethers":"hdHML","@0xsequence/utils":"7jY5X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9TjTm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChainId", ()=>ChainId);
parcelHelpers.export(exports, "NetworkType", ()=>NetworkType);
parcelHelpers.export(exports, "networks", ()=>networks);
let ChainId = /*#__PURE__*/ function(ChainId) {
    ChainId[ChainId["MAINNET"] = 1] = "MAINNET";
    ChainId[ChainId["ROPSTEN"] = 3] = "ROPSTEN";
    ChainId[ChainId["RINKEBY"] = 4] = "RINKEBY";
    ChainId[ChainId["GOERLI"] = 5] = "GOERLI";
    ChainId[ChainId["KOVAN"] = 42] = "KOVAN";
    ChainId[ChainId["SEPOLIA"] = 11155111] = "SEPOLIA";
    ChainId[ChainId["POLYGON"] = 137] = "POLYGON";
    ChainId[ChainId["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
    ChainId[ChainId["POLYGON_ZKEVM"] = 1101] = "POLYGON_ZKEVM";
    ChainId[ChainId["BSC"] = 56] = "BSC";
    ChainId[ChainId["BSC_TESTNET"] = 97] = "BSC_TESTNET";
    ChainId[ChainId["OPTIMISM"] = 10] = "OPTIMISM";
    ChainId[ChainId["OPTIMISM_KOVAN"] = 69] = "OPTIMISM_KOVAN";
    ChainId[ChainId["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
    ChainId[ChainId["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
    ChainId[ChainId["ARBITRUM"] = 42161] = "ARBITRUM";
    ChainId[ChainId["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
    ChainId[ChainId["ARBITRUM_SEPOLIA"] = 421614] = "ARBITRUM_SEPOLIA";
    ChainId[ChainId["ARBITRUM_NOVA"] = 42170] = "ARBITRUM_NOVA";
    ChainId[ChainId["AVALANCHE"] = 43114] = "AVALANCHE";
    ChainId[ChainId["AVALANCHE_TESTNET"] = 43113] = "AVALANCHE_TESTNET";
    ChainId[ChainId["GNOSIS"] = 100] = "GNOSIS";
    ChainId[ChainId["BASE"] = 8453] = "BASE";
    ChainId[ChainId["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
    ChainId[ChainId["BASE_SEPOLIA"] = 84532] = "BASE_SEPOLIA";
    ChainId[ChainId["HOMEVERSE_TESTNET"] = 40875] = "HOMEVERSE_TESTNET";
    ChainId[ChainId["HOMEVERSE"] = 19011] = "HOMEVERSE";
    ChainId[ChainId["HARDHAT"] = 31337] = "HARDHAT";
    ChainId[ChainId["HARDHAT_2"] = 31338] = "HARDHAT_2";
    return ChainId;
}({});
let NetworkType = /*#__PURE__*/ function(NetworkType) {
    NetworkType["MAINNET"] = "mainnet";
    NetworkType["TESTNET"] = "testnet";
    return NetworkType;
}({});
const networks = {
    [ChainId.MAINNET]: {
        chainId: ChainId.MAINNET,
        type: NetworkType.MAINNET,
        name: "mainnet",
        title: "Ethereum",
        blockExplorer: {
            name: "Etherscan",
            rootUrl: "https://etherscan.io/"
        },
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    [ChainId.ROPSTEN]: {
        chainId: ChainId.ROPSTEN,
        type: NetworkType.TESTNET,
        name: "ropsten",
        title: "Ropsten",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Ropsten)",
            rootUrl: "https://ropsten.etherscan.io/"
        },
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        deprecated: true
    },
    [ChainId.RINKEBY]: {
        chainId: ChainId.RINKEBY,
        type: NetworkType.TESTNET,
        name: "rinkeby",
        title: "Rinkeby",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Rinkeby)",
            rootUrl: "https://rinkeby.etherscan.io/"
        },
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        deprecated: true
    },
    [ChainId.GOERLI]: {
        chainId: ChainId.GOERLI,
        type: NetworkType.TESTNET,
        name: "goerli",
        title: "Goerli",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Goerli)",
            rootUrl: "https://goerli.etherscan.io/"
        },
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        deprecated: true
    },
    [ChainId.KOVAN]: {
        chainId: ChainId.KOVAN,
        type: NetworkType.TESTNET,
        name: "kovan",
        title: "Kovan",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Kovan)",
            rootUrl: "https://kovan.etherscan.io/"
        },
        deprecated: true
    },
    [ChainId.SEPOLIA]: {
        chainId: ChainId.SEPOLIA,
        type: NetworkType.TESTNET,
        name: "sepolia",
        title: "Sepolia",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Sepolia)",
            rootUrl: "https://sepolia.etherscan.io/"
        }
    },
    [ChainId.POLYGON]: {
        chainId: ChainId.POLYGON,
        type: NetworkType.MAINNET,
        name: "polygon",
        title: "Polygon",
        blockExplorer: {
            name: "Polygonscan",
            rootUrl: "https://polygonscan.com/"
        }
    },
    [ChainId.POLYGON_MUMBAI]: {
        chainId: ChainId.POLYGON_MUMBAI,
        type: NetworkType.TESTNET,
        name: "mumbai",
        title: "Polygon Mumbai",
        testnet: true,
        blockExplorer: {
            name: "Polygonscan (Mumbai)",
            rootUrl: "https://mumbai.polygonscan.com/"
        }
    },
    [ChainId.POLYGON_ZKEVM]: {
        chainId: ChainId.POLYGON_ZKEVM,
        type: NetworkType.MAINNET,
        name: "polygon-zkevm",
        title: "Polygon zkEVM",
        blockExplorer: {
            name: "Polygonscan (zkEVM)",
            rootUrl: "https://zkevm.polygonscan.com/"
        }
    },
    [ChainId.BSC]: {
        chainId: ChainId.BSC,
        type: NetworkType.MAINNET,
        name: "bsc",
        title: "BNB Smart Chain",
        blockExplorer: {
            name: "BSCScan",
            rootUrl: "https://bscscan.com/"
        }
    },
    [ChainId.BSC_TESTNET]: {
        chainId: ChainId.BSC_TESTNET,
        type: NetworkType.TESTNET,
        name: "bsc-testnet",
        title: "BNB Smart Chain Testnet",
        testnet: true,
        blockExplorer: {
            name: "BSCScan (Testnet)",
            rootUrl: "https://testnet.bscscan.com/"
        }
    },
    [ChainId.OPTIMISM]: {
        chainId: ChainId.OPTIMISM,
        type: NetworkType.MAINNET,
        name: "optimism",
        title: "Optimism",
        blockExplorer: {
            name: "Etherscan (Optimism)",
            rootUrl: "https://optimistic.etherscan.io/"
        }
    },
    [ChainId.OPTIMISM_KOVAN]: {
        chainId: ChainId.OPTIMISM_KOVAN,
        type: NetworkType.TESTNET,
        name: "optimism-kovan",
        title: "Optimistic Kovan",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Optimism Kovan)",
            rootUrl: "https://kovan-optimistic.etherscan.io/"
        },
        deprecated: true
    },
    [ChainId.OPTIMISM_GOERLI]: {
        chainId: ChainId.OPTIMISM_GOERLI,
        type: NetworkType.TESTNET,
        name: "optimism-goerli",
        title: "Optimistic Goerli",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Optimism Goerli)",
            rootUrl: "https://goerli-optimistic.etherscan.io/"
        },
        deprecated: true
    },
    [ChainId.OPTIMISM_SEPOLIA]: {
        chainId: ChainId.OPTIMISM_SEPOLIA,
        type: NetworkType.TESTNET,
        name: "optimism-sepolia",
        title: "Optimistic Sepolia",
        testnet: true,
        blockExplorer: {
            name: "Etherscan (Optimism Sepolia)",
            rootUrl: "https://sepolia-optimistic.etherscan.io/"
        }
    },
    [ChainId.ARBITRUM]: {
        chainId: ChainId.ARBITRUM,
        type: NetworkType.MAINNET,
        name: "arbitrum",
        title: "Arbitrum One",
        blockExplorer: {
            name: "Arbiscan",
            rootUrl: "https://arbiscan.io/"
        }
    },
    [ChainId.ARBITRUM_GOERLI]: {
        chainId: ChainId.ARBITRUM_GOERLI,
        type: NetworkType.TESTNET,
        name: "arbitrum-goerli",
        title: "Arbitrum Goerli",
        testnet: true,
        blockExplorer: {
            name: "Arbiscan (Goerli Testnet)",
            rootUrl: "https://testnet.arbiscan.io/"
        },
        deprecated: true
    },
    [ChainId.ARBITRUM_SEPOLIA]: {
        chainId: ChainId.ARBITRUM_SEPOLIA,
        type: NetworkType.TESTNET,
        name: "arbitrum-sepolia",
        title: "Arbitrum Sepolia",
        testnet: true,
        blockExplorer: {
            name: "Arbiscan (Sepolia Testnet)",
            rootUrl: "https://sepolia.arbiscan.io/"
        }
    },
    [ChainId.ARBITRUM_NOVA]: {
        chainId: ChainId.ARBITRUM_NOVA,
        type: NetworkType.MAINNET,
        name: "arbitrum-nova",
        title: "Arbitrum Nova",
        blockExplorer: {
            name: "Arbiscan Nova",
            rootUrl: "https://nova.arbiscan.io/"
        }
    },
    [ChainId.AVALANCHE]: {
        chainId: ChainId.AVALANCHE,
        type: NetworkType.MAINNET,
        name: "avalanche",
        title: "Avalanche",
        blockExplorer: {
            name: "Snowtrace",
            rootUrl: "https://subnets.avax.network/c-chain/"
        }
    },
    [ChainId.AVALANCHE_TESTNET]: {
        chainId: ChainId.AVALANCHE_TESTNET,
        type: NetworkType.TESTNET,
        name: "avalanche-testnet",
        title: "Avalanche Testnet",
        testnet: true,
        blockExplorer: {
            name: "Snowtrace (Testnet)",
            rootUrl: "https://subnets-test.avax.network/c-chain/"
        }
    },
    [ChainId.GNOSIS]: {
        chainId: ChainId.GNOSIS,
        type: NetworkType.MAINNET,
        name: "gnosis",
        title: "Gnosis Chain",
        blockExplorer: {
            name: "Gnosis Chain Explorer",
            rootUrl: "https://blockscout.com/xdai/mainnet/"
        }
    },
    [ChainId.BASE]: {
        chainId: ChainId.BASE,
        type: NetworkType.MAINNET,
        name: "base",
        title: "Base (Coinbase)",
        blockExplorer: {
            name: "Base Explorer",
            rootUrl: "https://basescan.org/"
        }
    },
    [ChainId.BASE_GOERLI]: {
        chainId: ChainId.BASE_GOERLI,
        type: NetworkType.TESTNET,
        name: "base-goerli",
        title: "Base Goerli",
        testnet: true,
        blockExplorer: {
            name: "Base Goerli Explorer",
            rootUrl: "https://goerli.basescan.org/"
        },
        deprecated: true
    },
    [ChainId.BASE_SEPOLIA]: {
        chainId: ChainId.BASE_SEPOLIA,
        type: NetworkType.TESTNET,
        name: "base-sepolia",
        title: "Base Sepolia",
        testnet: true,
        blockExplorer: {
            name: "Base Sepolia Explorer",
            rootUrl: "https://base-sepolia.blockscout.com/"
        },
        deprecated: true
    },
    [ChainId.HOMEVERSE]: {
        chainId: ChainId.HOMEVERSE,
        type: NetworkType.MAINNET,
        name: "homeverse",
        title: "Oasys Homeverse",
        blockExplorer: {
            name: "Oasys Homeverse Explorer",
            rootUrl: "https://explorer.oasys.homeverse.games/"
        }
    },
    [ChainId.HOMEVERSE_TESTNET]: {
        chainId: ChainId.HOMEVERSE_TESTNET,
        type: NetworkType.TESTNET,
        name: "homeverse-testnet",
        title: "Oasys Homeverse Testnet",
        testnet: true,
        blockExplorer: {
            name: "Oasys Homeverse Explorer (Testnet)",
            rootUrl: "https://explorer.testnet.oasys.homeverse.games/"
        }
    },
    [ChainId.HARDHAT]: {
        chainId: ChainId.HARDHAT,
        name: "hardhat",
        title: "Hardhat (local testnet)"
    },
    [ChainId.HARDHAT_2]: {
        chainId: ChainId.HARDHAT_2,
        name: "hardhat2",
        title: "Hardhat (local testnet)"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7jY5X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Logger", ()=>Logger);
parcelHelpers.export(exports, "PromiseCache", ()=>PromiseCache);
parcelHelpers.export(exports, "base64Decode", ()=>base64Decode);
parcelHelpers.export(exports, "base64DecodeObject", ()=>base64DecodeObject);
parcelHelpers.export(exports, "base64Encode", ()=>base64Encode);
parcelHelpers.export(exports, "base64EncodeObject", ()=>base64EncodeObject);
parcelHelpers.export(exports, "checkProperties", ()=>checkProperties);
parcelHelpers.export(exports, "configureLogger", ()=>configureLogger);
parcelHelpers.export(exports, "deepCopy", ()=>deepCopy);
parcelHelpers.export(exports, "defineReadOnly", ()=>defineReadOnly);
parcelHelpers.export(exports, "encodeMessageDigest", ()=>encodeMessageDigest);
parcelHelpers.export(exports, "encodeTypedDataDigest", ()=>encodeTypedDataDigest);
parcelHelpers.export(exports, "encodeTypedDataHash", ()=>encodeTypedDataHash);
parcelHelpers.export(exports, "getEthersConnectionInfo", ()=>getEthersConnectionInfo);
parcelHelpers.export(exports, "getRandomInt", ()=>getRandomInt);
parcelHelpers.export(exports, "getStatic", ()=>getStatic);
parcelHelpers.export(exports, "isBigNumberish", ()=>isBigNumberish);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "jwtDecodeClaims", ()=>jwtDecodeClaims);
parcelHelpers.export(exports, "logger", ()=>logger);
parcelHelpers.export(exports, "packMessageData", ()=>packMessageData);
parcelHelpers.export(exports, "promisify", ()=>promisify);
parcelHelpers.export(exports, "queryStringFromObject", ()=>queryStringFromObject);
parcelHelpers.export(exports, "queryStringToObject", ()=>queryStringToObject);
parcelHelpers.export(exports, "resolveProperties", ()=>resolveProperties);
parcelHelpers.export(exports, "sanitizeAlphanumeric", ()=>sanitizeAlphanumeric);
parcelHelpers.export(exports, "sanitizeHost", ()=>sanitizeHost);
parcelHelpers.export(exports, "sanitizeNumberString", ()=>sanitizeNumberString);
parcelHelpers.export(exports, "shallowCopy", ()=>shallowCopy);
parcelHelpers.export(exports, "sleep", ()=>sleep);
parcelHelpers.export(exports, "subDigestOf", ()=>subDigestOf);
parcelHelpers.export(exports, "urlClean", ()=>urlClean);
var _jsBase64 = require("js-base64");
var _ethers = require("ethers");
var process = require("6db6ed82b59b7f6c");
const base64Encode = (val)=>{
    return (0, _jsBase64.Base64).encode(val, true);
};
const base64EncodeObject = (obj)=>{
    return (0, _jsBase64.Base64).encode(JSON.stringify(obj), true);
};
const base64Decode = (encodedString)=>{
    if (encodedString === null || encodedString === undefined) return undefined;
    return (0, _jsBase64.Base64).decode(encodedString);
};
const base64DecodeObject = (encodedObject)=>{
    if (encodedObject === null || encodedObject === undefined) return undefined;
    return JSON.parse((0, _jsBase64.Base64).decode(encodedObject));
};
// ethers implement this method but doesn't exports it
function isBigNumberish(value) {
    return value != null && ((0, _ethers.BigNumber).isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, _ethers.utils).isHexString(value) || typeof value === "bigint" || (0, _ethers.utils).isBytes(value));
}
const encodeMessageDigest = (message)=>{
    if (typeof message === "string") return (0, _ethers.ethers).utils.arrayify((0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.toUtf8Bytes(message)));
    else return (0, _ethers.ethers).utils.arrayify((0, _ethers.ethers).utils.keccak256(message));
};
// packMessageData encodes the specified data ready for the Sequence Wallet contracts.
const packMessageData = (walletAddress, chainId, digest)=>{
    return (0, _ethers.ethers).utils.solidityPack([
        "string",
        "uint256",
        "address",
        "bytes32"
    ], [
        "\x19\x01",
        chainId,
        walletAddress,
        digest
    ]);
};
const subDigestOf = (address, chainId, digest)=>{
    return (0, _ethers.ethers).utils.keccak256(packMessageData(address, chainId, digest));
};
const isNode = ()=>{
    if (typeof window === "undefined" && typeof process === "object") return true;
    else return false;
};
const isBrowser = ()=>!isNode();
const jwtDecodeClaims = (jwt)=>{
    const parts = jwt.split(".");
    if (parts.length !== 3) throw new Error("invalid jwt");
    const claims = JSON.parse((0, _jsBase64.Base64).decode(parts[1]));
    return claims;
};
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var logLevel = /*#__PURE__*/ function(logLevel) {
    logLevel[logLevel["DEBUG"] = 1] = "DEBUG";
    logLevel[logLevel["INFO"] = 2] = "INFO";
    logLevel[logLevel["WARN"] = 3] = "WARN";
    logLevel[logLevel["ERROR"] = 4] = "ERROR";
    logLevel[logLevel["DISABLED"] = 5] = "DISABLED";
    return logLevel;
}(logLevel || {});
class Logger {
    constructor(config){
        this.config = config;
        this.logLevel = void 0;
        this.configure(config);
    }
    configure(config) {
        this.config = _extends({}, this.config, config);
        switch(this.config.logLevel){
            case "DEBUG":
                this.logLevel = logLevel.DEBUG;
                break;
            case "INFO":
                this.logLevel = logLevel.INFO;
                break;
            case "WARN":
                this.logLevel = logLevel.WARN;
                break;
            case "ERROR":
                this.logLevel = logLevel.ERROR;
                break;
            case "DISABLED":
                this.logLevel = logLevel.DISABLED;
                break;
            default:
                this.logLevel = logLevel.INFO;
                break;
        }
        // undefined silence value will disable the default silence flag
        if (this.config.silence === undefined) this.config.silence = false;
    }
    debug(message, ...optionalParams) {
        if (this.config.silence === true) return;
        if (this.logLevel === logLevel.DEBUG) console.log(message, ...optionalParams);
    }
    info(message, ...optionalParams) {
        if (this.config.silence === true) return;
        if (this.logLevel <= logLevel.INFO) console.log(message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
        if (this.config.silence === true) return;
        if (this.logLevel <= logLevel.WARN) {
            console.warn(message, ...optionalParams);
            if (this.config.onwarn) this.config.onwarn(message, optionalParams);
        }
    }
    error(message, ...optionalParams) {
        if (this.config.silence === true) return;
        if (this.logLevel <= logLevel.ERROR) {
            console.error(message, ...optionalParams);
            if (this.config.onerror) this.config.onerror(message, optionalParams);
        }
    }
}
const logger = new Logger({
    logLevel: "INFO",
    // By default we silence the logger. In tests we should call `configureLogger`
    // below to set silence: false.
    silence: true
});
const configureLogger = (config)=>logger.configure(config);
const getEthersConnectionInfo = (url, projectAccessKey, jwt)=>{
    const headers = {};
    if (jwt && jwt.length > 0) headers["Authorization"] = `BEARER ${jwt}`;
    if (projectAccessKey && projectAccessKey.length > 0) headers["X-Access-Key"] = projectAccessKey;
    return {
        url,
        headers,
        skipFetchSetup: true,
        fetchOptions: {
            mode: "cors",
            cache: "force-cache",
            credentials: "same-origin",
            redirect: "follow",
            referrer: "client"
        }
    };
};
class PromiseCache {
    constructor(){
        this.cache = void 0;
        this.cache = new Map();
    }
    do(key, validMilliseconds, task, ...args) {
        key = `${key}:${(0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.toUtf8Bytes(JSON.stringify(args, deterministically)))}`;
        let entry = this.cache.get(key);
        if (entry) {
            if (entry.expiration) {
                if (new Date() >= entry.expiration) {
                    entry = undefined;
                    this.cache.delete(key);
                }
            }
        }
        if (!entry) {
            const entry_ = {
                promise: task(...args)
            };
            if (validMilliseconds !== undefined) entry_.promise = entry_.promise.then((result)=>{
                entry_.expiration = new Date(Date.now() + validMilliseconds);
                return result;
            });
            entry = entry_;
            this.cache.set(key, entry);
        }
        return entry.promise;
    }
}
function deterministically(_key, value) {
    if (typeof value === "object" && value !== null && !Array.isArray(value)) return Object.fromEntries(Object.entries(value).sort());
    return value;
}
function promisify(f, thisContext) {
    return function(...a) {
        const args = Array.prototype.slice.call(a);
        return new Promise(async (resolve, reject)=>{
            try {
                args.push((err, result)=>err ? reject(err) : resolve(result));
                await f.apply(thisContext, args);
            } catch (e) {
                reject(e);
            }
        });
    };
}
function queryStringFromObject(name, obj) {
    const k = encodeURIComponent(name);
    const v = encodeURIComponent(JSON.stringify(obj));
    return `${k}=${v}`;
}
function queryStringToObject(qs) {
    const p = qs.split("&");
    const o = {};
    for (const v of p){
        const z = v.split("=");
        o[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]));
    }
    return o;
}
const getRandomInt = (min = 0, max = Number.MAX_SAFE_INTEGER)=>{
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
// sanitizeNumberString accepts a number string and returns back a clean number string.
// For example, input '1234.5678' will return '1234.5678' but '12javascript:{}etc' will return '12'
const sanitizeNumberString = (numString)=>{
    if (!numString || typeof numString !== "string") return "";
    const v = numString.match(/[\d.]+/);
    return v && v.length > 0 ? v[0].trim() : "";
};
// sanitizeAlphanumeric accepts any string and returns alphanumeric contents only
const sanitizeAlphanumeric = (alphanum)=>{
    if (!alphanum || typeof alphanum !== "string") return "";
    const v = alphanum.match(/[\w\s\d]+/);
    return v && v.length > 0 ? v[0].trim() : "";
};
// sanitizeHost accepts any string and returns valid host string
const sanitizeHost = (host)=>{
    if (!host || typeof host !== "string") return "";
    const v = host.match(/[\w\d.\-:\/]+/);
    return v && v.length > 0 ? v[0].trim() : "";
};
const sleep = (t)=>{
    return new Promise((resolve)=>{
        const timeout = setTimeout(()=>{
            clearTimeout(timeout);
            resolve();
        }, t);
    });
};
const encodeTypedDataHash = (typedData)=>{
    const types = _extends({}, typedData.types);
    // remove EIP712Domain key from types as ethers will auto-gen it in
    // the hash encoder below
    delete types["EIP712Domain"];
    return (0, _ethers.ethers).utils._TypedDataEncoder.hash(typedData.domain, types, typedData.message);
};
const encodeTypedDataDigest = (typedData)=>{
    return (0, _ethers.ethers).utils.arrayify(encodeTypedDataHash(typedData));
};
const { defineReadOnly, getStatic, resolveProperties, checkProperties, shallowCopy, deepCopy } = (0, _ethers.utils);
// urlClean removes double slashes from url path
const urlClean = (url)=>url.replace(/([^:]\/)\/+/g, "$1");

},{"6db6ed82b59b7f6c":"d5jf4","js-base64":"9GjXb","ethers":"hdHML","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3UL2G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Account", ()=>Account);
parcelHelpers.export(exports, "isAccount", ()=>isAccount);
var _abi = require("@0xsequence/abi");
var _core = require("@0xsequence/core");
var _migration = require("@0xsequence/migration");
var _relayer = require("@0xsequence/relayer");
var _utils = require("@0xsequence/utils");
var _wallet = require("@0xsequence/wallet");
var _ethers = require("ethers");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function isPromise(value) {
    return !!value && typeof value.then === "function";
}
function isDeferrable(value) {
    // The value is deferrable if any of the properties is a Promises
    if (typeof value === "object") return Object.keys(value).some((key)=>isPromise(value[key]));
    return false;
}
function encodeGasRefundTransaction(option) {
    if (!option) return [];
    const value = (0, _ethers.ethers).BigNumber.from(option.value);
    switch(option.token.type){
        case (0, _relayer.proto).FeeTokenType.UNKNOWN:
            return [
                {
                    delegateCall: false,
                    revertOnError: true,
                    gasLimit: option.gasLimit,
                    to: option.to,
                    value: value.toHexString(),
                    data: []
                }
            ];
        case (0, _relayer.proto).FeeTokenType.ERC20_TOKEN:
            if (!option.token.contractAddress) throw new Error(`No contract address for ERC-20 fee option`);
            return [
                {
                    delegateCall: false,
                    revertOnError: true,
                    gasLimit: option.gasLimit,
                    to: option.token.contractAddress,
                    value: 0,
                    data: new (0, _ethers.ethers).utils.Interface([
                        {
                            constant: false,
                            inputs: [
                                {
                                    type: "address"
                                },
                                {
                                    type: "uint256"
                                }
                            ],
                            name: "transfer",
                            outputs: [],
                            type: "function"
                        }
                    ]).encodeFunctionData("transfer", [
                        option.to,
                        value.toHexString()
                    ])
                }
            ];
        default:
            throw new Error(`Unhandled fee token type ${option.token.type}`);
    }
}
class AccountSigner {
    constructor(account, chainId, options){
        this.account = account;
        this.chainId = chainId;
        this.options = options;
        this._isSigner = true;
    }
    get provider() {
        return this.account.providerFor(this.chainId);
    }
    async getAddress() {
        return this.account.address;
    }
    signMessage(message) {
        var _this$options$cantVal, _this$options;
        return this.account.signMessage(message, this.chainId, (_this$options$cantVal = (_this$options = this.options) == null ? void 0 : _this$options.cantValidateBehavior) != null ? _this$options$cantVal : "throw");
    }
    async defaultSelectFee(_txs, options) {
        // If no options, return undefined
        if (options.length === 0) return undefined;
        // If there are multiple options, try them one by one
        // until we find one that satisfies the balance requirement
        const balanceOfAbi = [
            {
                constant: true,
                inputs: [
                    {
                        type: "address"
                    }
                ],
                name: "balanceOf",
                outputs: [
                    {
                        type: "uint256"
                    }
                ],
                type: "function"
            }
        ];
        for (const option of options){
            if (option.token.type === (0, _relayer.proto).FeeTokenType.UNKNOWN) {
                // Native token
                const balance = await this.getBalance();
                if (balance.gte((0, _ethers.ethers).BigNumber.from(option.value))) return option;
            } else if (option.token.contractAddress && option.token.type === (0, _relayer.proto).FeeTokenType.ERC20_TOKEN) {
                // ERC20 token
                const token = new (0, _ethers.ethers).Contract(option.token.contractAddress, balanceOfAbi, this.provider);
                const balance = await token.balanceOf(this.account.address);
                if (balance.gte((0, _ethers.ethers).BigNumber.from(option.value))) return option;
            }
        }
        throw new Error("No fee option available - not enough balance");
    }
    async sendTransaction(txsPromise, options) {
        var _this$options$stubSig, _this$options2, _this$options$selectF, _this$options3, _this$options4;
        const txs = isDeferrable(txsPromise) ? await (0, _ethers.ethers).utils.resolveProperties(txsPromise) : txsPromise;
        const prepare = await this.account.prepareTransactions({
            txs,
            chainId: this.chainId,
            stubSignatureOverrides: (_this$options$stubSig = (_this$options2 = this.options) == null ? void 0 : _this$options2.stubSignatureOverrides) != null ? _this$options$stubSig : new Map(),
            simulateForFeeOptions: options == null ? void 0 : options.simulateForFeeOptions
        });
        const selectMethod = (_this$options$selectF = (_this$options3 = this.options) == null ? void 0 : _this$options3.selectFee) != null ? _this$options$selectF : this.defaultSelectFee.bind(this);
        const feeOption = await selectMethod(txs, prepare.feeOptions);
        const finalTransactions = [
            ...prepare.transactions,
            ...encodeGasRefundTransaction(feeOption)
        ];
        return this.account.sendTransaction(finalTransactions, this.chainId, prepare.feeQuote, undefined, undefined, (_this$options4 = this.options) != null && _this$options4.nonceSpace ? {
            nonceSpace: this.options.nonceSpace
        } : undefined); // Will always have a transaction response
    }
    getBalance(blockTag) {
        return this.provider.getBalance(this.account.address, blockTag);
    }
    call(transaction, blockTag) {
        return this.provider.call(transaction, blockTag);
    }
    async resolveName(name) {
        const res = await this.provider.resolveName(name);
        if (!res) throw new Error(`Could not resolve name ${name}`);
        return res;
    }
    connect(_provider) {
        throw new Error("Method not implemented.");
    }
    signTransaction(transaction) {
        throw new Error("Method not implemented.");
    }
    getTransactionCount(blockTag) {
        throw new Error("Method not implemented.");
    }
    estimateGas(transaction) {
        throw new Error("Method not implemented.");
    }
    getChainId() {
        return Promise.resolve((0, _ethers.ethers).BigNumber.from(this.chainId).toNumber());
    }
    getGasPrice() {
        throw new Error("Method not implemented.");
    }
    getFeeData() {
        throw new Error("Method not implemented.");
    }
    checkTransaction(transaction) {
        throw new Error("Method not implemented.");
    }
    populateTransaction(transaction) {
        throw new Error("Method not implemented.");
    }
    _checkProvider(operation) {
        throw new Error("Method not implemented.");
    }
}
class Chain0Reader {
    async isDeployed(_wallet) {
        return false;
    }
    async implementation(_wallet) {
        return undefined;
    }
    async imageHash(_wallet) {
        return undefined;
    }
    async nonce(_wallet, _space) {
        return (0, _ethers.ethers).constants.Zero;
    }
    async isValidSignature(_wallet, _digest, _signature) {
        throw new Error("Method not supported.");
    }
}
class Account {
    constructor(options){
        this.address = void 0;
        this.networks = void 0;
        this.tracker = void 0;
        this.contexts = void 0;
        this.migrator = void 0;
        this.migrations = void 0;
        this.orchestrator = void 0;
        this.jwt = void 0;
        this.projectAccessKey = void 0;
        this.address = (0, _ethers.ethers).utils.getAddress(options.address);
        this.contexts = options.contexts;
        this.tracker = options.tracker;
        this.networks = options.networks;
        this.orchestrator = options.orchestrator;
        this.jwt = options.jwt;
        this.projectAccessKey = options.projectAccessKey;
        this.migrations = options.migrations || (0, _migration.defaults).DefaultMigrations;
        this.migrator = new (0, _migration.migrator).Migrator(options.tracker, this.migrations, this.contexts);
    }
    getSigner(chainId, options) {
        return new AccountSigner(this, chainId, options);
    }
    static async new(options) {
        var _options$migrations;
        const mig = new (0, _migration.migrator).Migrator(options.tracker, (_options$migrations = options.migrations) != null ? _options$migrations : (0, _migration.defaults).DefaultMigrations, options.contexts);
        const lastMigration = mig.lastMigration();
        const lastCoder = lastMigration.configCoder;
        const config = lastCoder.fromSimple(options.config);
        const imageHash = lastCoder.imageHashOf(config);
        const context = options.contexts[lastMigration.version];
        const address = (0, _core.commons).context.addressOf(context, imageHash);
        await options.tracker.saveCounterfactualWallet({
            config,
            context: Object.values(options.contexts)
        });
        return new Account({
            address,
            tracker: options.tracker,
            contexts: options.contexts,
            networks: options.networks,
            orchestrator: options.orchestrator,
            migrations: options.migrations,
            projectAccessKey: options.projectAccessKey
        });
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    get version() {
        return this.migrator.lastMigration().version;
    }
    get coders() {
        const lastMigration = this.migrator.lastMigration();
        return {
            signature: lastMigration.signatureCoder,
            config: lastMigration.configCoder
        };
    }
    network(chainId) {
        const tcid = (0, _ethers.ethers).BigNumber.from(chainId);
        const found = this.networks.find((n)=>tcid.eq(n.chainId));
        if (!found) throw new Error(`Network not found for chainId ${chainId}`);
        return found;
    }
    providerFor(chainId) {
        const found = this.network(chainId);
        if (!found.provider && !found.rpcUrl) throw new Error(`Provider not found for chainId ${chainId}`);
        return found.provider || new (0, _ethers.ethers).providers.StaticJsonRpcProvider((0, _utils.getEthersConnectionInfo)(found.rpcUrl, this.projectAccessKey, this.jwt), {
            name: "",
            chainId: (0, _ethers.ethers).BigNumber.from(chainId).toNumber()
        });
    }
    reader(chainId) {
        if ((0, _ethers.ethers).constants.Zero.eq(chainId)) return new Chain0Reader();
        // TODO: Networks should be able to provide a reader directly
        // and we should default to the on-chain reader
        return new (0, _core.commons).reader.OnChainReader(this.providerFor(chainId));
    }
    relayer(chainId) {
        const found = this.network(chainId);
        if (!found.relayer) throw new Error(`Relayer not found for chainId ${chainId}`);
        if ((0, _relayer.isRelayer)(found.relayer)) return found.relayer;
        return new (0, _relayer.RpcRelayer)(_extends({}, found.relayer, {
            projectAccessKey: this.projectAccessKey,
            jwtAuth: this.jwt
        }));
    }
    setOrchestrator(orchestrator) {
        this.orchestrator = orchestrator;
    }
    setJwt(jwt) {
        this.jwt = jwt;
    }
    contextFor(version) {
        const ctx = this.contexts[version];
        if (!ctx) throw new Error(`Context not found for version ${version}`);
        return ctx;
    }
    walletForStatus(chainId, status) {
        const coder = (0, _core.universal).coderFor(status.version);
        return this.walletFor(chainId, this.contextFor(status.version), status.config, coder);
    }
    walletFor(chainId, context, config, coders) {
        const isNetworkZero = (0, _ethers.ethers).constants.Zero.eq(chainId);
        return new (0, _wallet.Wallet)({
            config,
            context,
            chainId,
            coders,
            relayer: isNetworkZero ? undefined : this.relayer(chainId),
            address: this.address,
            orchestrator: this.orchestrator,
            reader: this.reader(chainId)
        });
    }
    // Get the status of the account on a given network
    // this does the following process:
    // 1. Get the current on-chain status of the wallet (version + imageHash)
    // 2. Get any pending migrations that have been signed by the wallet
    // 3. Get any pending configuration updates that have been signed by the wallet
    // 4. Fetch reverse lookups for both on-chain and pending configurations
    async status(chainId, longestPath = false) {
        var _this = this;
        const isDeployedPromise = this.reader(chainId).isDeployed(this.address);
        const counterfactualImageHashPromise = this.tracker.imageHashOfCounterfactualWallet({
            wallet: this.address
        }).then((r)=>{
            if (!r) throw new Error(`Counterfactual imageHash not found for wallet ${this.address}`);
            return r;
        });
        const counterFactualVersionPromise = counterfactualImageHashPromise.then((r)=>{
            return (0, _migration.version).counterfactualVersion(this.address, r.imageHash, Object.values(this.contexts));
        });
        const onChainVersionPromise = async function() {
            const isDeployed = await isDeployedPromise;
            if (!isDeployed) return counterFactualVersionPromise;
            const implementation = await _this.reader(chainId).implementation(_this.address);
            if (!implementation) throw new Error(`Implementation not found for wallet ${_this.address}`);
            const versions = Object.values(_this.contexts);
            for(let i = 0; i < versions.length; i++){
                if (versions[i].mainModule === implementation || versions[i].mainModuleUpgradable === implementation) return versions[i].version;
            }
            throw new Error(`Version not found for implementation ${implementation}`);
        }();
        const onChainImageHashPromise = async function() {
            const deployedImageHash = await _this.reader(chainId).imageHash(_this.address);
            if (deployedImageHash) return deployedImageHash;
            const counterfactualImageHash = await counterfactualImageHashPromise;
            if (counterfactualImageHash) return counterfactualImageHash.imageHash;
            throw new Error(`On-chain imageHash not found for wallet ${_this.address}`);
        }();
        const onChainConfigPromise = async function() {
            const onChainImageHash = await onChainImageHashPromise;
            const onChainConfig = await _this.tracker.configOfImageHash({
                imageHash: onChainImageHash
            });
            if (onChainConfig) return onChainConfig;
            throw new Error(`On-chain config not found for imageHash ${onChainImageHash}`);
        }();
        const onChainVersion = await onChainVersionPromise;
        const onChainImageHash = await onChainImageHashPromise;
        let fromImageHash = onChainImageHash;
        let lastVersion = onChainVersion;
        let signedMigrations = [];
        if (onChainVersion !== this.version) {
            // We either need to use the presigned configuration updates, or we haven't performed
            // any updates yet, so we can only use the on-chain imageHash as-is
            const presignedMigrate = await this.migrator.getAllMigratePresignedTransaction({
                address: this.address,
                fromImageHash: onChainImageHash,
                fromVersion: onChainVersion,
                chainId
            });
            // The migrator returns the original version and imageHash
            // if no presigned migration is found, so no need to check here
            fromImageHash = presignedMigrate.lastImageHash;
            lastVersion = presignedMigrate.lastVersion;
            signedMigrations = presignedMigrate.signedMigrations;
        }
        const presigned = await this.tracker.loadPresignedConfiguration({
            wallet: this.address,
            fromImageHash: fromImageHash,
            longestPath
        });
        const imageHash = presigned && presigned.length > 0 ? presigned[presigned.length - 1].nextImageHash : fromImageHash;
        const config = await this.tracker.configOfImageHash({
            imageHash
        });
        if (!config) throw new Error(`Config not found for imageHash ${imageHash}`);
        const isDeployed = await isDeployedPromise;
        const counterfactualImageHash = await counterfactualImageHashPromise;
        const checkpoint = (0, _core.universal).coderFor(lastVersion).config.checkpointOf(config);
        return {
            original: _extends({}, counterfactualImageHash, {
                version: await counterFactualVersionPromise
            }),
            onChain: {
                imageHash: onChainImageHash,
                config: await onChainConfigPromise,
                version: onChainVersion,
                deployed: isDeployed
            },
            fullyMigrated: lastVersion === this.version,
            signedMigrations,
            version: lastVersion,
            presignedConfigurations: presigned,
            imageHash,
            config,
            checkpoint,
            canOnchainValidate: onChainVersion === this.version && isDeployed
        };
    }
    mustBeFullyMigrated(status) {
        if (!status.fullyMigrated) throw new Error(`Wallet ${this.address} is not fully migrated`);
    }
    async predecorateSignedTransactions(status, chainId) {
        // Request signed predecorate transactions from child wallets
        const bundles = await this.orchestrator.predecorateSignedTransactions({
            chainId
        });
        // Get signed predecorate transaction
        const predecorated = await this.predecorateTransactions([], status, chainId);
        if ((0, _core.commons).transaction.fromTransactionish(this.address, predecorated).length > 0) // Sign it
        bundles.push(await this.signTransactions(predecorated, chainId));
        return bundles;
    }
    async predecorateTransactions(txs, status, chainId) {
        // if onchain wallet config is not up to date
        // then we should append an extra transaction that updates it
        // to the latest "lazy" state
        if (status.onChain.imageHash !== status.imageHash) {
            const wallet = this.walletForStatus(chainId, status);
            const updateConfig = await wallet.buildUpdateConfigurationTransaction(status.config);
            return [
                Array.isArray(txs) ? txs : [
                    txs
                ],
                updateConfig.transactions
            ].flat();
        }
        return txs;
    }
    async decorateTransactions(bundles, status, chainId) {
        var _chainId, _bundles$;
        if (!Array.isArray(bundles)) // Recurse with array
        return this.decorateTransactions([
            bundles
        ], status, chainId);
        // Default to chainId of first bundle when not supplied
        chainId = (_chainId = chainId) != null ? _chainId : bundles[0].chainId;
        const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId);
        const hasBootstrapTxs = bootstrapBundle.transactions.length > 0;
        if (!hasBootstrapTxs && bundles.length === 1) return bundles[0];
        // Intent defaults to first bundle when no bootstrap transaction
        const { entrypoint } = hasBootstrapTxs ? bootstrapBundle : bundles[0];
        const decoratedBundle = {
            entrypoint,
            chainId,
            // Intent of the first bundle is used
            intent: (_bundles$ = bundles[0]) == null ? void 0 : _bundles$.intent,
            transactions: [
                ...bootstrapBundle.transactions,
                ...bundles.map((bundle)=>({
                        to: bundle.entrypoint,
                        data: (0, _core.commons).transaction.encodeBundleExecData(bundle),
                        gasLimit: 0,
                        delegateCall: false,
                        revertOnError: true,
                        value: 0
                    }))
            ]
        };
        // Re-compute the meta-transaction id to use the guest module subdigest
        if (!status.onChain.deployed) {
            const id = (0, _core.commons).transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, chainId, decoratedBundle.transactions);
            if (decoratedBundle.intent === undefined) decoratedBundle.intent = {
                id,
                wallet: this.address
            };
            else decoratedBundle.intent.id = id;
        }
        return decoratedBundle;
    }
    async decorateSignature(signature, status) {
        if (!status.presignedConfigurations || status.presignedConfigurations.length === 0) return signature;
        const coder = this.coders.signature;
        const chain = status.presignedConfigurations.map((c)=>c.signature);
        const chainedSignature = coder.chainSignatures(signature, chain);
        return coder.trim(chainedSignature);
    }
    async publishWitness() {
        const digest = (0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.toUtf8Bytes(`This is a Sequence account woo! ${Date.now()}`));
        const signature = await this.signDigest(digest, 0, false);
        const decoded = this.coders.signature.decode(signature);
        const signatures = this.coders.signature.signaturesOfDecoded(decoded);
        return this.tracker.saveWitnesses({
            wallet: this.address,
            digest,
            chainId: 0,
            signatures
        });
    }
    async signDigest(digest, chainId, decorate = true, cantValidateBehavior = "ignore", metadata) {
        // If we are signing a digest for chainId zero then we can never be fully migrated
        // because Sequence v1 doesn't allow for signing a message on "all chains"
        // So we ignore the state on "chain zero" and instead use one of the states of the networks
        // wallet-webapp should ensure the wallet is as migrated as possible, trying to mimic
        // the behaviour of being migrated on all chains
        const chainRef = (0, _ethers.ethers).constants.Zero.eq(chainId) ? this.networks[0].chainId : chainId;
        const status = await this.status(chainRef);
        this.mustBeFullyMigrated(status);
        // Check if we can validate onchain and what to do if we can't
        // revert early, since there is no point in signing a digest now
        if (!status.canOnchainValidate && cantValidateBehavior === "throw") throw new Error("Wallet cannot validate onchain");
        const wallet = this.walletForStatus(chainId, status);
        const signature = await wallet.signDigest(digest, metadata);
        const decorated = decorate ? this.decorateSignature(signature, status) : signature;
        // If the wallet can't validate onchain then we
        // need to prefix the decorated signature with all deployments and migrations
        // aka doing a bootstrap using EIP-6492
        if (!status.canOnchainValidate) switch(cantValidateBehavior){
            // NOTICE: We covered this case before signing the digest
            // case 'throw':
            //   throw new Error('Wallet cannot validate on-chain')
            case "ignore":
                return decorated;
            case "eip6492":
                return this.buildEIP6492Signature(await decorated, status, chainId);
        }
        return decorated;
    }
    buildOnChainSignature(digest) {
        const subdigest = (0, _core.commons).signature.subdigestOf({
            digest: (0, _ethers.ethers).utils.hexlify(digest),
            chainId: 0,
            address: this.address
        });
        const hexSubdigest = (0, _ethers.ethers).utils.hexlify(subdigest);
        const config = this.coders.config.fromSimple({
            // Threshold *only* needs to be > 0, this is not a magic number
            // we only use 2 ** 15 because it may lead to lower gas costs in some chains
            threshold: 32768,
            checkpoint: 0,
            signers: [],
            subdigests: [
                hexSubdigest
            ]
        });
        const walletInterface = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModule.abi);
        const bundle = {
            entrypoint: this.address,
            transactions: [
                {
                    to: this.address,
                    data: walletInterface.encodeFunctionData(// *NEVER* use updateImageHash here, as it would effectively destroy the wallet
                    // setExtraImageHash sets an additional imageHash, without changing the current one
                    "setExtraImageHash", [
                        this.coders.config.imageHashOf(config),
                        // 2 ** 255 instead of max uint256, to have more zeros in the calldata
                        "57896044618658097711785492504343953926634992332820282019728792003956564819968"
                    ]),
                    // Conservative gas limit, used because the current relayer
                    // has trouble estimating gas for this transaction
                    gasLimit: 250000
                }
            ]
        };
        // Fire and forget request to save the config
        this.tracker.saveWalletConfig({
            config
        });
        // Encode a signature proof for the given subdigest
        // use `chainId = 0` to make it simpler, as this signature is only a proof
        const signature = this.coders.signature.encodeSigners(config, new Map(), [
            hexSubdigest
        ], 0).encoded;
        return {
            bundle,
            signature
        };
    }
    async buildEIP6492Signature(signature, status, chainId) {
        const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId);
        if (bootstrapBundle.transactions.length === 0) throw new Error("Cannot build EIP-6492 signature without bootstrap transactions");
        const encoded = (0, _ethers.ethers).utils.defaultAbiCoder.encode([
            "address",
            "bytes",
            "bytes"
        ], [
            bootstrapBundle.entrypoint,
            (0, _core.commons).transaction.encodeBundleExecData(bootstrapBundle),
            signature
        ]);
        return (0, _ethers.ethers).utils.solidityPack([
            "bytes",
            "bytes32"
        ], [
            encoded,
            (0, _core.commons).EIP6492.EIP_6492_SUFFIX
        ]);
    }
    async editConfig(changes) {
        const currentConfig = await this.status(0).then((s)=>s.config);
        const newConfig = this.coders.config.editConfig(currentConfig, _extends({}, changes, {
            checkpoint: this.coders.config.checkpointOf(currentConfig).add(1)
        }));
        return this.updateConfig(newConfig);
    }
    async updateConfig(config) {
        // config should be for the current version of the wallet
        if (!this.coders.config.isWalletConfig(config)) throw new Error(`Invalid config for wallet ${this.address}`);
        const nextImageHash = this.coders.config.imageHashOf(config);
        // sign an update config struct
        const updateStruct = this.coders.signature.hashSetImageHash(nextImageHash);
        // sign the update struct, using chain id 0
        const signature = await this.signDigest(updateStruct, 0, false);
        // save the presigned transaction to the sessions tracker
        await this.tracker.savePresignedConfiguration({
            wallet: this.address,
            nextConfig: config,
            signature
        });
        // safety check, tracker should have a reverse lookup for the imageHash
        // outside of the local cache
        const reverseConfig = await this.tracker.configOfImageHash({
            imageHash: nextImageHash,
            noCache: true
        });
        if (!reverseConfig || this.coders.config.imageHashOf(reverseConfig) !== nextImageHash) throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`);
    }
    /**
   *  This method is used to bootstrap the wallet on a given chain.
   *  this deploys the wallets and executes all the necessary transactions
   *  for that wallet to start working with the given version.
   *
   *  This usually involves: (a) deploying the wallet, (b) executing migrations
   *
   *  Notice: It should NOT explicitly include chained signatures. Unless internally used
   *  by any of the migrations.
   *
   */ async buildBootstrapTransactions(status, chainId) {
        var _bundle$transactions;
        const bundle = await this.orchestrator.buildDeployTransaction({
            chainId
        });
        const transactions = (_bundle$transactions = bundle == null ? void 0 : bundle.transactions) != null ? _bundle$transactions : [];
        // Add wallet deployment if needed
        if (!status.onChain.deployed) {
            // Wallet deployment will vary depending on the version
            // so we need to use the context to get the correct deployment
            const deployTransaction = (0, _wallet.Wallet).buildDeployTransaction(status.original.context, status.original.imageHash);
            transactions.push(...deployTransaction.transactions);
        }
        transactions.length;
        // Get pending migrations
        transactions.push(...status.signedMigrations.map((m)=>({
                to: m.tx.entrypoint,
                data: (0, _core.commons).transaction.encodeBundleExecData(m.tx),
                value: 0,
                gasLimit: 0,
                revertOnError: true,
                delegateCall: false
            })));
        // Build the transaction intent, if the transaction has migrations
        // then we should use one of the intents of the migrations (anyone will do)
        // if it doesn't, then the only intent we could use if the GuestModule one
        // ... but this may fail if the relayer uses a different GuestModule
        const id = status.signedMigrations.length > 0 ? status.signedMigrations[0].tx.intent.id : (0, _core.commons).transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, chainId, transactions);
        // Everything is encoded as a bundle
        // using the GuestModule of the account version
        const { guestModule } = this.contextFor(status.version);
        return {
            entrypoint: guestModule,
            transactions,
            chainId,
            intent: {
                id,
                wallet: this.address
            }
        };
    }
    async bootstrapTransactions(chainId, prestatus) {
        const status = prestatus || await this.status(chainId);
        return this.buildBootstrapTransactions(status, chainId);
    }
    async doBootstrap(chainId, feeQuote, prestatus) {
        const bootstrapTxs = await this.bootstrapTransactions(chainId, prestatus);
        return this.relayer(chainId).relay(_extends({}, bootstrapTxs, {
            chainId
        }), feeQuote);
    }
    signMessage(message, chainId, cantValidateBehavior = "ignore") {
        return this.signDigest((0, _ethers.ethers).utils.keccak256(message), chainId, true, cantValidateBehavior);
    }
    async signTransactions(txs, chainId, pstatus, options) {
        const status = pstatus || await this.status(chainId);
        this.mustBeFullyMigrated(status);
        const wallet = this.walletForStatus(chainId, status);
        const metadata = {
            address: this.address,
            digest: "",
            // Set in wallet.signTransactions
            chainId,
            config: {
                version: this.version
            },
            decorate: true,
            cantValidateBehavior: "ignore"
        };
        const nonceOptions = (options == null ? void 0 : options.nonceSpace) && {
            space: options == null ? void 0 : options.nonceSpace,
            serial: options == null ? void 0 : options.serial
        };
        const signed = await wallet.signTransactions(txs, nonceOptions, metadata);
        return _extends({}, signed, {
            signature: await this.decorateSignature(signed.signature, status)
        });
    }
    async signMigrations(chainId, editConfig) {
        const status = await this.status(chainId);
        if (status.fullyMigrated) return false;
        const wallet = this.walletForStatus(chainId, status);
        const nextConfig = editConfig(wallet.config);
        const signed = await this.migrator.signNextMigration(this.address, status.version, wallet, nextConfig);
        if (!signed) return false;
        // Make sure the tracker has a copy of the config
        // before attempting to save the migration
        // otherwise if this second step fails the tracker could end up
        // with a migration to an unknown config
        await this.tracker.saveWalletConfig({
            config: nextConfig
        });
        const nextCoder = (0, _core.universal).coderFor(nextConfig.version).config;
        const nextImageHash = nextCoder.imageHashOf(nextConfig);
        const reverseConfig = await this.tracker.configOfImageHash({
            imageHash: nextImageHash,
            noCache: true
        });
        if (!reverseConfig || nextCoder.imageHashOf(reverseConfig) !== nextImageHash) throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`);
        await this.tracker.saveMigration(this.address, signed, this.contexts);
        return true;
    }
    async signAllMigrations(editConfig) {
        var _this2 = this;
        const failedChains = [];
        const signedMigrations = await Promise.all(this.networks.map(async function(n) {
            try {
                // Signing migrations for each chain
                return await _this2.signMigrations(n.chainId, editConfig);
            } catch (error) {
                console.warn(`Failed to sign migrations for chain ${n.chainId}`, error);
                // Adding failed chainId to the failedChains array
                failedChains.push(n.chainId);
                // Using null as a placeholder for failed chains
                return null;
            }
        }));
        // Filter out null values to get only the successful signed migrations
        const successfulSignedMigrations = signedMigrations.filter((migration)=>migration !== null);
        return {
            signedMigrations: successfulSignedMigrations,
            failedChains
        };
    }
    async isMigratedAllChains() {
        var _this3 = this;
        const failedChains = [];
        const statuses = await Promise.all(this.networks.map(async function(n) {
            try {
                return await _this3.status(n.chainId);
            } catch (error) {
                failedChains.push(n.chainId);
                console.warn(`Failed to get status for chain ${n.chainId}`, error);
                // default to true for failed chains
                return {
                    fullyMigrated: true
                };
            }
        }));
        const migratedAllChains = statuses.every((s)=>s.fullyMigrated);
        return {
            migratedAllChains,
            failedChains
        };
    }
    async sendSignedTransactions(signedBundle, chainId, quote, pstatus, callback) {
        if (!Array.isArray(signedBundle)) return this.sendSignedTransactions([
            signedBundle
        ], chainId, quote, pstatus, callback);
        const status = pstatus || await this.status(chainId);
        this.mustBeFullyMigrated(status);
        const decoratedBundle = await this.decorateTransactions(signedBundle, status, chainId);
        callback == null || callback(decoratedBundle);
        return this.relayer(chainId).relay(decoratedBundle, quote);
    }
    async fillGasLimits(txs, chainId, status) {
        const wallet = this.walletForStatus(chainId, status || await this.status(chainId));
        return wallet.fillGasLimits(txs);
    }
    async gasRefundQuotes(txs, chainId, stubSignatureOverrides, status, options) {
        const wstatus = status || await this.status(chainId);
        const wallet = this.walletForStatus(chainId, wstatus);
        const predecorated = await this.predecorateTransactions(txs, wstatus, chainId);
        const transactions = (0, _core.commons).transaction.fromTransactionish(this.address, predecorated);
        // We can't sign the transactions (because we don't want to bother the user)
        // so we use the latest configuration to build a "stub" signature, the relayer
        // knows to ignore the wallet signatures
        const stubSignature = wallet.coders.config.buildStubSignature(wallet.config, stubSignatureOverrides);
        // Now we can decorate the transactions as always, but we need to manually build the signed bundle
        const intentId = (0, _ethers.ethers).utils.hexlify((0, _ethers.ethers).utils.randomBytes(32));
        const signedBundle = {
            chainId,
            intent: {
                id: intentId,
                wallet: this.address
            },
            signature: stubSignature,
            transactions,
            entrypoint: this.address,
            nonce: 0 // The relayer also ignored the nonce
        };
        const decoratedBundle = await this.decorateTransactions(signedBundle, wstatus);
        const data = (0, _core.commons).transaction.encodeBundleExecData(decoratedBundle);
        const res = await this.relayer(chainId).getFeeOptionsRaw(decoratedBundle.entrypoint, data, options);
        return _extends({}, res, {
            decorated: decoratedBundle
        });
    }
    async prepareTransactions(args) {
        const status = await this.status(args.chainId);
        const transactions = await this.fillGasLimits(args.txs, args.chainId, status);
        const gasRefundQuote = await this.gasRefundQuotes(transactions, args.chainId, args.stubSignatureOverrides, status, {
            simulate: args.simulateForFeeOptions
        });
        const flatDecorated = (0, _core.commons).transaction.unwind(this.address, gasRefundQuote.decorated.transactions);
        return {
            transactions,
            flatDecorated,
            feeOptions: gasRefundQuote.options,
            feeQuote: gasRefundQuote.quote
        };
    }
    async sendTransaction(txs, chainId, quote, skipPreDecorate = false, callback, options) {
        const status = await this.status(chainId);
        const predecorated = skipPreDecorate ? txs : await this.predecorateTransactions(txs, status, chainId);
        const hasTxs = (0, _core.commons).transaction.fromTransactionish(this.address, predecorated).length > 0;
        const signed = hasTxs ? await this.signTransactions(predecorated, chainId, undefined, options) : undefined;
        const childBundles = await this.orchestrator.predecorateSignedTransactions({
            chainId
        });
        const bundles = [];
        if (signed !== undefined && signed.transactions.length > 0) bundles.push(signed);
        bundles.push(...childBundles.filter((b)=>b.transactions.length > 0));
        return this.sendSignedTransactions(bundles, chainId, quote, undefined, callback);
    }
    async signTypedData(domain, types, message, chainId, cantValidateBehavior = "ignore") {
        const digest = (0, _utils.encodeTypedDataDigest)({
            domain,
            types,
            message
        });
        return this.signDigest(digest, chainId, true, cantValidateBehavior);
    }
    async getSigners() {
        var _this4 = this;
        const last = (ts)=>ts.length ? ts[ts.length - 1] : undefined;
        return (await Promise.all(this.networks.map(async function({ chainId, name }) {
            try {
                var _last;
                const status = await _this4.status(chainId);
                let latestImageHash = (_last = last(status.presignedConfigurations)) == null ? void 0 : _last.nextImageHash;
                if (!latestImageHash) {
                    if (status.onChain.version !== status.version) {
                        const migration = last(status.signedMigrations);
                        if (migration) {
                            const { toVersion, toConfig } = migration;
                            const _coder = (0, _core.universal).genericCoderFor(toVersion);
                            latestImageHash = _coder.config.imageHashOf(toConfig);
                        }
                    }
                }
                if (!latestImageHash) latestImageHash = status.onChain.imageHash;
                const latestConfig = await _this4.tracker.configOfImageHash({
                    imageHash: latestImageHash
                });
                if (!latestConfig) throw new Error(`unable to find config for image hash ${latestImageHash}`);
                const coder = (0, _core.universal).genericCoderFor(latestConfig.version);
                const signers = coder.config.signersOf(latestConfig);
                return signers.map((signer)=>_extends({}, signer, {
                        network: chainId
                    }));
            } catch (error) {
                console.warn(`unable to get signers on network ${chainId} ${name}`, error);
                return [];
            }
        }))).flat();
    }
    async getAllSigners() {
        var _this5 = this;
        const allSigners = [];
        // We need to get the signers for each status
        await Promise.all(this.networks.map(async function(network) {
            const chainId = network.chainId;
            // Getting the status with `longestPath` set to true will give us all the possible configurations
            // between the current onChain config and the latest config, including the ones "flagged for removal"
            const status = await _this5.status(chainId, true);
            const fullChain = [
                status.onChain.imageHash,
                ...status.onChain.version !== status.version ? status.signedMigrations.map((m)=>(0, _core.universal).coderFor(m.toVersion).config.imageHashOf(m.toConfig)) : [],
                ...status.presignedConfigurations.map((update)=>update.nextImageHash)
            ];
            return Promise.all(fullChain.map(async function(nextImageHash, iconf) {
                const isLast = iconf === fullChain.length - 1;
                const config = await _this5.tracker.configOfImageHash({
                    imageHash: nextImageHash
                });
                if (!config) {
                    console.warn(`AllSigners may be incomplete, config not found for imageHash ${nextImageHash}`);
                    return;
                }
                const coder = (0, _core.universal).genericCoderFor(config.version);
                const signers = coder.config.signersOf(config);
                signers.forEach((signer)=>{
                    const exists = allSigners.find((s)=>s.address === signer.address && s.network === chainId);
                    if (exists && isLast && exists.flaggedForRemoval) {
                        exists.flaggedForRemoval = false;
                        return;
                    }
                    if (exists) return;
                    allSigners.push({
                        address: signer.address,
                        weight: signer.weight,
                        network: chainId,
                        flaggedForRemoval: !isLast
                    });
                });
            }));
        }));
        return allSigners;
    }
}
function isAccount(value) {
    return value instanceof Account;
}

},{"@0xsequence/abi":"hbXMf","@0xsequence/core":"cIuGJ","@0xsequence/migration":"l6xLq","@0xsequence/relayer":"kiNl3","@0xsequence/utils":"7jY5X","@0xsequence/wallet":"qr7qv","ethers":"hdHML","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIuGJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "allVersions", ()=>allVersions);
parcelHelpers.export(exports, "commons", ()=>index$1);
parcelHelpers.export(exports, "universal", ()=>index);
parcelHelpers.export(exports, "v1", ()=>v1);
parcelHelpers.export(exports, "v2", ()=>v2);
var _ethers = require("ethers");
var _abi = require("@0xsequence/abi");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var config$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
function subdigestOf(payload) {
    return (0, _ethers.ethers).utils.solidityKeccak256([
        "bytes",
        "uint256",
        "address",
        "bytes32"
    ], [
        "0x1901",
        payload.chainId,
        payload.address,
        payload.digest
    ]);
}
function isSignedPayload(payload) {
    return payload.digest !== undefined && payload.chainId !== undefined && payload.address !== undefined;
}
var signature$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    subdigestOf: subdigestOf,
    isSignedPayload: isSignedPayload
});
const EIP1271_MAGIC_VALUE = "0x1626ba7e";
const EIP1271_ABI = [
    {
        inputs: [
            {
                internalType: "bytes32",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                type: "bytes"
            }
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                type: "bytes4"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];
async function isValidEIP1271Signature(address, digest, signature, provider) {
    const contract = new (0, _ethers.ethers).Contract(address, EIP1271_ABI, provider);
    const result = await contract.isValidSignature(digest, signature);
    return result === EIP1271_MAGIC_VALUE;
}
var validateEIP1271 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    isValidEIP1271Signature: isValidEIP1271Signature
});
let SigType = /*#__PURE__*/ function(SigType) {
    SigType[SigType["EIP712"] = 1] = "EIP712";
    SigType[SigType["ETH_SIGN"] = 2] = "ETH_SIGN";
    SigType[SigType["WALLET_BYTES32"] = 3] = "WALLET_BYTES32";
    return SigType;
}({});
function canRecover(signature) {
    const bytes = (0, _ethers.ethers).utils.arrayify(signature);
    const type = bytes[bytes.length - 1];
    return type === SigType.EIP712 || type === SigType.ETH_SIGN;
}
function recoverSigner(digest, signature) {
    const bytes = (0, _ethers.ethers).utils.arrayify(signature);
    const digestBytes = (0, _ethers.ethers).utils.arrayify(digest);
    // type is last byte
    const type = bytes[bytes.length - 1];
    // Split r:s:v
    const r = (0, _ethers.ethers).utils.hexlify(bytes.slice(0, 32));
    const s = (0, _ethers.ethers).utils.hexlify(bytes.slice(32, 64));
    const v = (0, _ethers.ethers).BigNumber.from(bytes.slice(64, 65)).toNumber();
    const splitSignature = {
        r,
        s,
        v
    };
    if (type === SigType.EIP712) return (0, _ethers.ethers).utils.recoverAddress(digestBytes, splitSignature);
    if (type === SigType.ETH_SIGN) return (0, _ethers.ethers).utils.recoverAddress((0, _ethers.ethers).utils.hashMessage(digestBytes), splitSignature);
    throw new Error(`Unsupported signature type: ${type}`);
}
function isValidSignature(address, digest, signature, provider) {
    const bytes = (0, _ethers.ethers).utils.arrayify(signature);
    // type is last byte
    const type = bytes[bytes.length - 1];
    if (type === SigType.EIP712 || type === SigType.ETH_SIGN) return address === recoverSigner(digest, signature);
    if (type === SigType.WALLET_BYTES32) return isValidEIP1271Signature(address, (0, _ethers.ethers).utils.hexlify(digest), bytes.slice(0, -1), provider);
    throw new Error(`Unsupported signature type: ${type}`);
}
function tryRecoverSigner(digest, signature) {
    const bytes = (0, _ethers.ethers).utils.arrayify(signature);
    if (bytes.length !== 66) return undefined;
    try {
        return recoverSigner(digest, bytes);
    } catch (_unused) {}
    return undefined;
}
var signer = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    SigType: SigType,
    canRecover: canRecover,
    recoverSigner: recoverSigner,
    isValidSignature: isValidSignature,
    tryRecoverSigner: tryRecoverSigner
});
let SignaturePartType$1 = /*#__PURE__*/ function(SignaturePartType) {
    SignaturePartType[SignaturePartType["EOASignature"] = 0] = "EOASignature";
    SignaturePartType[SignaturePartType["Address"] = 1] = "Address";
    SignaturePartType[SignaturePartType["DynamicSignature"] = 2] = "DynamicSignature";
    return SignaturePartType;
}({});
function isAddressMember(member) {
    return member.address !== undefined && !isUnrecoveredSignatureMember(member);
}
function isUnrecoveredSignatureMember(member) {
    return member.signature !== undefined && member.weight !== undefined && member.isDynamic !== undefined;
}
function isUnrecoveredSignature$1(signature) {
    return signature.threshold !== undefined && signature.signers !== undefined;
}
function decodeSignature$1(signature) {
    const bytes = (0, _ethers.ethers).utils.arrayify(signature);
    const threshold = bytes[0] << 8 | bytes[1];
    const signers = [];
    for(let i = 2; i < bytes.length;){
        const type = bytes[i++];
        const weight = bytes[i++];
        switch(type){
            case SignaturePartType$1.EOASignature:
                signers.push({
                    unrecovered: true,
                    weight,
                    signature: (0, _ethers.ethers).utils.hexlify(bytes.slice(i, i + 66)),
                    isDynamic: false
                });
                i += 66;
                break;
            case SignaturePartType$1.Address:
                signers.push({
                    weight,
                    address: (0, _ethers.ethers).utils.getAddress((0, _ethers.ethers).utils.hexlify(bytes.slice(i, i + 20)))
                });
                i += 20;
                break;
            case SignaturePartType$1.DynamicSignature:
                const address = (0, _ethers.ethers).utils.getAddress((0, _ethers.ethers).utils.hexlify(bytes.slice(i, i + 20)));
                i += 20;
                const size = bytes[i] << 8 | bytes[i + 1];
                i += 2;
                signers.push({
                    unrecovered: true,
                    weight,
                    signature: (0, _ethers.ethers).utils.hexlify(bytes.slice(i, i + size)),
                    address,
                    isDynamic: true
                });
                i += size;
                break;
            default:
                throw new Error(`Unknown signature part type: ${type}`);
        }
    }
    return {
        version: 1,
        threshold,
        signers
    };
}
function encodeSignature$1(signature) {
    if ((0, _ethers.ethers).utils.isBytesLike(signature)) return (0, _ethers.ethers).utils.hexlify(signature);
    const { signers, threshold } = isUnrecoveredSignature$1(signature) ? signature : signature.config;
    const encodedSigners = signers.map((s)=>{
        if (isAddressMember(s)) return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "address"
        ], [
            SignaturePartType$1.Address,
            s.weight,
            s.address
        ]);
        if (s.isDynamic) {
            const bytes = (0, _ethers.ethers).utils.arrayify(s.signature);
            return (0, _ethers.ethers).utils.solidityPack([
                "uint8",
                "uint8",
                "address",
                "uint16",
                "bytes"
            ], [
                SignaturePartType$1.DynamicSignature,
                s.weight,
                s.address,
                bytes.length,
                bytes
            ]);
        }
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "bytes"
        ], [
            SignaturePartType$1.EOASignature,
            s.weight,
            s.signature
        ]);
    });
    return (0, _ethers.ethers).utils.solidityPack([
        "uint16",
        ...new Array(encodedSigners.length).fill("bytes")
    ], [
        threshold,
        ...encodedSigners
    ]);
}
async function recoverSignature$1(data, payload, provider) {
    const subdigest = subdigestOf(payload);
    const signers = await Promise.all(data.signers.map(async (s)=>{
        if (isAddressMember(s)) return s;
        if (s.isDynamic) {
            if (!s.address) throw new Error("Dynamic signature part must have address");
            if (!isValidSignature(s.address, subdigest, s.signature, provider)) throw new Error(`Invalid dynamic signature part ${s.address}`);
            return {
                address: s.address,
                weight: s.weight,
                signature: s.signature
            };
        } else {
            const address = recoverSigner(subdigest, s.signature);
            return {
                address,
                weight: s.weight,
                signature: s.signature
            };
        }
    }));
    return {
        version: 1,
        payload,
        subdigest,
        config: {
            version: 1,
            threshold: data.threshold,
            signers
        }
    };
}
function encodeSigners$1(config, signatures, subdigests, _) {
    if (subdigests.length !== 0) throw new Error("Explicit subdigests not supported on v1");
    let weight = (0, _ethers.ethers).BigNumber.from(0);
    const parts = config.signers.map((s)=>{
        if (!signatures.has(s.address)) return s;
        const signature = signatures.get(s.address);
        const bytes = (0, _ethers.ethers).utils.arrayify(signature.signature);
        weight = weight.add(s.weight);
        if (signature.isDynamic || bytes.length !== 66) return _extends({}, s, {
            isDynamic: true,
            signature: signature.signature,
            address: s.address
        });
        return _extends({}, s, {
            isDynamic: false,
            signature: signature.signature
        });
    });
    const encoded = encodeSignature$1({
        version: 1,
        threshold: config.threshold,
        signers: parts
    });
    return {
        encoded,
        weight
    };
}
const SignatureCoder$1 = {
    decode: (data)=>{
        return decodeSignature$1(data);
    },
    encode: (data)=>{
        return encodeSignature$1(data);
    },
    trim: async (data)=>{
        return data;
    },
    supportsNoChainId: true,
    recover: (data, payload, provider)=>{
        return recoverSignature$1(data, payload, provider);
    },
    encodeSigners: (config, signatures, subdigests, chainId)=>{
        return encodeSigners$1(config, signatures, subdigests);
    },
    hasEnoughSigningPower: (config, signatures)=>{
        const { weight } = SignatureCoder$1.encodeSigners(config, signatures, [], 0);
        return weight.gte(config.threshold);
    },
    chainSignatures: (_main, _suffix)=>{
        throw new Error("Signature chaining not supported on v1");
    },
    hashSetImageHash: function(_imageHash) {
        throw new Error("Image hash not supported on v1");
    },
    signaturesOf (config) {
        return config.signers.filter((s)=>s.signature !== undefined).map((s)=>({
                address: s.address,
                signature: s.signature
            }));
    },
    signaturesOfDecoded: function(data) {
        return data.signers.map((s)=>s.signature).filter((s)=>s !== undefined);
    }
};
var signature$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    SignaturePartType: SignaturePartType$1,
    isAddressMember: isAddressMember,
    isUnrecoveredSignatureMember: isUnrecoveredSignatureMember,
    isUnrecoveredSignature: isUnrecoveredSignature$1,
    decodeSignature: decodeSignature$1,
    encodeSignature: encodeSignature$1,
    recoverSignature: recoverSignature$1,
    encodeSigners: encodeSigners$1,
    SignatureCoder: SignatureCoder$1
});
const ConfigCoder$1 = {
    isWalletConfig: (config)=>{
        return config.version === 1 && config.threshold !== undefined && config.signers !== undefined;
    },
    imageHashOf: (config)=>{
        return config.signers.reduce((imageHash, signer)=>(0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.defaultAbiCoder.encode([
                "bytes32",
                "uint8",
                "address"
            ], [
                imageHash,
                signer.weight,
                signer.address
            ])), (0, _ethers.ethers).utils.solidityPack([
            "uint256"
        ], [
            config.threshold
        ]));
    },
    hasSubdigest: (_walletConfig, _subdigest)=>{
        // v1 does not support explicit subdigests
        return false;
    },
    isComplete: (_config)=>{
        // v1 does not support incomplete configs
        return true;
    },
    checkpointOf: (_config)=>{
        return (0, _ethers.ethers).BigNumber.from(0);
    },
    signersOf: (config)=>{
        return config.signers.map((s)=>({
                address: s.address,
                weight: (0, _ethers.ethers).BigNumber.from(s.weight).toNumber()
            }));
    },
    fromSimple: (config)=>{
        if (!(0, _ethers.ethers).constants.Zero.eq(config.checkpoint)) throw new Error("v1 wallet config does not support checkpoint");
        if (config.subdigests && config.subdigests.length > 0) throw new Error("v1 wallet config does not support subdigests");
        return {
            version: 1,
            threshold: config.threshold,
            signers: config.signers
        };
    },
    update: {
        isKindUsed: true,
        buildTransaction: (wallet, config, context, kind)=>{
            const module = new (0, _ethers.ethers).utils.Interface([
                ...(0, _abi.walletContracts).mainModule.abi,
                ...(0, _abi.walletContracts).mainModuleUpgradable.abi
            ]);
            const transactions = [];
            if (!kind || kind === "first") transactions.push({
                to: wallet,
                data: module.encodeFunctionData(module.getFunction("updateImplementation"), [
                    context.mainModuleUpgradable
                ]),
                gasLimit: 0,
                delegateCall: false,
                revertOnError: true,
                value: 0
            });
            transactions.push({
                to: wallet,
                data: module.encodeFunctionData(module.getFunction("updateImageHash"), [
                    ConfigCoder$1.imageHashOf(config)
                ]),
                gasLimit: 0,
                delegateCall: false,
                revertOnError: true,
                value: 0
            });
            return {
                entrypoint: wallet,
                transactions
            };
        },
        decodeTransaction: function(tx) {
            throw new Error("Function not implemented.");
        }
    },
    toJSON: function(config) {
        const plainMembers = config.signers.map((signer)=>{
            return {
                weight: (0, _ethers.ethers).BigNumber.from(signer.weight).toString(),
                address: signer.address
            };
        });
        return JSON.stringify({
            version: config.version,
            threshold: (0, _ethers.ethers).BigNumber.from(config.threshold).toString(),
            signers: plainMembers
        });
    },
    fromJSON: function(json) {
        const parsed = JSON.parse(json);
        const signers = parsed.signers.map((signer)=>{
            return {
                weight: (0, _ethers.ethers).BigNumber.from(signer.weight),
                address: signer.address
            };
        });
        return {
            version: parsed.version,
            threshold: (0, _ethers.ethers).BigNumber.from(parsed.threshold),
            signers
        };
    },
    editConfig: function(config, action) {
        var _action$threshold;
        const newSigners = config.signers.slice();
        if (action.checkpoint && !(0, _ethers.ethers).constants.Zero.eq(action.checkpoint)) throw new Error("v1 wallet config does not support checkpoint");
        if (action.add) for (const signer of action.add){
            if (newSigners.find((s)=>s.address === signer.address)) continue;
            newSigners.push({
                weight: signer.weight,
                address: signer.address
            });
        }
        if (action.remove) for (const address of action.remove){
            const index = newSigners.findIndex((signer)=>signer.address === address);
            if (index >= 0) newSigners.splice(index, 1);
        }
        return {
            version: config.version,
            threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,
            signers: newSigners
        };
    },
    buildStubSignature: function(config, overrides) {
        const parts = new Map();
        for (const [signer, signature] of overrides.entries()){
            parts.set(signer, {
                signature,
                isDynamic: true
            });
            const { encoded, weight } = encodeSigners$1(config, parts, []);
            if (weight.gte(config.threshold)) return encoded;
        }
        const signers = config.signers;
        for (const { address } of signers.sort(({ weight: a }, { weight: b })=>(0, _ethers.ethers).BigNumber.from(a).sub(b).toNumber())){
            const signature = "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02";
            parts.set(address, {
                signature,
                isDynamic: false
            });
            const { encoded, weight } = encodeSigners$1(config, parts, []);
            if (weight.gte(config.threshold)) return encoded;
        }
        return encodeSigners$1(config, parts, []).encoded;
    }
};
var config$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ConfigCoder: ConfigCoder$1
});
const version$1 = 1;
const DeployedWalletContext$1 = {
    version: version$1,
    factory: "0xf9D09D634Fb818b05149329C1dcCFAeA53639d96",
    guestModule: "0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7",
    mainModule: "0xd01F11855bCcb95f88D7A48492F66410d4637313",
    mainModuleUpgradable: "0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118",
    walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var v1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    config: config$1,
    signature: signature$1,
    version: version$1,
    DeployedWalletContext: DeployedWalletContext$1
});
//                              = keccak256("SetImageHash(bytes32 imageHash)")
const SetImageHashPrefix = "0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1";
function hashSetImageHash(imageHash) {
    return (0, _ethers.ethers).utils.keccak256(messageSetImageHash(imageHash));
}
function messageSetImageHash(imageHash) {
    return (0, _ethers.ethers).utils.solidityPack([
        "bytes32",
        "bytes32"
    ], [
        SetImageHashPrefix,
        imageHash
    ]);
}
function decodeMessageSetImageHash(message) {
    const arr = (0, _ethers.ethers).utils.arrayify(message);
    if (arr.length !== 64) return undefined;
    if ((0, _ethers.ethers).utils.hexlify(arr.slice(0, 32)) !== SetImageHashPrefix) return undefined;
    return (0, _ethers.ethers).utils.hexlify(arr.slice(32, 64));
}
function isMessageSetImageHash(message) {
    return decodeMessageSetImageHash(message) !== undefined;
}
var chained = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    SetImageHashPrefix: SetImageHashPrefix,
    hashSetImageHash: hashSetImageHash,
    messageSetImageHash: messageSetImageHash,
    decodeMessageSetImageHash: decodeMessageSetImageHash,
    isMessageSetImageHash: isMessageSetImageHash
});
let SignatureType = /*#__PURE__*/ function(SignatureType) {
    SignatureType[SignatureType["Legacy"] = 0] = "Legacy";
    SignatureType[SignatureType["Dynamic"] = 1] = "Dynamic";
    SignatureType[SignatureType["NoChainIdDynamic"] = 2] = "NoChainIdDynamic";
    SignatureType[SignatureType["Chained"] = 3] = "Chained";
    return SignatureType;
}({});
let SignaturePartType = /*#__PURE__*/ function(SignaturePartType) {
    SignaturePartType[SignaturePartType["Signature"] = 0] = "Signature";
    SignaturePartType[SignaturePartType["Address"] = 1] = "Address";
    SignaturePartType[SignaturePartType["DynamicSignature"] = 2] = "DynamicSignature";
    SignaturePartType[SignaturePartType["Node"] = 3] = "Node";
    SignaturePartType[SignaturePartType["Branch"] = 4] = "Branch";
    SignaturePartType[SignaturePartType["Subdigest"] = 5] = "Subdigest";
    SignaturePartType[SignaturePartType["Nested"] = 6] = "Nested";
    return SignaturePartType;
}({});
const SignaturePartTypeLength = 66;
function isUnrecoveredNode(node) {
    return node.left !== undefined && node.right !== undefined;
}
function isUnrecoveredNestedLeaf(leaf) {
    return leaf.tree !== undefined;
}
function isUnrecoveredSignatureLeaf(leaf) {
    return leaf.unrecovered && leaf.signature !== undefined && leaf.isDynamic !== undefined;
}
function decodeSignatureTree(body) {
    let arr = (0, _ethers.ethers).utils.arrayify(body);
    let pointer;
    const append = (prevPointer, node)=>{
        if (!prevPointer) return {
            left: node
        };
        if (!prevPointer.right) return {
            left: prevPointer.left,
            right: node
        };
        return {
            left: prevPointer,
            right: node
        };
    };
    while(arr.length > 0){
        const type = arr[0];
        arr = arr.slice(1);
        switch(type){
            case SignaturePartType.Signature:
                {
                    const weight = arr[0];
                    const signature = (0, _ethers.ethers).utils.hexlify(arr.slice(1, SignaturePartTypeLength + 1));
                    pointer = append(pointer, {
                        signature,
                        weight,
                        unrecovered: true,
                        isDynamic: false
                    });
                    arr = arr.slice(SignaturePartTypeLength + 1);
                }
                break;
            case SignaturePartType.Address:
                {
                    const weight = arr[0];
                    const address = (0, _ethers.ethers).utils.getAddress((0, _ethers.ethers).utils.hexlify(arr.slice(1, 21)));
                    pointer = append(pointer, {
                        address,
                        weight
                    });
                    arr = arr.slice(21);
                }
                break;
            case SignaturePartType.DynamicSignature:
                {
                    const weight = arr[0];
                    const address = (0, _ethers.ethers).utils.getAddress((0, _ethers.ethers).utils.hexlify(arr.slice(1, 21)));
                    const size = arr[21] << 16 | arr[22] << 8 | arr[23];
                    const signature = (0, _ethers.ethers).utils.hexlify(arr.slice(24, 24 + size));
                    pointer = append(pointer, {
                        address,
                        signature,
                        weight,
                        unrecovered: true,
                        isDynamic: true
                    });
                    arr = arr.slice(24 + size);
                }
                break;
            case SignaturePartType.Node:
                {
                    const nodeHash = (0, _ethers.ethers).utils.hexlify(arr.slice(0, 32));
                    pointer = append(pointer, {
                        nodeHash
                    });
                    arr = arr.slice(32);
                }
                break;
            case SignaturePartType.Branch:
                {
                    const size = arr[0] << 16 | arr[1] << 8 | arr[2];
                    const branch = decodeSignatureTree(arr.slice(3, 3 + size));
                    pointer = append(pointer, branch);
                    arr = arr.slice(3 + size);
                }
                break;
            case SignaturePartType.Subdigest:
                {
                    const subdigest = (0, _ethers.ethers).utils.hexlify(arr.slice(0, 32));
                    pointer = append(pointer, {
                        subdigest
                    });
                    arr = arr.slice(32);
                }
                break;
            case SignaturePartType.Nested:
                {
                    const weight = arr[0];
                    const threshold = arr[1] << 8 | arr[2];
                    const size = arr[3] << 16 | arr[4] << 8 | arr[5];
                    const tree = decodeSignatureTree(arr.slice(6, 6 + size));
                    pointer = append(pointer, {
                        weight,
                        threshold,
                        tree
                    });
                    arr = arr.slice(6 + size);
                }
                break;
            default:
                throw new Error(`Unknown signature part type: ${type}: ${(0, _ethers.ethers).utils.hexlify(arr)}`);
        }
    }
    if (!pointer) throw new Error("Empty signature tree");
    if (pointer.right) return pointer;
    return pointer.left;
}
class InvalidSignatureLeafError extends Error {
    constructor(leaf){
        super(`Invalid signature leaf: ${JSON.stringify(leaf)}`);
        this.leaf = leaf;
    }
}
async function recoverTopology(unrecovered, subdigest, provider) {
    if (isUnrecoveredNode(unrecovered)) {
        const [left, right] = await Promise.all([
            recoverTopology(unrecovered.left, subdigest, provider),
            recoverTopology(unrecovered.right, subdigest, provider)
        ]);
        return {
            left,
            right
        };
    }
    if (isUnrecoveredNestedLeaf(unrecovered)) return {
        weight: unrecovered.weight,
        threshold: unrecovered.threshold,
        tree: await recoverTopology(unrecovered.tree, subdigest, provider)
    };
    if (isUnrecoveredSignatureLeaf(unrecovered)) {
        if (unrecovered.isDynamic) {
            if (!unrecovered.address) throw new Error("Dynamic signature leaf without address");
            const isValid = await isValidSignature(unrecovered.address, subdigest, unrecovered.signature, provider);
            if (!isValid) throw new InvalidSignatureLeafError(unrecovered);
            return {
                weight: unrecovered.weight,
                address: unrecovered.address,
                signature: unrecovered.signature,
                subdigest
            };
        } else return {
            weight: unrecovered.weight,
            address: recoverSigner(subdigest, unrecovered.signature),
            signature: unrecovered.signature,
            subdigest
        };
    }
    return unrecovered;
}
// TODO: It should be possible to re-use encodeSignatureTree
// and avoid duplicating this logic
const partEncoder = {
    concat: (a, b)=>{
        return (0, _ethers.ethers).utils.solidityPack([
            "bytes",
            "bytes"
        ], [
            a,
            b
        ]);
    },
    node: (nodeHash)=>{
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "bytes32"
        ], [
            SignaturePartType.Node,
            nodeHash
        ]);
    },
    branch: (tree)=>{
        const arr = (0, _ethers.ethers).utils.arrayify(tree);
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint24",
            "bytes"
        ], [
            SignaturePartType.Branch,
            arr.length,
            arr
        ]);
    },
    nested: (weight, threshold, tree)=>{
        const arr = (0, _ethers.ethers).utils.arrayify(tree);
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "uint16",
            "uint24",
            "bytes"
        ], [
            SignaturePartType.Nested,
            weight,
            threshold,
            arr.length,
            arr
        ]);
    },
    subdigest: (subdigest)=>{
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "bytes32"
        ], [
            SignaturePartType.Subdigest,
            subdigest
        ]);
    },
    signature: (weight, signature)=>{
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "bytes"
        ], [
            SignaturePartType.Signature,
            weight,
            signature
        ]);
    },
    dynamicSignature: (weight, address, signature)=>{
        const arrSignature = (0, _ethers.ethers).utils.arrayify(signature);
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "address",
            "uint24",
            "bytes"
        ], [
            SignaturePartType.DynamicSignature,
            weight,
            address,
            arrSignature.length,
            arrSignature
        ]);
    },
    address: (weight, address)=>{
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "address"
        ], [
            SignaturePartType.Address,
            weight,
            address
        ]);
    }
};
function encodeSigners(config, parts, subdigests, chainId, options = {}) {
    const tree = encodeTree(config.tree, parts, subdigests, options);
    if ((0, _ethers.ethers).BigNumber.from(chainId).isZero()) return {
        encoded: (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint16",
            "uint32",
            "bytes"
        ], [
            SignatureType.NoChainIdDynamic,
            config.threshold,
            config.checkpoint,
            tree.encoded
        ]),
        weight: tree.weight
    };
    if ((0, _ethers.ethers).BigNumber.from(config.threshold).gt(255)) return {
        encoded: (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint16",
            "uint32",
            "bytes"
        ], [
            SignatureType.Dynamic,
            config.threshold,
            config.checkpoint,
            tree.encoded
        ]),
        weight: tree.weight
    };
    return {
        encoded: (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "uint32",
            "bytes"
        ], [
            SignatureType.Legacy,
            config.threshold,
            config.checkpoint,
            tree.encoded
        ]),
        weight: tree.weight
    };
}
function encodeTree(topology, parts, subdigests, options = {}) {
    const trim = !options.disableTrim;
    if (isNode(topology)) {
        const left = encodeTree(topology.left, parts, subdigests);
        const right = encodeTree(topology.right, parts, subdigests);
        const isLeftSigner = isSignerLeaf(topology.left);
        const isRightSigner = isSignerLeaf(topology.right);
        if (trim && left.weight.eq(0) && right.weight.eq(0) && !isLeftSigner && !isRightSigner) return {
            // We don't need to include anything for this node
            // just the hash will be enough
            encoded: partEncoder.node(hashNode(topology)),
            weight: (0, _ethers.ethers).constants.Zero
        };
        if (trim && right.weight.eq(0) && !isRightSigner) return {
            // The right node doesn't have any weight
            // but we still need to include the left node encoded
            encoded: partEncoder.concat(left.encoded, partEncoder.node(hashNode(topology.right))),
            weight: left.weight
        };
        if (trim && left.weight.eq(0) && !isLeftSigner) return {
            // The left node doesn't have any weight
            // we can just append its hash, but for the right node
            // we need to create a new "branch"
            encoded: partEncoder.concat(partEncoder.node(hashNode(topology.left)), partEncoder.branch(right.encoded)),
            weight: right.weight
        };
        return {
            // Both nodes have weight, we need to include both
            // the right one must be a branch
            encoded: partEncoder.concat(left.encoded, partEncoder.branch(right.encoded)),
            weight: left.weight.add(right.weight)
        };
    }
    if (isNestedLeaf(topology)) {
        const tree = encodeTree(topology.tree, parts, subdigests);
        if (trim && tree.weight.eq(0)) return {
            encoded: partEncoder.node(hashNode(topology)),
            weight: (0, _ethers.ethers).constants.Zero
        };
        return {
            encoded: partEncoder.nested(topology.weight, topology.threshold, tree.encoded),
            weight: tree.weight
        };
    }
    if (isNodeLeaf(topology)) return {
        encoded: partEncoder.node(hashNode(topology)),
        weight: (0, _ethers.ethers).constants.Zero
    };
    if (isSubdigestLeaf(topology)) {
        const include = subdigests.includes(topology.subdigest);
        return {
            encoded: partEncoder.subdigest(topology.subdigest),
            weight: include ? (0, _ethers.ethers).constants.MaxUint256 : (0, _ethers.ethers).constants.Zero
        };
    }
    if (isSignerLeaf(topology)) {
        const include = parts.has(topology.address);
        if (include) {
            const part = parts.get(topology.address);
            const signature = part.signature;
            if (options.forceDynamicEncoding || part.isDynamic) return {
                encoded: partEncoder.dynamicSignature(topology.weight, topology.address, signature),
                weight: (0, _ethers.ethers).BigNumber.from(topology.weight)
            };
            else return {
                encoded: partEncoder.signature(topology.weight, signature),
                weight: (0, _ethers.ethers).BigNumber.from(topology.weight)
            };
        } else return {
            encoded: partEncoder.address(topology.weight, topology.address),
            weight: (0, _ethers.ethers).constants.Zero
        };
    }
    throw new Error(`Invalid topology - unknown error: ${JSON.stringify(topology)}`);
}
function deepestConfigOfSignature(signature) {
    return isChainedSignature(signature) ? deepestConfigOfSignature(signature.suffix[signature.suffix.length - 1]) : signature.config;
}
function isUnrecoveredSignature(sig) {
    return sig.type !== undefined && sig.decoded !== undefined && sig.version !== undefined && sig.version === 2;
}
function isUnrecoveredChainedSignature(sig) {
    return sig.suffix !== undefined && Array.isArray(sig.suffix) && sig.suffix.every(isUnrecoveredSignature);
}
function isSignature(sig) {
    return sig.type !== undefined && sig.config !== undefined && sig.digest !== undefined && sig.version !== undefined && sig.version === 2;
}
function isChainedSignature(sig) {
    return sig.chain !== undefined && Array.isArray(sig.chain) && sig.chain.every(isSignature);
}
function decodeSignature(signature) {
    const bytes = (0, _ethers.ethers).utils.arrayify(signature);
    const type = bytes[0];
    switch(type){
        case SignatureType.Legacy:
            return {
                version: 2,
                type: SignatureType.Legacy,
                decoded: decodeSignatureBody(bytes)
            };
        case SignatureType.Dynamic:
            return {
                version: 2,
                type: SignatureType.Dynamic,
                decoded: decodeSignatureBody(bytes.slice(1))
            };
        case SignatureType.NoChainIdDynamic:
            return {
                version: 2,
                type: SignatureType.NoChainIdDynamic,
                decoded: decodeSignatureBody(bytes.slice(1))
            };
        case SignatureType.Chained:
            return decodeChainedSignature(bytes);
        default:
            throw new Error(`Invalid signature type: ${type}`);
    }
}
function decodeSignatureBody(signature) {
    const bytes = (0, _ethers.ethers).utils.arrayify(signature);
    const threshold = bytes[0] << 8 | bytes[1];
    const checkpoint = bytes[2] << 24 | bytes[3] << 16 | bytes[4] << 8 | bytes[5];
    const tree = decodeSignatureTree(bytes.slice(6));
    return {
        threshold,
        checkpoint,
        tree
    };
}
function decodeChainedSignature(signature) {
    const arr = (0, _ethers.ethers).utils.arrayify(signature);
    const type = arr[0];
    if (type !== SignatureType.Chained) throw new Error(`Expected chained signature type: ${type}`);
    const chain = [];
    let index = 1;
    while(index < arr.length){
        const size = arr[index] << 16 | arr[index + 1] << 8 | arr[index + 2];
        index += 3;
        const sig = decodeSignature(arr.slice(index, index + size));
        chain.push(sig);
        index += size;
    }
    const main = chain[0];
    if (isUnrecoveredChainedSignature(main)) throw new Error(`Expected first link of chained signature to be a simple signature (not chained)`);
    const suffix = chain.slice(1);
    return _extends({}, main, {
        suffix
    });
}
function setImageHashStruct(imageHash) {
    return (0, _ethers.ethers).utils.solidityPack([
        "bytes32",
        "bytes32"
    ], [
        (0, _ethers.ethers).utils.solidityKeccak256([
            "string"
        ], [
            "SetImageHash(bytes32 imageHash)"
        ]),
        imageHash
    ]);
}
async function recoverSignature(signature, payload, provider) {
    const signedPayload = payload.subdigest === undefined ? payload : undefined;
    const isNoChainId = signature.type === SignatureType.NoChainIdDynamic;
    if (isNoChainId && signedPayload) signedPayload.chainId = 0;
    const subdigest = signedPayload ? subdigestOf(signedPayload) : payload.subdigest;
    if (!isUnrecoveredChainedSignature(signature)) {
        const tree = await recoverTopology(signature.decoded.tree, subdigest, provider);
        return {
            version: 2,
            type: signature.type,
            subdigest,
            config: _extends({
                version: 2
            }, signature.decoded, {
                tree
            })
        };
    }
    if (!isSignedPayload(signedPayload)) throw new Error(`Chained signature recovery requires detailed signed payload, subdigest is not enough`);
    const result = [];
    let mutatedPayload = signedPayload;
    // Recover the chain of signatures
    // NOTICE: Remove the suffix from the "first" siganture
    // otherwise we recurse infinitely
    for (const sig of [
        _extends({}, signature, {
            suffix: undefined
        }),
        ...signature.suffix
    ]){
        const recovered = await recoverSignature(sig, mutatedPayload, provider);
        result.unshift(recovered);
        const nextMessage = setImageHashStruct(imageHash(deepestConfigOfSignature(recovered)));
        mutatedPayload = _extends({}, mutatedPayload, {
            message: nextMessage,
            digest: (0, _ethers.ethers).utils.keccak256(nextMessage)
        });
    }
    const main = result[0];
    const suffix = result.slice(1);
    return _extends({}, main, {
        suffix
    });
}
function encodeChain(main, suffix) {
    const allSignatures = [
        main,
        ...suffix || []
    ];
    const encodedMap = allSignatures.map((s)=>(0, _ethers.ethers).utils.arrayify(encodeSignature(s)));
    const body = (0, _ethers.ethers).utils.solidityPack(encodedMap.map(()=>[
            "uint24",
            "bytes"
        ]).flat(), encodedMap.map((s)=>[
            s.length,
            s
        ]).flat());
    return (0, _ethers.ethers).utils.solidityPack([
        "uint8",
        "bytes"
    ], [
        SignatureType.Chained,
        body
    ]);
}
function encodeSignature(decoded) {
    if ((0, _ethers.ethers).utils.isBytesLike(decoded)) return (0, _ethers.ethers).utils.hexlify(decoded);
    if (isUnrecoveredChainedSignature(decoded) || isChainedSignature(decoded)) return encodeChain(encodeSignature(decoded), (decoded.suffix || []).map(encodeSignature));
    const body = isUnrecoveredSignature(decoded) ? decoded.decoded : decoded.config;
    switch(decoded.type){
        case SignatureType.Legacy:
            if ((0, _ethers.ethers).BigNumber.from(body.threshold).gt(255)) throw new Error(`Legacy signature threshold is too large: ${body.threshold} (max 255)`);
            return encodeSignatureBody(body);
        case SignatureType.NoChainIdDynamic:
        case SignatureType.Dynamic:
            return (0, _ethers.ethers).utils.solidityPack([
                "uint8",
                "bytes"
            ], [
                decoded.type,
                encodeSignatureBody(body)
            ]);
        case SignatureType.Chained:
            throw new Error(`Unreachable code: Chained signature should be handled above`);
        default:
            throw new Error(`Invalid signature type: ${decoded.type}`);
    }
}
function encodeSignatureBody(decoded) {
    return (0, _ethers.ethers).utils.solidityPack([
        "uint16",
        "uint32",
        "bytes"
    ], [
        decoded.threshold,
        decoded.checkpoint,
        encodeSignatureTree(decoded.tree)
    ]);
}
function encodeSignatureTree(tree) {
    if (isNode(tree) || isUnrecoveredNode(tree)) {
        const encodedRight = (0, _ethers.ethers).utils.arrayify(encodeSignatureTree(tree.right));
        const encodedLeft = (0, _ethers.ethers).utils.arrayify(encodeSignatureTree(tree.left));
        const isBranching = isNode(tree.right) || isUnrecoveredNode(tree.right);
        if (isBranching) return (0, _ethers.ethers).utils.solidityPack([
            "bytes",
            "uint8",
            "uint24",
            "bytes"
        ], [
            encodedLeft,
            SignaturePartType.Branch,
            encodedRight.length,
            encodedRight
        ]);
        else return (0, _ethers.ethers).utils.solidityPack([
            "bytes",
            "bytes"
        ], [
            encodedLeft,
            encodedRight
        ]);
    }
    if (isNestedLeaf(tree) || isUnrecoveredNestedLeaf(tree)) {
        const nested = (0, _ethers.ethers).utils.arrayify(encodeSignatureTree(tree.tree));
        return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "uint16",
            "uint24",
            "bytes"
        ], [
            SignaturePartType.Nested,
            tree.weight,
            tree.threshold,
            nested.length,
            nested
        ]);
    }
    if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) {
        const signature = (0, _ethers.ethers).utils.arrayify(tree.signature);
        if (tree.isDynamic || signature.length !== SignaturePartTypeLength) {
            if (!tree.address) throw new Error(`Dynamic signature leaf must have address`);
            return (0, _ethers.ethers).utils.solidityPack([
                "uint8",
                "uint8",
                "address",
                "uint24",
                "bytes"
            ], [
                SignaturePartType.DynamicSignature,
                tree.weight,
                tree.address,
                signature.length,
                signature
            ]);
        } else return (0, _ethers.ethers).utils.solidityPack([
            "uint8",
            "uint8",
            "bytes"
        ], [
            SignaturePartType.Signature,
            tree.weight,
            signature
        ]);
    }
    if (isSignerLeaf(tree)) return (0, _ethers.ethers).utils.solidityPack([
        "uint8",
        "uint8",
        "address"
    ], [
        SignaturePartType.Address,
        tree.weight,
        tree.address
    ]);
    if (isNodeLeaf(tree)) return (0, _ethers.ethers).utils.solidityPack([
        "uint8",
        "bytes32"
    ], [
        SignaturePartType.Node,
        tree.nodeHash
    ]);
    if (isSubdigestLeaf(tree)) return (0, _ethers.ethers).utils.solidityPack([
        "uint8",
        "bytes32"
    ], [
        SignaturePartType.Subdigest,
        tree.subdigest
    ]);
    throw new Error(`Unknown signature tree type: ${tree}`);
}
function signaturesOf(topology) {
    if (isNode(topology)) return [
        ...signaturesOf(topology.left),
        ...signaturesOf(topology.right)
    ];
    if (isNestedLeaf(topology)) return signaturesOf(topology.tree);
    if (isSignerLeaf(topology) && topology.signature) return [
        {
            address: topology.address,
            signature: topology.signature
        }
    ];
    return [];
}
function signaturesOfDecoded(utopology) {
    if (isUnrecoveredNode(utopology)) return [
        ...signaturesOfDecoded(utopology.left),
        ...signaturesOfDecoded(utopology.right)
    ];
    if (isUnrecoveredNestedLeaf(utopology)) return signaturesOfDecoded(utopology.tree);
    if (isUnrecoveredSignatureLeaf(utopology)) return [
        utopology.signature
    ];
    return [];
}
function subdigestsOfDecoded(utopology) {
    if (isUnrecoveredNode(utopology)) return [
        ...subdigestsOfDecoded(utopology.left),
        ...subdigestsOfDecoded(utopology.right)
    ];
    if (isUnrecoveredNestedLeaf(utopology)) return subdigestsOfDecoded(utopology.tree);
    if (isSubdigestLeaf(utopology)) return [
        utopology.subdigest
    ];
    return [];
}
async function trimSignature(signature) {
    const decoded = typeof signature === "string" ? decodeSignature(signature) : signature;
    if (isUnrecoveredChainedSignature(decoded)) {
        // We need to trim every suffix AND the main signature
        const _trimmed = await Promise.all([
            trimSignature(_extends({}, decoded, {
                suffix: undefined
            })),
            ...decoded.suffix.map((s)=>trimSignature(s))
        ]);
        return encodeChain(_trimmed[0], _trimmed.slice(1));
    }
    const { trimmed } = await trimUnrecoveredTree(decoded.decoded.tree);
    return encodeSignature(_extends({}, decoded, {
        decoded: _extends({}, decoded.decoded, {
            tree: trimmed
        })
    }));
}
async function trimUnrecoveredTree(tree, trimStaticDigest = true) {
    if (isUnrecoveredNode(tree)) {
        const [left, right] = await Promise.all([
            trimUnrecoveredTree(tree.left),
            trimUnrecoveredTree(tree.right)
        ]);
        if (left.weight === 0 && right.weight === 0) try {
            // If both weights are 0 then it means we don't have any signatures yet
            // because of that, we should be able to "recover" the tree with any subdigest
            // and still get the valid node hash (there shouldn't be any signatures to verify)
            const recovered = await recoverTopology(tree, (0, _ethers.ethers).constants.HashZero, undefined);
            return {
                weight: 0,
                trimmed: {
                    nodeHash: hashNode(recovered)
                }
            };
        } catch (_unused) {
        // If something fails it's more likely because some signatures have sneaked in
        // in that case we should keep this node
        }
        else return {
            weight: left.weight + right.weight,
            trimmed: {
                left: left.trimmed,
                right: right.trimmed
            }
        };
    }
    if (isUnrecoveredNestedLeaf(tree)) {
        const trimmed = await trimUnrecoveredTree(tree.tree);
        if (trimmed.weight === 0) try {
            // If the nested leaf is empty, we can recover it with any subdigest
            // and still get the valid node hash (there shouldn't be any signatures to verify)
            const recovered = await recoverTopology(tree, (0, _ethers.ethers).constants.HashZero, undefined);
            return {
                weight: 0,
                trimmed: {
                    nodeHash: hashNode(recovered)
                }
            };
        } catch (_unused2) {
        // If something fails it's more likely because some signatures have sneaked in
        // in that case we should keep this node
        }
        return {
            weight: trimmed.weight,
            trimmed: {
                weight: tree.weight,
                threshold: tree.threshold,
                tree: trimmed.trimmed
            }
        };
    }
    // Hash nodes can be encoded as signer leaves if they have a weight below
    // 256, most likely the are signer leaves wrongly encoded
    if (isNodeLeaf(tree) && isEncodedSignerLeaf(tree.nodeHash)) return {
        weight: 0,
        trimmed: _extends({}, decodeSignerLeaf(tree.nodeHash))
    };
    if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) return {
        weight: (0, _ethers.ethers).BigNumber.from(tree.weight).toNumber(),
        trimmed: tree
    };
    if (!trimStaticDigest && isSubdigestLeaf(tree)) return {
        weight: Infinity,
        trimmed: tree
    };
    return {
        weight: 0,
        trimmed: tree
    };
}
const SignatureCoder = {
    decode: (data)=>{
        return decodeSignature(data);
    },
    encode: (data)=>{
        return encodeSignature(data);
    },
    trim: (data)=>{
        return trimSignature(data);
    },
    supportsNoChainId: true,
    recover: (data, payload, provider)=>{
        return recoverSignature(data, payload, provider);
    },
    encodeSigners: (config, signatures, subdigests, chainId)=>{
        return encodeSigners(config, signatures, subdigests, chainId);
    },
    hasEnoughSigningPower: (config, signatures)=>{
        const { weight } = SignatureCoder.encodeSigners(config, signatures, [], 0);
        return weight.gte(config.threshold);
    },
    chainSignatures: (main, suffix)=>{
        // Notice: v2 expects suffix to be reversed
        // that being: from signed to current imageHash
        const reversed = suffix.reverse();
        const mraw = (0, _ethers.ethers).utils.isBytesLike(main) ? main : encodeSignature(main);
        const sraw = reversed.map((s)=>(0, _ethers.ethers).utils.isBytesLike(s) ? s : encodeSignature(s));
        return encodeChain(mraw, sraw);
    },
    hashSetImageHash: function(imageHash) {
        return hashSetImageHash(imageHash);
    },
    signaturesOf (config) {
        return signaturesOf(config.tree);
    },
    signaturesOfDecoded: function(data) {
        return signaturesOfDecoded(data.decoded.tree);
    }
};
var signature = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    SignatureType: SignatureType,
    SignaturePartType: SignaturePartType,
    SignaturePartTypeLength: SignaturePartTypeLength,
    isUnrecoveredNode: isUnrecoveredNode,
    isUnrecoveredNestedLeaf: isUnrecoveredNestedLeaf,
    isUnrecoveredSignatureLeaf: isUnrecoveredSignatureLeaf,
    decodeSignatureTree: decodeSignatureTree,
    InvalidSignatureLeafError: InvalidSignatureLeafError,
    recoverTopology: recoverTopology,
    partEncoder: partEncoder,
    encodeSigners: encodeSigners,
    encodeTree: encodeTree,
    deepestConfigOfSignature: deepestConfigOfSignature,
    isUnrecoveredSignature: isUnrecoveredSignature,
    isUnrecoveredChainedSignature: isUnrecoveredChainedSignature,
    isSignature: isSignature,
    isChainedSignature: isChainedSignature,
    decodeSignature: decodeSignature,
    decodeSignatureBody: decodeSignatureBody,
    decodeChainedSignature: decodeChainedSignature,
    setImageHashStruct: setImageHashStruct,
    recoverSignature: recoverSignature,
    encodeChain: encodeChain,
    encodeSignature: encodeSignature,
    encodeSignatureBody: encodeSignatureBody,
    encodeSignatureTree: encodeSignatureTree,
    signaturesOf: signaturesOf,
    signaturesOfDecoded: signaturesOfDecoded,
    subdigestsOfDecoded: subdigestsOfDecoded,
    trimSignature: trimSignature,
    trimUnrecoveredTree: trimUnrecoveredTree,
    SignatureCoder: SignatureCoder
});
//
// Tree typings - leaves
//
// This is an unknown node
// it means the tree has a branch
// but we don't know what the content
function isSignerLeaf(leaf) {
    return leaf.address !== undefined && leaf.weight !== undefined;
}
function isSubdigestLeaf(leaf) {
    return leaf.subdigest !== undefined && leaf.address === undefined;
}
function topologyToJSON(tree) {
    if (isNode(tree)) return JSON.stringify({
        left: topologyToJSON(tree.left),
        right: topologyToJSON(tree.right)
    });
    if (isNestedLeaf(tree)) return JSON.stringify({
        weight: (0, _ethers.ethers).BigNumber.from(tree.weight).toString(),
        threshold: (0, _ethers.ethers).BigNumber.from(tree.threshold).toString(),
        tree: topologyToJSON(tree.tree)
    });
    if (isSignerLeaf(tree)) return JSON.stringify({
        address: tree.address,
        weight: (0, _ethers.ethers).BigNumber.from(tree.weight).toString()
    });
    return JSON.stringify(tree);
}
function topologyFromJSON(json) {
    const parsed = typeof json === "string" ? JSON.parse(json) : json;
    if (parsed.left !== undefined && parsed.right !== undefined) return {
        left: topologyFromJSON(parsed.left),
        right: topologyFromJSON(parsed.right)
    };
    if (parsed.weight !== undefined && parsed.threshold !== undefined && parsed.tree !== undefined) return {
        weight: (0, _ethers.ethers).BigNumber.from(parsed.weight),
        threshold: (0, _ethers.ethers).BigNumber.from(parsed.threshold),
        tree: topologyFromJSON(parsed.tree)
    };
    if (parsed.address !== undefined && parsed.weight !== undefined) return {
        address: parsed.address,
        weight: (0, _ethers.ethers).BigNumber.from(parsed.weight)
    };
    return parsed;
}
function isNestedLeaf(leaf) {
    return leaf.tree !== undefined && leaf.weight !== undefined && leaf.threshold !== undefined;
}
function isNodeLeaf(leaf) {
    return leaf.nodeHash !== undefined;
}
function isLeaf(leaf) {
    return isSignerLeaf(leaf) || isSubdigestLeaf(leaf) || isNestedLeaf(leaf) || isNodeLeaf(leaf);
}
//
// Tree typings - nodes
//
function isNode(node) {
    return node.left !== undefined && node.right !== undefined;
}
function isTopology(topology) {
    return isNode(topology) || isLeaf(topology);
}
function encodeSignerLeaf(leaf) {
    return (0, _ethers.ethers).utils.solidityPack([
        "uint96",
        "address"
    ], [
        leaf.weight,
        leaf.address
    ]);
}
function decodeSignerLeaf(encoded) {
    const bytes = (0, _ethers.ethers).utils.arrayify(encoded);
    if (bytes.length !== 32) throw new Error("Invalid encoded string length");
    const weight = (0, _ethers.ethers).BigNumber.from(bytes.slice(0, 12));
    const address = (0, _ethers.ethers).utils.getAddress((0, _ethers.ethers).utils.hexlify(bytes.slice(12)));
    return {
        weight,
        address
    };
}
function isEncodedSignerLeaf(encoded) {
    const bytes = (0, _ethers.ethers).utils.arrayify(encoded);
    if (bytes.length !== 32) return false;
    const prefix = bytes.slice(0, 11);
    return prefix.every((byte)=>byte === 0);
}
function hashNode(node) {
    if (isSignerLeaf(node)) return encodeSignerLeaf(node);
    if (isSubdigestLeaf(node)) return (0, _ethers.ethers).utils.solidityKeccak256([
        "string",
        "bytes32"
    ], [
        "Sequence static digest:\n",
        node.subdigest
    ]);
    if (isNestedLeaf(node)) {
        const nested = hashNode(node.tree);
        return (0, _ethers.ethers).utils.solidityKeccak256([
            "string",
            "bytes32",
            "uint256",
            "uint256"
        ], [
            "Sequence nested config:\n",
            nested,
            node.threshold,
            node.weight
        ]);
    }
    if (isNodeLeaf(node)) return node.nodeHash;
    return (0, _ethers.ethers).utils.solidityKeccak256([
        "bytes32",
        "bytes32"
    ], [
        hashNode(node.left),
        hashNode(node.right)
    ]);
}
function leftFace(topology) {
    const stack = [];
    let prev = topology;
    while(!isLeaf(prev)){
        stack.unshift(prev.right);
        prev = prev.left;
    }
    stack.unshift(prev);
    return stack;
}
//
// Wallet config types
//
function isWalletConfig(config) {
    return config.threshold !== undefined && config.checkpoint !== undefined && config.tree !== undefined && config.version !== undefined && config.version === 2;
}
function imageHash(config) {
    return (0, _ethers.ethers).utils.solidityKeccak256([
        "bytes32",
        "uint256"
    ], [
        (0, _ethers.ethers).utils.solidityKeccak256([
            "bytes32",
            "uint256"
        ], [
            hashNode(config.tree),
            config.threshold
        ]),
        config.checkpoint
    ]);
}
//
// Simple wallet config types
// (used for building and reading merkle configs)
//
// dev: `members` is a flat representation of the tree
//      it keeps relevant structure like 'nested trees' but
//      it ignores the tree structure
//
//
function isSimpleNestedMember(member) {
    return member.threshold !== undefined && member.weight !== undefined && member.members !== undefined;
}
function topologyToMembers(tree) {
    if (isSignerLeaf(tree) || isSubdigestLeaf(tree)) return [
        tree
    ];
    if (isNestedLeaf(tree)) return [
        {
            threshold: tree.threshold,
            weight: tree.weight,
            members: topologyToMembers(tree.tree)
        }
    ];
    if (isNodeLeaf(tree)) // we don't know the content of this node
    // so we omit it
    return [];
    return [
        ...topologyToMembers(tree.left),
        ...topologyToMembers(tree.right)
    ];
}
function hasUnknownNodes(tree) {
    if (isNodeLeaf(tree)) return true;
    if (isNode(tree)) return hasUnknownNodes(tree.left) || hasUnknownNodes(tree.right);
    return false;
}
function toSimpleWalletConfig(config) {
    return {
        threshold: config.threshold,
        checkpoint: config.checkpoint,
        members: topologyToMembers(config.tree)
    };
}
const membersAsTopologies = (members, builder)=>{
    return members.map((member)=>{
        if (isSimpleNestedMember(member)) return {
            tree: builder(member.members),
            threshold: member.threshold,
            weight: member.weight
        };
        return member;
    });
};
function legacyTopologyBuilder(members) {
    if (members.length === 0) throw new Error("Empty members array");
    const asTopologies = membersAsTopologies(members, legacyTopologyBuilder);
    return asTopologies.reduce((acc, member)=>{
        return {
            left: acc,
            right: member
        };
    });
}
function merkleTopologyBuilder(members) {
    if (members.length === 0) throw new Error("Empty members array");
    const leaves = membersAsTopologies(members, merkleTopologyBuilder);
    for(let s = leaves.length; s > 1; s = s / 2)for(let i = 0; i < s / 2; i++){
        const j1 = i * 2;
        const j2 = j1 + 1;
        if (j2 >= s) leaves[i] = leaves[j1];
        else leaves[i] = {
            left: leaves[j1],
            right: leaves[j2]
        };
    }
    return leaves[0];
}
function optimized2SignersTopologyBuilder(members) {
    if (members.length > 8) return merkleTopologyBuilder(members);
    return legacyTopologyBuilder(members);
}
function toWalletConfig(simpleWalletConfig, builder = optimized2SignersTopologyBuilder) {
    return {
        version: 2,
        threshold: simpleWalletConfig.threshold,
        checkpoint: simpleWalletConfig.checkpoint,
        tree: builder(simpleWalletConfig.members)
    };
}
function hasSubdigest(tree, subdigest) {
    if (isSubdigestLeaf(tree)) return tree.subdigest === subdigest;
    if (isNode(tree)) return hasSubdigest(tree.left, subdigest) || hasSubdigest(tree.right, subdigest);
    return false;
}
function signersOf(tree) {
    const stack = [
        tree
    ];
    const signers = new Set();
    while(stack.length > 0){
        const node = stack.pop();
        if (isNestedLeaf(node)) stack.push(node.tree);
        else if (isNode(node)) {
            stack.push(node.left);
            stack.push(node.right);
        } else if (isSignerLeaf(node)) signers.add({
            address: node.address,
            weight: (0, _ethers.ethers).BigNumber.from(node.weight).toNumber()
        });
    }
    return Array.from(signers);
}
function isComplete(tree) {
    if (isNode(tree)) return isComplete(tree.left) && isComplete(tree.right);
    return !isNodeLeaf(tree);
}
const ConfigCoder = {
    isWalletConfig: (config)=>{
        return config.version === 2 && config.threshold !== undefined && config.tree !== undefined;
    },
    imageHashOf: (config)=>{
        return imageHash(config);
    },
    hasSubdigest: (config, subdigest)=>{
        return hasSubdigest(config.tree, subdigest);
    },
    checkpointOf: (config)=>{
        return (0, _ethers.ethers).BigNumber.from(config.checkpoint);
    },
    signersOf: (config)=>{
        return signersOf(config.tree);
    },
    fromSimple: (config)=>{
        var _config$subdigests;
        return toWalletConfig(_extends({}, config, {
            members: [
                ...config.signers,
                ...((_config$subdigests = config.subdigests) != null ? _config$subdigests : []).map((subdigest)=>({
                        subdigest
                    }))
            ]
        }));
    },
    isComplete: (config)=>{
        return isComplete(config.tree);
    },
    // isValid = (config: WalletConfig): boolean {}
    /**
   *
   * Notice: context and kind are ignored because v2
   * doesn't need to manually update the implementation before
   * a configuration update, it's automatically done by the contract.
   *
   */ update: {
        isKindUsed: true,
        buildTransaction: (wallet, config, _context, _kind)=>{
            const module = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModuleUpgradable.abi);
            return {
                entrypoint: wallet,
                transactions: [
                    {
                        to: wallet,
                        data: module.encodeFunctionData(module.getFunction("updateImageHash"), [
                            ConfigCoder.imageHashOf(config)
                        ]),
                        gasLimit: 0,
                        delegateCall: false,
                        revertOnError: true,
                        value: 0
                    }
                ]
            };
        },
        decodeTransaction: function(tx) {
            var _tx$transactions$0$va, _tx$transactions$, _tx$transactions$0$ga, _tx$transactions$2;
            const module = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModuleUpgradable.abi);
            if (tx.transactions.length !== 1) throw new Error("Invalid transaction bundle, expected 1 transaction");
            const data = tx.transactions[0].data;
            if (!data) throw new Error("Invalid transaction bundle, expected data");
            const decoded = module.decodeFunctionData(module.getFunction("updateImageHash"), data);
            if (!decoded) throw new Error("Invalid transaction bundle, expected valid data");
            if (tx.transactions[0].to !== tx.entrypoint) throw new Error("Invalid transaction bundle, expected to be sent to entrypoint");
            if (tx.transactions[0].delegateCall) throw new Error("Invalid transaction bundle, expected not to be a delegateCall");
            if (!tx.transactions[0].revertOnError) throw new Error("Invalid transaction bundle, expected revertOnError");
            if (!(0, _ethers.ethers).constants.Zero.eq((_tx$transactions$0$va = (_tx$transactions$ = tx.transactions[0]) == null ? void 0 : _tx$transactions$.value) != null ? _tx$transactions$0$va : 0)) throw new Error("Invalid transaction bundle, expected value to be 0");
            if (!(0, _ethers.ethers).constants.Zero.eq((_tx$transactions$0$ga = (_tx$transactions$2 = tx.transactions[0]) == null ? void 0 : _tx$transactions$2.gasLimit) != null ? _tx$transactions$0$ga : 0)) throw new Error("Invalid transaction bundle, expected value to be 0");
            return {
                address: tx.entrypoint,
                newImageHash: decoded[0],
                kind: undefined
            };
        }
    },
    toJSON: function(config) {
        return JSON.stringify({
            version: config.version,
            threshold: (0, _ethers.ethers).BigNumber.from(config.threshold).toString(),
            checkpoint: (0, _ethers.ethers).BigNumber.from(config.checkpoint).toString(),
            tree: topologyToJSON(config.tree)
        });
    },
    fromJSON: function(json) {
        const config = JSON.parse(json);
        return {
            version: config.version,
            threshold: (0, _ethers.ethers).BigNumber.from(config.threshold),
            checkpoint: (0, _ethers.ethers).BigNumber.from(config.checkpoint),
            tree: topologyFromJSON(config.tree)
        };
    },
    editConfig: function(config, action) {
        var _action$threshold, _action$checkpoint;
        const members = topologyToMembers(config.tree);
        if (action.add) for (const signer of action.add){
            if (members.find((s)=>isSignerLeaf(s) && s.address === signer.address)) continue;
            members.push({
                address: signer.address,
                weight: signer.weight
            });
        }
        if (action.remove) for (const address of action.remove){
            const index = members.findIndex((s)=>isSignerLeaf(s) && s.address === address);
            if (index >= 0) members.splice(index, 1);
        }
        return {
            version: config.version,
            threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,
            checkpoint: (_action$checkpoint = action.checkpoint) != null ? _action$checkpoint : config.checkpoint,
            tree: optimized2SignersTopologyBuilder(members)
        };
    },
    buildStubSignature: function(config, overrides) {
        const parts = new Map();
        for (const [signer, signature] of overrides.entries()){
            parts.set(signer, {
                signature,
                isDynamic: true
            });
            const { encoded, weight } = encodeSigners(config, parts, [], 0);
            if (weight.gte(config.threshold)) return encoded;
        }
        const signers = signersOf(config.tree);
        for (const { address } of signers.sort(({ weight: a }, { weight: b })=>a - b)){
            const signature = "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02";
            parts.set(address, {
                signature,
                isDynamic: false
            });
            const { encoded, weight } = encodeSigners(config, parts, [], 0);
            if (weight.gte(config.threshold)) return encoded;
        }
        return encodeSigners(config, parts, [], 0).encoded;
    }
};
var config = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    isSignerLeaf: isSignerLeaf,
    isSubdigestLeaf: isSubdigestLeaf,
    topologyToJSON: topologyToJSON,
    topologyFromJSON: topologyFromJSON,
    isNestedLeaf: isNestedLeaf,
    isNodeLeaf: isNodeLeaf,
    isLeaf: isLeaf,
    isNode: isNode,
    isTopology: isTopology,
    encodeSignerLeaf: encodeSignerLeaf,
    decodeSignerLeaf: decodeSignerLeaf,
    isEncodedSignerLeaf: isEncodedSignerLeaf,
    hashNode: hashNode,
    leftFace: leftFace,
    isWalletConfig: isWalletConfig,
    imageHash: imageHash,
    isSimpleNestedMember: isSimpleNestedMember,
    topologyToMembers: topologyToMembers,
    hasUnknownNodes: hasUnknownNodes,
    toSimpleWalletConfig: toSimpleWalletConfig,
    legacyTopologyBuilder: legacyTopologyBuilder,
    merkleTopologyBuilder: merkleTopologyBuilder,
    optimized2SignersTopologyBuilder: optimized2SignersTopologyBuilder,
    toWalletConfig: toWalletConfig,
    hasSubdigest: hasSubdigest,
    signersOf: signersOf,
    isComplete: isComplete,
    ConfigCoder: ConfigCoder
});
var context$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
const coders = {
    config: ConfigCoder,
    signature: SignatureCoder
};
const version = 2;
const DeployedWalletContext = {
    version: version,
    factory: "0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A",
    guestModule: "0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE",
    mainModule: "0xfBf8f1A5E00034762D928f46d438B947f5d4065d",
    mainModuleUpgradable: "0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911",
    walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var v2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    config: config,
    signature: signature,
    context: context$1,
    chained: chained,
    coders: coders,
    version: version,
    DeployedWalletContext: DeployedWalletContext
});
function addressOf(context, imageHash) {
    const codeHash = (0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.solidityPack([
        "bytes",
        "bytes32"
    ], [
        context.walletCreationCode,
        (0, _ethers.ethers).utils.hexZeroPad(context.mainModule, 32)
    ]));
    const hash = (0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.solidityPack([
        "bytes1",
        "address",
        "bytes32",
        "bytes32"
    ], [
        "0xff",
        context.factory,
        imageHash,
        codeHash
    ]));
    return (0, _ethers.ethers).utils.getAddress((0, _ethers.ethers).utils.hexDataSlice(hash, 12));
}
async function isValidCounterfactual(wallet, digest, signature, chainId, provider, contexts) {
    // We don't know the version of the signature
    // so we need to try all of them
    const res = await Promise.all(allVersions.map(async (version)=>{
        try {
            const decoded = version.signature.SignatureCoder.decode((0, _ethers.ethers).utils.hexlify(signature));
            const recovered1 = await version.signature.SignatureCoder.recover(decoded, {
                address: wallet,
                digest: (0, _ethers.ethers).utils.hexlify(digest),
                chainId
            }, provider);
            const imageHash = version.config.ConfigCoder.imageHashOf(recovered1.config);
            const counterfactualAddress = addressOf(contexts[version.version], imageHash);
            if (counterfactualAddress.toLowerCase() === wallet.toLowerCase()) return true;
            // chainId=0 means no chainId, so the signature is valid for all chains
            // we need to check that case too
            const recovered2 = await version.signature.SignatureCoder.recover(decoded, {
                address: wallet,
                digest: (0, _ethers.ethers).utils.hexlify(digest),
                chainId
            }, provider);
            const imageHash2 = version.config.ConfigCoder.imageHashOf(recovered2.config);
            const counterfactualAddress2 = addressOf(contexts[version.version], imageHash2);
            return counterfactualAddress2.toLowerCase() === wallet.toLowerCase();
        } catch (_unused) {}
        // We most likely failed to decode the signature
        return false;
    }));
    return res.some((r)=>r);
}
function isValidVersionedContext(contexts) {
    // number of keys is the number of versions
    const versions = Object.keys(contexts).length;
    // check that all versions exist and are valid
    for(let i = 1; i <= versions; i++){
        const context = contexts[i];
        if (!context || context.version !== i) return false;
    }
    return true;
}
function latestContext(contexts) {
    const versions = Object.keys(contexts).length;
    return contexts[versions];
}
const defaultContexts = {
    1: DeployedWalletContext$1,
    2: DeployedWalletContext
};
var context = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    addressOf: addressOf,
    isValidCounterfactual: isValidCounterfactual,
    isValidVersionedContext: isValidVersionedContext,
    latestContext: latestContext,
    defaultContexts: defaultContexts
});
const MetaTransactionsType = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function intendTransactionBundle(bundle, wallet, chainId, id) {
    return _extends({}, bundle, {
        chainId,
        intent: {
            id: id,
            wallet
        }
    });
}
function intendedTransactionID(bundle) {
    return (0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.defaultAbiCoder.encode([
        "address",
        "uint256",
        "bytes32"
    ], [
        bundle.intent.wallet,
        bundle.chainId,
        bundle.intent.id
    ]));
}
function unpackMetaTransactionsData(data) {
    const res = (0, _ethers.ethers).utils.defaultAbiCoder.decode([
        "uint256",
        MetaTransactionsType
    ], data);
    if (res.length !== 2 || !res[0] || !res[1]) throw new Error("Invalid meta transaction data");
    return [
        res[0],
        res[1]
    ];
}
function packMetaTransactionsData(nonce, txs) {
    return (0, _ethers.ethers).utils.defaultAbiCoder.encode([
        "uint256",
        MetaTransactionsType
    ], [
        nonce,
        sequenceTxAbiEncode(txs)
    ]);
}
function digestOfTransactions(nonce, txs) {
    return (0, _ethers.ethers).utils.keccak256(packMetaTransactionsData(nonce, txs));
}
function subdigestOfTransactions(address, chainId, nonce, txs) {
    return subdigestOf({
        address,
        chainId,
        digest: digestOfTransactions(nonce, txs)
    });
}
function subdigestOfGuestModuleTransactions(guestModule, chainId, txs) {
    return subdigestOf({
        address: guestModule,
        chainId,
        digest: (0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.defaultAbiCoder.encode([
            "string",
            MetaTransactionsType
        ], [
            "guest:",
            sequenceTxAbiEncode(txs)
        ]))
    });
}
function toSequenceTransactions(wallet, txs) {
    return txs.map((tx)=>toSequenceTransaction(wallet, tx));
}
function toSequenceTransaction(wallet, tx) {
    if (tx.to && tx.to !== (0, _ethers.ethers).constants.AddressZero) return {
        nonce: tx.nonce,
        transaction: {
            delegateCall: false,
            revertOnError: false,
            gasLimit: tx.gasLimit || 0,
            to: tx.to,
            value: tx.value || 0,
            data: tx.data || "0x"
        }
    };
    else {
        const walletInterface = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModule.abi);
        const data = walletInterface.encodeFunctionData(walletInterface.getFunction("createContract"), [
            tx.data
        ]);
        return {
            nonce: tx.nonce,
            transaction: {
                delegateCall: false,
                revertOnError: false,
                gasLimit: tx.gasLimit,
                to: wallet,
                value: tx.value || 0,
                data: data
            }
        };
    }
}
function isSequenceTransaction(tx) {
    return tx.delegateCall !== undefined || tx.revertOnError !== undefined;
}
function hasSequenceTransactions(txs) {
    return txs.every(isSequenceTransaction);
}
// TODO: We may be able to remove this if we make Transaction === TransactionEncoded
function sequenceTxAbiEncode(txs) {
    return txs.map((t)=>{
        var _t$to;
        return {
            delegateCall: t.delegateCall === true,
            revertOnError: t.revertOnError === true,
            gasLimit: t.gasLimit !== undefined ? t.gasLimit : (0, _ethers.ethers).constants.Zero,
            target: (_t$to = t.to) != null ? _t$to : (0, _ethers.ethers).constants.AddressZero,
            value: t.value !== undefined ? t.value : (0, _ethers.ethers).constants.Zero,
            data: t.data !== undefined ? t.data : []
        };
    });
}
function fromTxAbiEncode(txs) {
    return txs.map((t)=>({
            delegateCall: t.delegateCall,
            revertOnError: t.revertOnError,
            gasLimit: t.gasLimit,
            to: t.target,
            value: t.value,
            data: t.data
        }));
}
// export function appendNonce(txs: Transaction[], nonce: BigNumberish): Transaction[] {
//   return txs.map((t: Transaction) => ({ ...t, nonce }))
// }
function encodeNonce(space, nonce) {
    const bspace = (0, _ethers.ethers).BigNumber.from(space);
    const bnonce = (0, _ethers.ethers).BigNumber.from(nonce);
    const shl = (0, _ethers.ethers).constants.Two.pow((0, _ethers.ethers).BigNumber.from(96));
    if (!bnonce.div(shl).eq((0, _ethers.ethers).constants.Zero)) throw new Error("Space already encoded");
    return bnonce.add(bspace.mul(shl));
}
function decodeNonce(nonce) {
    const bnonce = (0, _ethers.ethers).BigNumber.from(nonce);
    const shr = (0, _ethers.ethers).constants.Two.pow((0, _ethers.ethers).BigNumber.from(96));
    return [
        bnonce.div(shr),
        bnonce.mod(shr)
    ];
}
function fromTransactionish(wallet, transaction) {
    if (Array.isArray(transaction)) {
        if (hasSequenceTransactions(transaction)) return transaction;
        else {
            const stx = toSequenceTransactions(wallet, transaction);
            return stx.map((t)=>t.transaction);
        }
    } else if (isSequenceTransaction(transaction)) return [
        transaction
    ];
    else return [
        toSequenceTransaction(wallet, transaction).transaction
    ];
}
function isTransactionBundle(cand) {
    return cand !== undefined && cand.entrypoint !== undefined && cand.chainId !== undefined && cand.transactions !== undefined && cand.nonce !== undefined && cand.intent !== undefined && cand.intent.id !== undefined && cand.intent.wallet !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c)=>p && isSequenceTransaction(c), true);
}
function isSignedTransactionBundle(cand) {
    return cand !== undefined && cand.signature !== undefined && cand.signature !== "" && isTransactionBundle(cand);
}
function encodeBundleExecData(bundle) {
    const walletInterface = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModule.abi);
    return walletInterface.encodeFunctionData(walletInterface.getFunction("execute"), isSignedTransactionBundle(bundle) ? [
        // Signed transaction bundle has all 3 parameters
        sequenceTxAbiEncode(bundle.transactions),
        bundle.nonce,
        bundle.signature
    ] : [
        // Unsigned bundle may be a GuestModule call, so signature and nonce are missing
        sequenceTxAbiEncode(bundle.transactions),
        0,
        []
    ]);
}
// TODO: Use Sequence ABI package
const selfExecuteSelector = "0x61c2926c";
const selfExecuteAbi = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
// Splits Sequence batch transactions into individual parts
const unwind = (wallet, transactions)=>{
    const unwound = [];
    const walletInterface = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModule.abi);
    for (const tx of transactions){
        const txData = (0, _ethers.ethers).utils.arrayify(tx.data || "0x");
        if (tx.to === wallet && (0, _ethers.ethers).utils.hexlify(txData.slice(0, 4)) === selfExecuteSelector) {
            // Decode as selfExecute call
            const data = txData.slice(4);
            const decoded = (0, _ethers.ethers).utils.defaultAbiCoder.decode([
                selfExecuteAbi
            ], data)[0];
            unwound.push(...unwind(tx.to, decoded.map((d)=>_extends({}, d, {
                    to: d.target
                }))));
        } else try {
            const innerTransactions = walletInterface.decodeFunctionData("execute", txData)[0];
            const unwoundTransactions = unwind(wallet, innerTransactions.map((tx)=>_extends({}, tx, {
                    to: tx.target
                })));
            unwound.push(...unwoundTransactions);
        } catch (_unused) {
            unwound.push(tx);
        }
    }
    return unwound;
};
var transaction = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    MetaTransactionsType: MetaTransactionsType,
    intendTransactionBundle: intendTransactionBundle,
    intendedTransactionID: intendedTransactionID,
    unpackMetaTransactionsData: unpackMetaTransactionsData,
    packMetaTransactionsData: packMetaTransactionsData,
    digestOfTransactions: digestOfTransactions,
    subdigestOfTransactions: subdigestOfTransactions,
    subdigestOfGuestModuleTransactions: subdigestOfGuestModuleTransactions,
    toSequenceTransactions: toSequenceTransactions,
    toSequenceTransaction: toSequenceTransaction,
    isSequenceTransaction: isSequenceTransaction,
    hasSequenceTransactions: hasSequenceTransactions,
    sequenceTxAbiEncode: sequenceTxAbiEncode,
    fromTxAbiEncode: fromTxAbiEncode,
    encodeNonce: encodeNonce,
    decodeNonce: decodeNonce,
    fromTransactionish: fromTransactionish,
    isTransactionBundle: isTransactionBundle,
    isSignedTransactionBundle: isSignedTransactionBundle,
    encodeBundleExecData: encodeBundleExecData,
    selfExecuteSelector: selfExecuteSelector,
    selfExecuteAbi: selfExecuteAbi,
    unwind: unwind
});
/* Source of Offchain EIP-6492 validation:

// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.18;


// As per ERC-1271
interface IERC1271Wallet {
  function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);
}

error ERC1271Revert(bytes error);
error ERC6492DeployFailed(bytes error);

contract UniversalSigValidator {
  bytes32 private constant ERC6492_DETECTION_SUFFIX = 0x6492649264926492649264926492649264926492649264926492649264926492;
  bytes4 private constant ERC1271_SUCCESS = 0x1626ba7e;

  function isValidSigImpl(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature,
    bool allowSideEffects,
    bool deployAlreadyDeployed
  ) public returns (bool) {
    uint contractCodeLen = address(_signer).code.length;
    bytes memory sigToValidate;
    // The order here is striclty defined in https://eips.ethereum.org/EIPS/eip-6492
    // - ERC-6492 suffix check and verification first, while being permissive in case the contract is already deployed; if the contract is deployed we will check the sig against the deployed version, this allows 6492 signatures to still be validated while taking into account potential key rotation
    // - ERC-1271 verification if there's contract code
    // - finally, ecrecover
    bool isCounterfactual = bytes32(_signature[_signature.length-32:_signature.length]) == ERC6492_DETECTION_SUFFIX;
    if (isCounterfactual) {
      address create2Factory;
      bytes memory factoryCalldata;
      (create2Factory, factoryCalldata, sigToValidate) = abi.decode(_signature[0:_signature.length-32], (address, bytes, bytes));

      if (contractCodeLen == 0 || deployAlreadyDeployed) {
        (bool success, bytes memory err) = create2Factory.call(factoryCalldata);
        if (!success) revert ERC6492DeployFailed(err);
      }
    } else {
      sigToValidate = _signature;
    }

    // Try ERC-1271 verification
    if (isCounterfactual || contractCodeLen > 0) {
      try IERC1271Wallet(_signer).isValidSignature(_hash, sigToValidate) returns (bytes4 magicValue) {
        bool isValid = magicValue == ERC1271_SUCCESS;

        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*
        // but it may be useful to retry the call making the factory call
        // even if the wallet is already deployed, in case the wallet
        // needs to perform some sort of migration or onchain key rotation
        if (!isValid && !deployAlreadyDeployed && contractCodeLen > 0) {
          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);
        }

        if (contractCodeLen == 0 && isCounterfactual && !allowSideEffects) {
          // if the call had side effects we need to return the
          // result using a `revert` (to undo the state changes)
          assembly {
            mstore(0, isValid)
            revert(31, 1)
          }
        }

        return isValid;
      } catch (bytes memory err) {
        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*
        // but it may be useful to retry the call making the factory call
        // even if the wallet is already deployed, in case the wallet
        // needs to perform some sort of migration or onchain key rotation
        if (!deployAlreadyDeployed && contractCodeLen > 0) {
          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);
        }

        revert ERC1271Revert(err);
      }
    }

    // ecrecover verification
    require(_signature.length == 65, 'SignatureValidator#recoverSigner: invalid signature length');
    bytes32 r = bytes32(_signature[0:32]);
    bytes32 s = bytes32(_signature[32:64]);
    uint8 v = uint8(_signature[64]);

    if (v != 27 && v != 28) {
      revert('SignatureValidator: invalid signature v value');
    }

    return ecrecover(_hash, v, r, s) == _signer;
  }

  function isValidSigWithSideEffects(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    return this.isValidSigImpl(_signer, _hash, _signature, true, false);
  }

  function isValidSig(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {
      return isValid;
    } catch (bytes memory error) {
      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result
      uint len = error.length;
      if (len == 1) {
        return error[0] == 0x01;
        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call
      } else {
        assembly { revert(error, len) }
      }
    }
  }

  // NOTICE: These functions aren't part of the standard
  // they are helpers that behave like the above functions
  // but they don't revert on failure, instead they return false

  function isValidSigNoThrow(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {
      return isValid;
    } catch (bytes memory error) {
      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result
      uint len = error.length;
      if (len == 1) {
        return error[0] == 0x01;
        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call
      } else {
        // Ignore all other errors and return false
        return false;
      }
    }
  }

  function isValidSigWithSideEffectsNoThrow(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    try this.isValidSigImpl(_signer, _hash, _signature, true, false) returns (bool isValid) {
      return isValid;
    } catch (bytes memory error) {
      // Ignore all errors and return false
      return false;
    }
  }
}

// this is a helper so we can perform validation in a single eth_call without pre-deploying a singleton
contract ValidateSigOffchain {
  constructor (address _signer, bytes32 _hash, bytes memory _signature) {
    UniversalSigValidator validator = new UniversalSigValidator();
    bool isValidSig = validator.isValidSigWithSideEffects(_signer, _hash, _signature);
    assembly {
      mstore(0, isValidSig)
      return(31, 1)
    }
  }
}
*/ const EIP_6492_OFFCHAIN_DEPLOY_CODE = "0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033";
const EIP_6492_SUFFIX = "0x6492649264926492649264926492649264926492649264926492649264926492";
// TODO: This is a length payload, we can lower the load by deploying
// the contract on some of the popular chains, and calling the contract
// if the provider is one of those chains
async function validateEIP6492Offchain(provider, signer, hash, signature) {
    return "0x01" === await provider.call({
        data: (0, _ethers.ethers).utils.concat([
            EIP_6492_OFFCHAIN_DEPLOY_CODE,
            new (0, _ethers.ethers).utils.AbiCoder().encode([
                "address",
                "bytes32",
                "bytes"
            ], [
                signer,
                hash,
                signature
            ])
        ])
    });
}
var validateEIP6492 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    EIP_6492_OFFCHAIN_DEPLOY_CODE: EIP_6492_OFFCHAIN_DEPLOY_CODE,
    EIP_6492_SUFFIX: EIP_6492_SUFFIX,
    validateEIP6492Offchain: validateEIP6492Offchain
});
/**
 * Provides stateful information about the wallet.
 */ /**
 * The OnChainReader class fetches on-chain data from a wallet.
 * It is used to understand the "real" state of the wallet contract on-chain.
 */ class OnChainReader {
    constructor(provider){
        this.provider = provider;
        // Simple cache to avoid re-fetching the same data
        this.isDeployedCache = new Set();
    }
    module(address) {
        return new (0, _ethers.ethers).Contract(address, [
            ...(0, _abi.walletContracts).mainModuleUpgradable.abi,
            ...(0, _abi.walletContracts).mainModule.abi,
            ...(0, _abi.walletContracts).erc1271.abi
        ], this.provider);
    }
    async isDeployed(wallet) {
        // This is safe to cache because the wallet cannot be undeployed once deployed
        if (this.isDeployedCache.has(wallet)) return true;
        const code = await this.provider.getCode(wallet).then((c)=>(0, _ethers.ethers).utils.arrayify(c));
        const isDeployed = code.length !== 0;
        if (isDeployed) this.isDeployedCache.add(wallet);
        return isDeployed;
    }
    async implementation(wallet) {
        const position = (0, _ethers.ethers).utils.defaultAbiCoder.encode([
            "address"
        ], [
            wallet
        ]);
        const val = await this.provider.getStorageAt(wallet, position).then((c)=>(0, _ethers.ethers).utils.arrayify(c));
        if (val.length === 20) return (0, _ethers.ethers).utils.getAddress((0, _ethers.ethers).utils.hexlify(val));
        if (val.length === 32) return (0, _ethers.ethers).utils.defaultAbiCoder.decode([
            "address"
        ], val)[0];
        return undefined;
    }
    async imageHash(wallet) {
        try {
            const imageHash = await this.module(wallet).imageHash();
            return imageHash;
        } catch (_unused) {}
        return undefined;
    }
    async nonce(wallet, space = 0) {
        try {
            const nonce = await this.module(wallet).readNonce(space);
            return nonce;
        } catch (e) {
            if (!await this.isDeployed(wallet)) return 0;
            throw e;
        }
    }
    // We use the EIP-6492 validator contract to check the signature
    // this means that if the wallet is not deployed, then the signature
    // must be prefixed with a transaction that deploys the wallet
    async isValidSignature(wallet, digest, signature) {
        return validateEIP6492Offchain(this.provider, wallet, digest, signature);
    }
}
var reader = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    OnChainReader: OnChainReader
});
/**
 * Request metadata, used by the wallet to pass additional information through the orchestrator.
 */ function isWalletSignRequestMetadata(obj) {
    return obj && obj.address && obj.digest && obj.chainId !== undefined && obj.config;
}
/**
 * Request metadata, used by the wallet to pass additional information through the orchestrator.
 */ var index$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    config: config$2,
    signature: signature$2,
    context: context,
    signer: signer,
    EIP1271: validateEIP1271,
    transaction: transaction,
    reader: reader,
    EIP6492: validateEIP6492,
    isWalletSignRequestMetadata: isWalletSignRequestMetadata
});
const ALL_CODERS = [
    {
        config: ConfigCoder$1,
        signature: SignatureCoder$1
    },
    {
        config: ConfigCoder,
        signature: SignatureCoder
    }
];
function coderFor(version) {
    const index = version - 1;
    if (index < 0 || index >= ALL_CODERS.length) throw new Error(`No coder for version: ${version}`);
    return ALL_CODERS[index];
}
/**
 *  Same as `coderFor` but returns `generic` coders without versioned types.
 */ function genericCoderFor(version) {
    return coderFor(version);
}
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ALL_CODERS: ALL_CODERS,
    coderFor: coderFor,
    genericCoderFor: genericCoderFor
});
const allVersions = [
    v1,
    v2
];

},{"ethers":"hdHML","@0xsequence/abi":"hbXMf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l6xLq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaults", ()=>defaults);
parcelHelpers.export(exports, "migration", ()=>index);
parcelHelpers.export(exports, "migrator", ()=>migrator);
parcelHelpers.export(exports, "version", ()=>version);
var _core = require("@0xsequence/core");
var _ethers = require("ethers");
var _abi = require("@0xsequence/abi");
function counterfactualVersion(address, firstImageHash, versions) {
    for(let i = 0; i < versions.length; i++){
        if ((0, _core.commons).context.addressOf(versions[i], firstImageHash) === address) return versions[i].version;
    }
    // if we can't find the version then either the address is invalid,
    // the version is not in VersionedContext, or the firstImageHash is not correct
    throw new Error("Could not find version for counterfactual address");
}
var version = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    counterfactualVersion: counterfactualVersion
});
class Migration_v1v2 {
    constructor(){
        this.version = 2;
        this.configCoder = (0, _core.v2).config.ConfigCoder;
        this.signatureCoder = (0, _core.v2).signature.SignatureCoder;
    }
    buildTransaction(address, contexts, newConfig) {
        // If new config is not v2, then we need to convert it to v2
        if (!(0, _core.v2).config.ConfigCoder.isWalletConfig(newConfig)) {
            const v2Config = (0, _core.v2).config.toWalletConfig({
                threshold: newConfig.threshold,
                members: newConfig.signers,
                checkpoint: 0
            });
            return this.buildTransaction(address, contexts, v2Config);
        }
        const context = contexts[2];
        const contract = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModule.abi);
        // WARNING: v1 wallets CAN NOT use v2 configurations so we ALWAYS need to update
        // both the implementation and the configuration at the same time
        const updateBundle = (0, _core.v2).config.ConfigCoder.update.buildTransaction(address, newConfig, context, "first");
        const tx = {
            entrypoint: address,
            nonce: (0, _core.commons).transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0),
            transactions: [
                {
                    to: address,
                    value: 0,
                    gasLimit: 0,
                    revertOnError: true,
                    delegateCall: false,
                    data: contract.encodeFunctionData(contract.getFunction("updateImplementation"), [
                        context.mainModuleUpgradable
                    ])
                },
                ...updateBundle.transactions
            ]
        };
        return {
            tx,
            fromVersion: this.version - 1,
            toVersion: this.version,
            toConfig: newConfig
        };
    }
    decodeTransaction(tx, contexts) {
        const address = tx.entrypoint;
        if (tx.transactions.length < 2) throw new Error("Invalid transaction bundle size");
        if (!tx.nonce || !(0, _core.commons).transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0).eq(tx.nonce)) throw new Error("Invalid transaction bundle nonce");
        if (tx.transactions[0].to !== address || tx.transactions[1].to !== address || tx.transactions[0].delegateCall || tx.transactions[1].delegateCall || !tx.transactions[0].revertOnError || !tx.transactions[1].revertOnError || tx.transactions[0].value && !(0, _ethers.ethers).constants.Zero.eq(tx.transactions[0].value) || tx.transactions[1].value && !(0, _ethers.ethers).constants.Zero.eq(tx.transactions[1].value) || tx.transactions[0].gasLimit && !(0, _ethers.ethers).constants.Zero.eq(tx.transactions[0].gasLimit) || tx.transactions[1].gasLimit && !(0, _ethers.ethers).constants.Zero.eq(tx.transactions[1].gasLimit)) throw new Error("Invalid transaction bundle format");
        const context = contexts[2];
        const contract = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModule.abi);
        const data1 = (0, _ethers.ethers).utils.hexlify(tx.transactions[0].data || []);
        const expectData1 = (0, _ethers.ethers).utils.hexlify(contract.encodeFunctionData(contract.getFunction("updateImplementation"), [
            context.mainModuleUpgradable
        ]));
        if (data1 !== expectData1) throw new Error("Invalid new implementation on transaction");
        const decoded2 = (0, _core.v2).config.ConfigCoder.update.decodeTransaction({
            entrypoint: address,
            transactions: [
                tx.transactions[1]
            ]
        });
        if (decoded2.address !== address) throw new Error("Invalid transaction bundle address");
        return decoded2;
    }
}
//                                 = uint160(keccak256("org.sequence.sdk.migration.space.nonce"))
const MIGRATION_NONCE_SPACE = "0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb";
const v1v2 = new Migration_v1v2();
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    MIGRATION_NONCE_SPACE: MIGRATION_NONCE_SPACE,
    v1v2: v1v2
});
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function validateMigrations(migrations) {
    for (const [version, migration] of Object.entries(migrations)){
        if (version !== String(migration.version - 1)) throw new Error(`Migration with key ${version} has version ${migration.version}, expected version to be key + 1`);
    }
}
class Migrator {
    constructor(tracker, migrations, contexts){
        this.tracker = tracker;
        this.migrations = migrations;
        this.contexts = contexts;
        validateMigrations(migrations);
    }
    lastMigration() {
        let last;
        for (const migration of Object.values(this.migrations))if (last === undefined || migration.version > last.version) last = migration;
        if (last === undefined) throw new Error("No migrations");
        return last;
    }
    async getAllMigratePresignedTransaction(args) {
        const { address, fromImageHash, fromVersion, chainId } = args;
        let fih = fromImageHash;
        let fversion = fromVersion;
        const versions = Object.values(this.contexts);
        const migs = [];
        for(let i = 1; i < versions.length; i++){
            const mig = await this.tracker.getMigration(address, fih, fversion, chainId);
            if (!mig) return {
                signedMigrations: migs,
                missing: true,
                lastImageHash: fih,
                lastVersion: fversion
            };
            migs.push(mig);
            const migration = this.migrations[fversion];
            if (!migration) throw new Error(`No migration found for version ${fversion}`);
            const decoded = migration.decodeTransaction(mig.tx, this.contexts);
            if (decoded.address !== address) throw new Error(`Migration transaction address does not match expected address`);
            fih = decoded.newImageHash;
            fversion += 1;
        }
        return {
            signedMigrations: migs,
            missing: false,
            lastImageHash: fih,
            lastVersion: fversion
        };
    }
    async signNextMigration(address, fromVersion, wallet, nextConfig) {
        const migration = this.migrations[fromVersion];
        if (!migration) return undefined;
        const unsignedMigration = migration.buildTransaction(address, this.contexts, nextConfig);
        const signedBundle = await wallet.signTransactionBundle(unsignedMigration.tx);
        return _extends({}, unsignedMigration, {
            tx: signedBundle
        });
    }
}
var migrator = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Migrator: Migrator
});
const DefaultMigrations = {
    1: v1v2
};
var defaults = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    DefaultMigrations: DefaultMigrations
});

},{"@0xsequence/core":"cIuGJ","ethers":"hdHML","@0xsequence/abi":"hbXMf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kiNl3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalRelayer", ()=>LocalRelayer);
parcelHelpers.export(exports, "ProviderRelayer", ()=>ProviderRelayer);
parcelHelpers.export(exports, "ProviderRelayerDefaults", ()=>ProviderRelayerDefaults);
parcelHelpers.export(exports, "RpcRelayer", ()=>RpcRelayer);
parcelHelpers.export(exports, "RpcRelayerProto", ()=>relayer_gen);
parcelHelpers.export(exports, "isLocalRelayerOptions", ()=>isLocalRelayerOptions);
parcelHelpers.export(exports, "isProviderRelayerOptions", ()=>isProviderRelayerOptions);
parcelHelpers.export(exports, "isRelayer", ()=>isRelayer);
parcelHelpers.export(exports, "isRpcRelayerOptions", ()=>isRpcRelayerOptions);
parcelHelpers.export(exports, "proto", ()=>relayer_gen);
var _ethers = require("ethers");
var _utils = require("@0xsequence/utils");
var _abi = require("@0xsequence/abi");
var _core = require("@0xsequence/core");
var global = arguments[3];
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const DEFAULT_GAS_LIMIT = (0, _ethers.ethers).BigNumber.from(800000);
const ProviderRelayerDefaults = {
    waitPollRate: 1000,
    deltaBlocksLog: 12,
    fromBlockLog: -1024
};
function isProviderRelayerOptions(obj) {
    return obj.provider !== undefined && (0, _ethers.providers).Provider.isProvider(obj.provider);
}
class ProviderRelayer {
    constructor(options){
        this.provider = void 0;
        this.waitPollRate = void 0;
        this.deltaBlocksLog = void 0;
        this.fromBlockLog = void 0;
        const opts = _extends({}, ProviderRelayerDefaults, options);
        this.provider = opts.provider;
    }
    async simulate(wallet, ...transactions) {
        var _this = this;
        return (await Promise.all(transactions.map(async function(tx) {
            // Respect gasLimit request of the transaction (as long as its not 0)
            if (tx.gasLimit && !(0, _ethers.ethers).BigNumber.from(tx.gasLimit || 0).eq((0, _ethers.ethers).constants.Zero)) return tx.gasLimit;
            // Fee can't be estimated locally for delegateCalls
            if (tx.delegateCall) return DEFAULT_GAS_LIMIT;
            // Fee can't be estimated for self-called if wallet hasn't been deployed
            if (tx.to === wallet && await _this.provider.getCode(wallet).then((code)=>(0, _ethers.ethers).utils.arrayify(code).length === 0)) return DEFAULT_GAS_LIMIT;
            if (!_this.provider) throw new Error("signer.provider is not set, but is required");
            // TODO: If the wallet address has been deployed, gas limits can be
            // estimated with more accurately by using self-calls with the batch transactions one by one
            return _this.provider.estimateGas({
                from: wallet,
                to: tx.to,
                data: tx.data,
                value: tx.value
            });
        }))).map((gasLimit)=>({
                executed: true,
                succeeded: true,
                gasUsed: (0, _ethers.ethers).BigNumber.from(gasLimit).toNumber(),
                gasLimit: (0, _ethers.ethers).BigNumber.from(gasLimit).toNumber()
            }));
    }
    async getNonce(address, space, blockTag) {
        if (!this.provider) throw new Error("provider is not set");
        if (await this.provider.getCode(address) === "0x") return 0;
        if (space === undefined) space = 0;
        const module = new (0, _ethers.ethers).Contract(address, (0, _abi.walletContracts).mainModule.abi, this.provider);
        const nonce = await module.readNonce(space, {
            blockTag: blockTag
        });
        return (0, _core.commons).transaction.encodeNonce(space, nonce);
    }
    async wait(metaTxnId, timeout, delay = this.waitPollRate, maxFails = 5) {
        var _this2 = this;
        if (typeof metaTxnId !== "string") metaTxnId = (0, _core.commons).transaction.intendedTransactionID(metaTxnId);
        let timedOut = false;
        const retry = async function retry(f, errorMessage) {
            let fails = 0;
            while(!timedOut){
                try {
                    return await f();
                } catch (error) {
                    fails++;
                    if (maxFails !== undefined && fails >= maxFails) {
                        (0, _utils.logger).error(`giving up after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ""}`, error);
                        throw error;
                    } else (0, _utils.logger).warn(`attempt #${fails} failed${errorMessage ? `: ${errorMessage}` : ""}`, error);
                }
                if (delay > 0) await new Promise((resolve)=>setTimeout(resolve, delay));
            }
            throw new Error(`timed out after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ""}`);
        };
        const waitReceipt = async function waitReceipt() {
            // Transactions can only get executed on nonce change
            // get all nonce changes and look for metaTxnIds in between logs
            let lastBlock = _this2.fromBlockLog;
            if (lastBlock < 0) {
                const block = await retry(()=>_this2.provider.getBlockNumber(), "unable to get latest block number");
                lastBlock = block + lastBlock;
            }
            if (typeof metaTxnId !== "string") throw new Error("impossible");
            const normalMetaTxnId = metaTxnId.replace("0x", "");
            while(!timedOut){
                const block = await retry(()=>_this2.provider.getBlockNumber(), "unable to get latest block number");
                const logs = await retry(()=>_this2.provider.getLogs({
                        fromBlock: Math.max(0, lastBlock - _this2.deltaBlocksLog),
                        toBlock: block,
                        // Nonce change event topic
                        topics: [
                            "0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881"
                        ]
                    }), `unable to get NonceChange logs for blocks ${Math.max(0, lastBlock - _this2.deltaBlocksLog)} to ${block}`);
                lastBlock = block;
                // Get receipts of all transactions
                const txs = await Promise.all(logs.map((l)=>retry(()=>_this2.provider.getTransactionReceipt(l.transactionHash), `unable to get receipt for transaction ${l.transactionHash}`)));
                // Find a transaction with a TxExecuted log
                const found = txs.find((tx)=>tx.logs.find((l)=>l.topics.length === 0 && l.data.replace("0x", "") === normalMetaTxnId || l.topics.length === 1 && // TxFailed event topic
                        l.topics[0] === "0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7" && l.data.length >= 64 && l.data.replace("0x", "").startsWith(normalMetaTxnId)));
                // If found return that
                if (found) return _extends({
                    receipt: found
                }, await retry(()=>_this2.provider.getTransaction(found.transactionHash), `unable to get transaction ${found.transactionHash}`));
                // Otherwise wait and try again
                if (!timedOut) await new Promise((r)=>setTimeout(r, delay));
            }
            throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);
        };
        if (timeout !== undefined) return Promise.race([
            waitReceipt(),
            new Promise((_, reject)=>setTimeout(()=>{
                    timedOut = true;
                    reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
                }, timeout))
        ]);
        else return waitReceipt();
    }
}
function isLocalRelayerOptions(obj) {
    return obj.signer !== undefined && (0, _ethers.Signer).isSigner(obj.signer);
}
class LocalRelayer extends ProviderRelayer {
    constructor(options){
        super((0, _ethers.Signer).isSigner(options) ? {
            provider: options.provider
        } : _extends({}, options, {
            provider: options.signer.provider
        }));
        this.signer = void 0;
        this.txnOptions = void 0;
        this.signer = (0, _ethers.Signer).isSigner(options) ? options : options.signer;
        if (!this.signer.provider) throw new Error("Signer must have a provider");
    }
    async getFeeOptions(_address, ..._transactions) {
        return {
            options: []
        };
    }
    async getFeeOptionsRaw(_entrypoint, _data, _options) {
        return {
            options: []
        };
    }
    async gasRefundOptions(address, ...transactions) {
        const { options } = await this.getFeeOptions(address, ...transactions);
        return options;
    }
    setTransactionOptions(transactionRequest) {
        this.txnOptions = transactionRequest;
    }
    async relay(signedTxs, quote, waitForReceipt = true) {
        if (quote !== undefined) (0, _utils.logger).warn(`LocalRelayer doesn't accept fee quotes`);
        const data = (0, _core.commons).transaction.encodeBundleExecData(signedTxs);
        // TODO: think about computing gas limit individually, summing together and passing across
        // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation
        // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))
        // txRequest.gasLimit = gasLimit
        const responsePromise = this.signer.sendTransaction(_extends({
            to: signedTxs.entrypoint,
            data
        }, this.txnOptions, {
            gasLimit: 9000000
        }));
        if (waitForReceipt) {
            const response = await responsePromise;
            response.receipt = await response.wait();
            return response;
        } else return responsePromise;
    }
}
/* eslint-disable */ // sequence-relayer v0.4.0 950b00c821b56110c64d947312b9dea3e197e207
// --
// Code generated by webrpc-gen@v0.12.x-dev with typescript@v0.10.0 generator. DO NOT EDIT.
//
// webrpc-gen -schema=relayer.ridl -target=typescript@v0.10.0 -client -out=./clients/relayer.gen.ts
// WebRPC description and code-gen version
const WebRPCVersion = "v1";
// Schema version of your RIDL schema
const WebRPCSchemaVersion = "v0.4.0";
// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = "950b00c821b56110c64d947312b9dea3e197e207";
//
// Types
//
let ETHTxnStatus = /*#__PURE__*/ function(ETHTxnStatus) {
    ETHTxnStatus["UNKNOWN"] = "UNKNOWN";
    ETHTxnStatus["DROPPED"] = "DROPPED";
    ETHTxnStatus["QUEUED"] = "QUEUED";
    ETHTxnStatus["SENT"] = "SENT";
    ETHTxnStatus["SUCCEEDED"] = "SUCCEEDED";
    ETHTxnStatus["PARTIALLY_FAILED"] = "PARTIALLY_FAILED";
    ETHTxnStatus["FAILED"] = "FAILED";
    return ETHTxnStatus;
}({});
let TransferType = /*#__PURE__*/ function(TransferType) {
    TransferType["SEND"] = "SEND";
    TransferType["RECEIVE"] = "RECEIVE";
    TransferType["BRIDGE_DEPOSIT"] = "BRIDGE_DEPOSIT";
    TransferType["BRIDGE_WITHDRAW"] = "BRIDGE_WITHDRAW";
    TransferType["BURN"] = "BURN";
    TransferType["UNKNOWN"] = "UNKNOWN";
    return TransferType;
}({});
let FeeTokenType = /*#__PURE__*/ function(FeeTokenType) {
    FeeTokenType["UNKNOWN"] = "UNKNOWN";
    FeeTokenType["ERC20_TOKEN"] = "ERC20_TOKEN";
    FeeTokenType["ERC1155_TOKEN"] = "ERC1155_TOKEN";
    return FeeTokenType;
}({});
let SortOrder = /*#__PURE__*/ function(SortOrder) {
    SortOrder["DESC"] = "DESC";
    SortOrder["ASC"] = "ASC";
    return SortOrder;
}({});
//
// Client
//
class Relayer {
    constructor(hostname, fetch){
        this.hostname = void 0;
        this.fetch = void 0;
        this.path = "/rpc/Relayer/";
        this.ping = (headers)=>{
            return this.fetch(this.url("Ping"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.version = (headers)=>{
            return this.fetch(this.url("Version"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        version: _data.version
                    };
                });
            });
        };
        this.runtimeStatus = (headers)=>{
            return this.fetch(this.url("RuntimeStatus"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.getSequenceContext = (headers)=>{
            return this.fetch(this.url("GetSequenceContext"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        data: _data.data
                    };
                });
            });
        };
        this.getChainID = (headers)=>{
            return this.fetch(this.url("GetChainID"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        chainID: _data.chainID
                    };
                });
            });
        };
        this.sendMetaTxn = (args, headers)=>{
            return this.fetch(this.url("SendMetaTxn"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        txnHash: _data.txnHash
                    };
                });
            });
        };
        this.getMetaTxnNonce = (args, headers)=>{
            return this.fetch(this.url("GetMetaTxnNonce"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        nonce: _data.nonce
                    };
                });
            });
        };
        this.getMetaTxnReceipt = (args, headers)=>{
            return this.fetch(this.url("GetMetaTxnReceipt"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        receipt: _data.receipt
                    };
                });
            });
        };
        this.simulate = (args, headers)=>{
            return this.fetch(this.url("Simulate"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        results: _data.results
                    };
                });
            });
        };
        this.updateMetaTxnGasLimits = (args, headers)=>{
            return this.fetch(this.url("UpdateMetaTxnGasLimits"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        payload: _data.payload
                    };
                });
            });
        };
        this.feeTokens = (headers)=>{
            return this.fetch(this.url("FeeTokens"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        isFeeRequired: _data.isFeeRequired,
                        tokens: _data.tokens
                    };
                });
            });
        };
        this.feeOptions = (args, headers)=>{
            return this.fetch(this.url("FeeOptions"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        options: _data.options,
                        quote: _data.quote
                    };
                });
            });
        };
        this.getMetaTxnNetworkFeeOptions = (args, headers)=>{
            return this.fetch(this.url("GetMetaTxnNetworkFeeOptions"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        options: _data.options
                    };
                });
            });
        };
        this.sentTransactions = (args, headers)=>{
            return this.fetch(this.url("SentTransactions"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        transactions: _data.transactions
                    };
                });
            });
        };
        this.pendingTransactions = (args, headers)=>{
            return this.fetch(this.url("PendingTransactions"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        transactions: _data.transactions
                    };
                });
            });
        };
        this.getGasTank = (args, headers)=>{
            return this.fetch(this.url("GetGasTank"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        gasTank: _data.gasTank
                    };
                });
            });
        };
        this.addGasTank = (args, headers)=>{
            return this.fetch(this.url("AddGasTank"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        gasTank: _data.gasTank
                    };
                });
            });
        };
        this.updateGasTank = (args, headers)=>{
            return this.fetch(this.url("UpdateGasTank"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        gasTank: _data.gasTank
                    };
                });
            });
        };
        this.getGasSponsor = (args, headers)=>{
            return this.fetch(this.url("GetGasSponsor"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        gasSponsor: _data.gasSponsor
                    };
                });
            });
        };
        this.listGasSponsors = (args, headers)=>{
            return this.fetch(this.url("ListGasSponsors"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        gasSponsors: _data.gasSponsors
                    };
                });
            });
        };
        this.addGasSponsor = (args, headers)=>{
            return this.fetch(this.url("AddGasSponsor"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        gasSponsor: _data.gasSponsor
                    };
                });
            });
        };
        this.updateGasSponsor = (args, headers)=>{
            return this.fetch(this.url("UpdateGasSponsor"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        gasSponsor: _data.gasSponsor
                    };
                });
            });
        };
        this.removeGasSponsor = (args, headers)=>{
            return this.fetch(this.url("RemoveGasSponsor"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.reportGasSponsorUsage = (args, headers)=>{
            return this.fetch(this.url("ReportGasSponsorUsage"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        gasSponsorUsage: _data.gasSponsorUsage
                    };
                });
            });
        };
        this.nextGasTankBalanceAdjustmentNonce = (args, headers)=>{
            return this.fetch(this.url("NextGasTankBalanceAdjustmentNonce"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        nonce: _data.nonce
                    };
                });
            });
        };
        this.adjustGasTankBalance = (args, headers)=>{
            return this.fetch(this.url("AdjustGasTankBalance"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        adjustment: _data.adjustment
                    };
                });
            });
        };
        this.getGasTankBalanceAdjustment = (args, headers)=>{
            return this.fetch(this.url("GetGasTankBalanceAdjustment"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        adjustment: _data.adjustment
                    };
                });
            });
        };
        this.listGasTankBalanceAdjustments = (args, headers)=>{
            return this.fetch(this.url("ListGasTankBalanceAdjustments"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        adjustments: _data.adjustments
                    };
                });
            });
        };
        this.hostname = hostname;
        this.fetch = (input, init)=>fetch(input, init);
    }
    url(name) {
        return this.hostname + this.path + name;
    }
}
const createHTTPRequest = (body = {}, headers = {})=>{
    return {
        method: "POST",
        headers: _extends({}, headers, {
            "Content-Type": "application/json"
        }),
        body: JSON.stringify(body || {})
    };
};
const buildResponse = (res)=>{
    return res.text().then((text)=>{
        let data;
        try {
            data = JSON.parse(text);
        } catch (err) {
            throw {
                code: "unknown",
                msg: `expecting JSON, got: ${text}`,
                status: res.status
            };
        }
        if (!res.ok) throw data; // webrpc error response
        return data;
    });
};
var relayer_gen = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    WebRPCVersion: WebRPCVersion,
    WebRPCSchemaVersion: WebRPCSchemaVersion,
    WebRPCSchemaHash: WebRPCSchemaHash,
    ETHTxnStatus: ETHTxnStatus,
    TransferType: TransferType,
    FeeTokenType: FeeTokenType,
    SortOrder: SortOrder,
    Relayer: Relayer
});
const FINAL_STATUSES = [
    ETHTxnStatus.DROPPED,
    ETHTxnStatus.SUCCEEDED,
    ETHTxnStatus.PARTIALLY_FAILED,
    ETHTxnStatus.FAILED
];
const FAILED_STATUSES = [
    ETHTxnStatus.DROPPED,
    ETHTxnStatus.PARTIALLY_FAILED,
    ETHTxnStatus.FAILED
];
function isRpcRelayerOptions(obj) {
    return obj.url !== undefined && typeof obj.url === "string" && obj.provider !== undefined && (0, _ethers.ethers).providers.Provider.isProvider(obj.provider);
}
const fetch = typeof global === "object" ? global.fetch : window.fetch;
// TODO: rename to SequenceRelayer
class RpcRelayer {
    constructor(options){
        this.options = options;
        this.service = void 0;
        this.provider = void 0;
        this._fetch = (input, init)=>{
            // automatically include jwt and access key auth header to requests
            // if its been set on the api client
            const headers = {};
            const { jwtAuth, projectAccessKey } = this.options;
            if (jwtAuth && jwtAuth.length > 0) headers["Authorization"] = `BEARER ${jwtAuth}`;
            if (projectAccessKey && projectAccessKey.length > 0) headers["X-Access-Key"] = projectAccessKey;
            // before the request is made
            init.headers = _extends({}, init.headers, headers);
            return fetch(input, init);
        };
        this.service = new Relayer(options.url, this._fetch);
        if ((0, _ethers.ethers).providers.Provider.isProvider(options.provider)) this.provider = options.provider;
        else {
            const { jwtAuth, projectAccessKey } = this.options;
            const providerConnectionInfo = (0, _utils.getEthersConnectionInfo)(options.provider.url, projectAccessKey, jwtAuth);
            this.provider = new (0, _ethers.ethers).providers.StaticJsonRpcProvider(providerConnectionInfo);
        }
    }
    async waitReceipt(metaTxnId, delay = 1000, maxFails = 5, isCancelled) {
        if (typeof metaTxnId !== "string") metaTxnId = (0, _core.commons).transaction.intendedTransactionID(metaTxnId);
        (0, _utils.logger).info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnId}`);
        let fails = 0;
        while(isCancelled === undefined || !isCancelled()){
            try {
                const { receipt } = await this.service.getMetaTxnReceipt({
                    metaTxID: metaTxnId
                });
                if (receipt && receipt.txnReceipt && receipt.txnReceipt !== "null" && FINAL_STATUSES.includes(receipt.status)) return {
                    receipt
                };
            } catch (e) {
                fails++;
                if (fails === maxFails) throw e;
            }
            if (isCancelled === undefined || !isCancelled()) await new Promise((resolve)=>setTimeout(resolve, delay));
        }
        throw new Error(`Cancelled waiting for transaction receipt ${metaTxnId}`);
    }
    async simulate(wallet, ...transactions) {
        const coder = (0, _ethers.ethers).utils.defaultAbiCoder;
        const encoded = coder.encode([
            (0, _core.commons).transaction.MetaTransactionsType
        ], [
            (0, _core.commons).transaction.sequenceTxAbiEncode(transactions)
        ]);
        return (await this.service.simulate({
            wallet,
            transactions: encoded
        })).results;
    }
    async getFeeOptions(address, ...transactions) {
        // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value
        // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically
        // with http cache response for this endpoint and service-worker.. lots of approaches
        const feeTokens = await this.service.feeTokens();
        if (feeTokens.isFeeRequired) {
            const symbols = feeTokens.tokens.map((token)=>token.symbol).join(", ");
            (0, _utils.logger).info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);
            const nonce = await this.getNonce(address);
            if (!this.provider) {
                (0, _utils.logger).warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);
                throw new Error("provider is not set");
            }
            const { options, quote } = await this.service.feeOptions({
                wallet: address,
                to: address,
                data: (0, _core.commons).transaction.encodeBundleExecData({
                    entrypoint: address,
                    transactions,
                    nonce
                })
            });
            (0, _utils.logger).info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`);
            return {
                options,
                quote: {
                    _tag: "FeeQuote",
                    _quote: quote
                }
            };
        } else {
            (0, _utils.logger).info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);
            return {
                options: []
            };
        }
    }
    async getFeeOptionsRaw(entrypoint, data, options) {
        const { options: feeOptions, quote } = await this.service.feeOptions({
            wallet: entrypoint,
            to: entrypoint,
            data: (0, _ethers.ethers).utils.hexlify(data),
            simulate: options == null ? void 0 : options.simulate
        });
        return {
            options: feeOptions,
            quote: {
                _tag: "FeeQuote",
                _quote: quote
            }
        };
    }
    async gasRefundOptions(address, ...transactions) {
        const { options } = await this.getFeeOptions(address, ...transactions);
        return options;
    }
    async getNonce(address, space) {
        (0, _utils.logger).info(`[rpc-relayer/getNonce] get nonce for wallet ${address} space: ${space}`);
        const encodedNonce = space !== undefined ? (0, _ethers.ethers).BigNumber.from(space).toHexString() : undefined;
        const resp = await this.service.getMetaTxnNonce({
            walletContractAddress: address,
            space: encodedNonce
        });
        const nonce = (0, _ethers.ethers).BigNumber.from(resp.nonce);
        const [decodedSpace, decodedNonce] = (0, _core.commons).transaction.decodeNonce(nonce);
        (0, _utils.logger).info(`[rpc-relayer/getNonce] got next nonce for wallet ${address} ${decodedNonce} space: ${decodedSpace}`);
        return nonce;
    }
    async relay(signedTxs, quote, waitForReceipt = true) {
        var _this = this;
        (0, _utils.logger).info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`);
        let typecheckedQuote;
        if (quote !== undefined) {
            if (typeof quote._quote === "string") typecheckedQuote = quote._quote;
            else (0, _utils.logger).warn("[rpc-relayer/relay] ignoring invalid fee quote");
        }
        if (!this.provider) {
            (0, _utils.logger).warn(`[rpc-relayer/relay] provider not set, failed relay`);
            throw new Error("provider is not set");
        }
        const data = (0, _core.commons).transaction.encodeBundleExecData(signedTxs);
        const metaTxn = await this.service.sendMetaTxn({
            call: {
                walletAddress: signedTxs.intent.wallet,
                contract: signedTxs.entrypoint,
                input: data
            },
            quote: typecheckedQuote
        });
        (0, _utils.logger).info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);
        if (waitForReceipt) return this.wait(signedTxs.intent.id);
        else {
            const response = {
                hash: signedTxs.intent.id,
                confirmations: 0,
                from: signedTxs.intent.wallet,
                wait: (_confirmations)=>Promise.reject(new Error("impossible"))
            };
            const wait = async function wait(confirmations) {
                var _waitResponse$receipt;
                if (!_this.provider) throw new Error("cannot wait for receipt, relayer has no provider set");
                const waitResponse = await _this.wait(signedTxs.intent.id);
                const transactionHash = (_waitResponse$receipt = waitResponse.receipt) == null ? void 0 : _waitResponse$receipt.transactionHash;
                if (!transactionHash) throw new Error("cannot wait for receipt, unknown native transaction hash");
                Object.assign(response, waitResponse);
                return _this.provider.waitForTransaction(transactionHash, confirmations);
            };
            response.wait = wait;
            return response;
        }
    }
    async wait(metaTxnId, timeout, delay = 1000, maxFails = 5) {
        var _this2 = this;
        let timedOut = false;
        const { receipt } = await (timeout !== undefined ? Promise.race([
            this.waitReceipt(metaTxnId, delay, maxFails, ()=>timedOut),
            new Promise((_, reject)=>setTimeout(()=>{
                    timedOut = true;
                    reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
                }, timeout))
        ]) : this.waitReceipt(metaTxnId, delay, maxFails));
        if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) throw new MetaTransactionResponseException(receipt);
        const txReceipt = JSON.parse(receipt.txnReceipt);
        return {
            blockHash: txReceipt.blockHash,
            blockNumber: (0, _ethers.ethers).BigNumber.from(txReceipt.blockNumber).toNumber(),
            confirmations: 1,
            from: typeof metaTxnId === "string" ? undefined : metaTxnId.intent.wallet,
            hash: txReceipt.transactionHash,
            raw: receipt.txnReceipt,
            receipt: txReceipt,
            // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
            wait: async function(confirmations) {
                return _this2.provider.waitForTransaction(txReceipt.transactionHash, confirmations);
            }
        };
    }
}
class MetaTransactionResponseException {
    constructor(receipt){
        this.receipt = receipt;
    }
}
// A fee quote is simply an opaque value that can be obtained via Relayer.getFeeOptions(), and
// returned back to the same relayer via Relayer.relay(). Fee quotes should be treated as an
// implementation detail of the relayer that produces them.
//
// This interface exists for type-safety purposes to protect against passing non-FeeQuotes to
// Relayer.relay(), or any other functions that call it indirectly (e.g. Account.sendTransaction).
function isRelayer(cand) {
    return typeof cand === "object" && typeof cand.simulate === "function" && typeof cand.getFeeOptions === "function" && typeof cand.gasRefundOptions === "function" && typeof cand.getNonce === "function" && typeof cand.relay === "function" && typeof cand.wait === "function";
}

},{"ethers":"hdHML","@0xsequence/utils":"7jY5X","@0xsequence/abi":"hbXMf","@0xsequence/core":"cIuGJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"qr7qv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidSigner", ()=>InvalidSigner);
parcelHelpers.export(exports, "NotEnoughSigners", ()=>NotEnoughSigners);
parcelHelpers.export(exports, "SequenceOrchestratorWrapper", ()=>SequenceOrchestratorWrapper);
parcelHelpers.export(exports, "Signer", ()=>Signer);
parcelHelpers.export(exports, "Wallet", ()=>Wallet);
parcelHelpers.export(exports, "findLatestLog", ()=>findLatestLog);
parcelHelpers.export(exports, "isSequenceSigner", ()=>isSequenceSigner);
parcelHelpers.export(exports, "resolveArrayProperties", ()=>resolveArrayProperties);
var _ethers = require("ethers");
var _core = require("@0xsequence/core");
var _signhub = require("@0xsequence/signhub");
var _utils = require("@0xsequence/utils");
var _abi = require("@0xsequence/abi");
// TODO: Move to account ?
class Signer extends (0, _ethers.Signer) {
    static isSequenceSigner(cand) {
        return isSequenceSigner(cand);
    }
}
function isSequenceSigner(signer) {
    const cand = signer;
    return cand && cand.updateConfig !== undefined && cand.publishConfig !== undefined && cand.getWalletConfig !== undefined;
}
// TODO: move to error.ts, along with others..
class InvalidSigner extends Error {
}
class NotEnoughSigners extends Error {
}
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
async function resolveArrayProperties(object) {
    if (Array.isArray(object)) // T must include array type
    return Promise.all(object.map((o)=>(0, _ethers.utils).resolveProperties(o)));
    return (0, _ethers.utils).resolveProperties(object);
}
async function findLatestLog(provider, filter) {
    const toBlock = filter.toBlock === "latest" ? await provider.getBlockNumber() : filter.toBlock;
    const fromBlock = filter.fromBlock;
    try {
        const logs = await provider.getLogs(_extends({}, filter, {
            toBlock: toBlock
        }));
        return logs.length === 0 ? undefined : logs[logs.length - 1];
    } catch (e) {
        // TODO Don't assume all errors are bad
        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);
        const nhalf = await findLatestLog(provider, _extends({}, filter, {
            fromBlock: pivot,
            toBlock: toBlock
        }));
        if (nhalf !== undefined) return nhalf;
        return findLatestLog(provider, _extends({}, filter, {
            fromBlock: fromBlock,
            toBlock: pivot
        }));
    }
}
const statusToSignatureParts = (status)=>{
    const parts = new Map();
    for (const signer of Object.keys(status.signers)){
        const value = status.signers[signer];
        if (value.state === (0, _signhub.SignerState).SIGNED) {
            const suffix = (0, _ethers.ethers).utils.arrayify(value.suffix);
            const suffixed = (0, _ethers.ethers).utils.solidityPack([
                "bytes",
                "bytes"
            ], [
                value.signature,
                suffix
            ]);
            parts.set(signer, {
                signature: suffixed,
                isDynamic: suffix.length !== 1 || suffix[0] !== 2
            });
        }
    }
    return parts;
};
/**
 * The wallet is the minimum interface to interact with a single Sequence wallet/contract.
 * it doesn't have any knowledge of any on-chain state, instead it relies solely on the information
 * provided by the user. This building block is used to create higher level abstractions.
 *
 * Wallet can also be used to create Sequence wallets, but it's not recommended to use it directly.
 */ class Wallet extends (0, _ethers.ethers).Signer {
    constructor(options){
        if ((0, _ethers.ethers).constants.Zero.eq(options.chainId) && !options.coders.signature.supportsNoChainId) throw new Error(`Sequence version ${options.config.version} doesn't support chainId 0`);
        super();
        this.context = void 0;
        this.config = void 0;
        this.address = void 0;
        this.chainId = void 0;
        this.provider = void 0;
        this.relayer = void 0;
        this.coders = void 0;
        this.orchestrator = void 0;
        this._reader = void 0;
        this.context = options.context;
        this.config = options.config;
        this.orchestrator = options.orchestrator;
        this.coders = options.coders;
        this.address = options.address;
        this.chainId = options.chainId;
        this.provider = options.provider;
        this.relayer = options.relayer;
        this._reader = options.reader;
    }
    static newWallet(options) {
        const address = (0, _core.commons).context.addressOf(options.context, options.coders.config.imageHashOf(options.config));
        return new Wallet(_extends({}, options, {
            address
        }));
    }
    reader() {
        if (this._reader) return this._reader;
        if (!this.provider) throw new Error("Wallet status provider requires a provider");
        return new (0, _core.commons).reader.OnChainReader(this.provider);
    }
    setConfig(config) {
        this.config = config;
    }
    setOrchestrator(orchestrator) {
        this.orchestrator = orchestrator;
    }
    setAddress(address) {
        this.address = address;
    }
    getSigners() {
        return this.orchestrator.getSigners();
    }
    async getAddress() {
        return this.address;
    }
    async decorateTransactions(bundle) {
        // Allow children to decorate
        const decorated = await this.orchestrator.decorateTransactions(bundle);
        if (await this.reader().isDeployed(this.address)) // Deployed - No decorating at this level
        return decorated;
        const transactions = [
            {
                to: decorated.entrypoint,
                data: (0, _core.commons).transaction.encodeBundleExecData(decorated),
                revertOnError: true
            }
        ];
        // Add deployment tx
        const deployTx = await this.buildDeployTransaction();
        if (deployTx) transactions.unshift(...deployTx.transactions);
        // TODO: If entrypoint is guestModule we can flatten the bundle
        // and avoid calling guestModule twice
        return {
            entrypoint: this.context.guestModule,
            chainId: this.chainId,
            intent: decorated.intent,
            transactions
        };
    }
    async buildDeployTransaction(metadata) {
        if (metadata != null && metadata.ignoreDeployed && await this.reader().isDeployed(this.address)) return;
        const imageHash = this.coders.config.imageHashOf(this.config);
        if ((0, _core.commons).context.addressOf(this.context, imageHash) !== this.address) throw new Error(`First address of config ${imageHash} doesn't match wallet address ${this.address}`);
        const bundle = Wallet.buildDeployTransaction(this.context, imageHash);
        if (metadata != null && metadata.includeChildren) {
            const childBundle = await this.orchestrator.buildDeployTransaction(metadata);
            if (childBundle) // Deploy children first
            bundle.transactions = childBundle.transactions.concat(bundle.transactions);
        }
        return bundle;
    }
    async deploy(metadata) {
        const deployTx = await this.buildDeployTransaction(metadata);
        if (deployTx === undefined) // Already deployed
        return;
        if (!this.relayer) throw new Error("Wallet deploy requires a relayer");
        return this.relayer.relay(_extends({}, deployTx, {
            chainId: this.chainId,
            intent: {
                id: (0, _ethers.ethers).utils.hexlify((0, _ethers.ethers).utils.randomBytes(32)),
                wallet: this.address
            }
        }));
    }
    static buildDeployTransaction(context, imageHash) {
        const factoryInterface = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).factory.abi);
        return {
            entrypoint: context.guestModule,
            transactions: [
                {
                    to: context.factory,
                    data: factoryInterface.encodeFunctionData(factoryInterface.getFunction("deploy"), [
                        context.mainModule,
                        imageHash
                    ]),
                    gasLimit: 100000,
                    delegateCall: false,
                    revertOnError: true,
                    value: 0
                }
            ]
        };
    }
    async buildUpdateConfigurationTransaction(config) {
        if (this.coders.config.update.isKindUsed) {
            const implementation = await this.reader().implementation(this.address);
            const isLaterUpdate = implementation && implementation === this.context.mainModuleUpgradable;
            return this.coders.config.update.buildTransaction(this.address, config, this.context, isLaterUpdate ? "later" : "first");
        }
        return this.coders.config.update.buildTransaction(this.address, config, this.context);
    }
    async getNonce(space = 0) {
        const nonce = await this.reader().nonce(this.address, space);
        if (nonce === undefined) throw new Error("Unable to determine nonce");
        return nonce;
    }
    async signDigest(digest, metadata) {
        // The subdigest may be statically defined on the configuration
        // in that case we just encode the proof, no need to sign anything
        const subdigest = (0, _utils.subDigestOf)(this.address, this.chainId, digest);
        if (this.coders.config.hasSubdigest(this.config, subdigest)) return this.coders.signature.encodeSigners(this.config, new Map(), [
            subdigest
        ], this.chainId).encoded;
        // We build the metadata object, this contains additional information
        // that may be needed to sign the digest (by the other signers, or by the guard)
        const childMetadata = _extends({}, metadata, {
            // Keep other metadata fields
            digest,
            chainId: this.chainId,
            address: this.address,
            config: this.config
        });
        // We ask the orchestrator to sign the digest, as soon as we have enough signature parts
        // to reach the threshold we returns true, that means the orchestrator will stop asking
        // and we can encode the final signature
        const subdigestBytes = (0, _ethers.ethers).utils.arrayify(subdigest);
        const signature = await this.orchestrator.signMessage({
            candidates: this.coders.config.signersOf(this.config).map((s)=>s.address),
            message: subdigestBytes,
            metadata: childMetadata,
            callback: (status, onNewMetadata)=>{
                const parts = statusToSignatureParts(status);
                const newMetadata = _extends({}, childMetadata, {
                    parts
                });
                onNewMetadata(newMetadata);
                return this.coders.signature.hasEnoughSigningPower(this.config, parts);
            }
        });
        const parts = statusToSignatureParts(signature);
        return this.coders.signature.encodeSigners(this.config, parts, [], this.chainId).encoded;
    }
    signMessage(message) {
        return this.signDigest((0, _ethers.ethers).utils.keccak256(message), {
            message
        });
    }
    signTransactionBundle(bundle) {
        if (bundle.entrypoint !== this.address) throw new Error(`Invalid entrypoint: ${bundle.entrypoint} !== ${this.address}`);
        return this.signTransactions(bundle.transactions, bundle.nonce);
    }
    async fetchNonceOrSpace(nonce) {
        let spaceValue;
        if (nonce && nonce.space !== undefined) // specified nonce "space"
        spaceValue = (0, _ethers.ethers).BigNumber.from(nonce.space);
        else if (nonce === undefined) // default is random, aka parallel
        return this.randomNonce();
        else if (nonce && nonce.serial === true) // next nonce determined from the chain
        spaceValue = 0;
        else // specific nonce is used
        return nonce;
        const resultNonce = await this.reader().nonce(this.address, spaceValue);
        if (resultNonce === undefined) throw new Error("Unable to determine nonce");
        return (0, _core.commons).transaction.encodeNonce(spaceValue, resultNonce);
    }
    // Generate nonce with random space
    randomNonce() {
        const randomNonceSpace = (0, _ethers.ethers).BigNumber.from((0, _ethers.ethers).utils.hexlify((0, _ethers.ethers).utils.randomBytes(12)));
        const randomNonce = (0, _core.commons).transaction.encodeNonce(randomNonceSpace, 0);
        return randomNonce;
    }
    async signTransactions(txs, nonce, metadata) {
        const transaction = await resolveArrayProperties(txs);
        const transactions = (0, _core.commons).transaction.fromTransactionish(this.address, transaction);
        // NOTICE: If the `transactions` list is empty, then we add a dummy transaction
        // otherwise the `TxExecuted` event will not be emitted, and we won't be able to
        // find the transaction hash
        if (transactions.length === 0) transactions.push({
            to: this.address,
            data: "0x",
            value: 0,
            gasLimit: 0,
            delegateCall: false,
            revertOnError: true
        });
        const defaultedNonce = await this.fetchNonceOrSpace(nonce);
        const digest = (0, _core.commons).transaction.digestOfTransactions(defaultedNonce, transactions);
        const meta = _extends({
            digest,
            transactions
        }, metadata);
        const signature = await this.signDigest(digest, meta);
        return {
            intent: {
                // Maybe is better if signDigest returns the subdigest directly
                id: (0, _utils.subDigestOf)(this.address, this.chainId, digest),
                wallet: this.address
            },
            chainId: this.chainId,
            transactions,
            entrypoint: this.address,
            nonce: defaultedNonce,
            signature
        };
    }
    async sendSignedTransaction(signedBundle, quote) {
        if (!this.relayer) throw new Error("Wallet sendTransaction requires a relayer");
        return this.relayer.relay(signedBundle, quote);
    }
    // sendTransaction will dispatch the transaction to the relayer for submission to the network.
    // This method is able to send transactions in serial or parallel (default). You can specify
    // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).
    //
    // By default, nonces are generated randomly and assigned so transactioned can be executed
    // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.
    async sendTransaction(txs, options) {
        let nonce;
        if ((options == null ? void 0 : options.nonce) !== undefined) // specific nonce is used
        nonce = options.nonce;
        else if (options != null && options.serial) // next nonce on wallet is used and detected on-chain
        nonce = 0;
        else // default is random, aka parallel
        nonce = this.randomNonce();
        const signed = await this.signTransactions(txs, nonce);
        const decorated = await this.decorateTransactions(signed);
        return this.sendSignedTransaction(decorated, options == null ? void 0 : options.quote);
    }
    async fillGasLimits(txs) {
        const transaction = await resolveArrayProperties(txs);
        const transactions = (0, _core.commons).transaction.fromTransactionish(this.address, transaction);
        const relayer = this.relayer;
        if (!relayer) throw new Error("Wallet fillGasLimits requires a relayer");
        const simulations = await relayer.simulate(this.address, ...transactions);
        return transactions.map((tx, i)=>{
            const gasLimit = tx.gasLimit ? (0, _ethers.ethers).BigNumber.from(tx.gasLimit).toNumber() : simulations[i].gasLimit;
            return _extends({}, tx, simulations[i], {
                gasLimit
            });
        });
    }
    connect(provider, relayer) {
        this.provider = provider;
        this.relayer = relayer;
        return this;
    }
    signTransaction(transaction) {
        throw new Error("Method not implemented.");
    }
}
// Implements a wrapper for using Sequence wallets as nested signers
// in the signhub orchestrator. It only works for nested signatures.
class SequenceOrchestratorWrapper {
    constructor(wallet){
        this.wallet = wallet;
    }
    async getAddress() {
        return this.wallet.address;
    }
    async buildDeployTransaction(metadata) {
        return this.wallet.buildDeployTransaction(metadata);
    }
    async predecorateSignedTransactions(_metadata) {
        // Wallets do not predecorate as they have no off chain knowledge
        return [];
    }
    async decorateTransactions(bundle, _metadata) {
        return this.wallet.decorateTransactions(bundle);
    }
    sign(message, metadata) {
        if (!(0, _core.commons).isWalletSignRequestMetadata(metadata)) throw new Error("SequenceOrchestratorWrapper only supports nested Sequence signatures");
        // For Sequence nested signatures we must use `signDigest` and not `signMessage`
        // otherwise the wallet will hash the digest and the signature will be invalid.
        return this.wallet.signDigest(message, {
            nested: metadata
        });
    }
    notifyStatusChange(_i, _s, _m) {}
    suffix() {
        return [
            3
        ];
    }
}

},{"ethers":"hdHML","@0xsequence/core":"cIuGJ","@0xsequence/signhub":"jyR3Z","@0xsequence/utils":"7jY5X","@0xsequence/abi":"hbXMf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jyR3Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Orchestrator", ()=>Orchestrator);
parcelHelpers.export(exports, "SignerState", ()=>SignerState);
parcelHelpers.export(exports, "isSignerStatusPending", ()=>isSignerStatusPending);
parcelHelpers.export(exports, "signers", ()=>index);
var _ethers = require("ethers");
function isSapientSigner(signer) {
    return signer.getAddress !== undefined && signer.buildDeployTransaction !== undefined && signer.predecorateSignedTransactions !== undefined && signer.decorateTransactions !== undefined && signer.sign !== undefined && signer.notifyStatusChange !== undefined;
}
class SignerWrapper {
    constructor(signer, eoa = true){
        this.signer = signer;
        this.eoa = eoa;
    }
    getAddress() {
        return this.signer.getAddress();
    }
    async buildDeployTransaction(_metadata) {
        // Wrapped signers don't require deployment
        return;
    }
    async predecorateSignedTransactions(_metadata) {
        return [];
    }
    async decorateTransactions(bundle, _metadata) {
        return bundle;
    }
    sign(message, metadata) {
        return this.signer.signMessage(message);
    }
    notifyStatusChange(_i, _s, _m) {}
    suffix() {
        return [
            2
        ];
    }
}
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    isSapientSigner: isSapientSigner,
    SignerWrapper: SignerWrapper
});
let SignerState = /*#__PURE__*/ function(SignerState) {
    SignerState[SignerState["INITIAL"] = 0] = "INITIAL";
    SignerState[SignerState["SIGNING"] = 1] = "SIGNING";
    SignerState[SignerState["SIGNED"] = 2] = "SIGNED";
    SignerState[SignerState["ERROR"] = 3] = "ERROR";
    return SignerState;
}({});
function isSignerStatusPending(status) {
    return status === undefined || status.state === SignerState.INITIAL || status.state === SignerState.SIGNING;
}
/**
 * Orchestrates actions of collective signers.
 * This includes the signing of a single digests and transactions by multiple signers.
 * It can provide internal visibility of the signing process, and it also
 * provides the internal signers with additional information about the
 * message being signed. Transaction decoration can be used to ensure on-chain state
 * is correctly managed during the signing process.
 */ class Orchestrator {
    constructor(signers, tag = Orchestrator.randomTag()){
        this.tag = tag;
        this.observers = [];
        this.signers = [];
        this.count = 0;
        this.setSigners(signers);
    }
    static randomTag() {
        return `default-${(0, _ethers.ethers).utils.hexlify((0, _ethers.ethers).utils.randomBytes(8)).slice(2)}`;
    }
    pullId() {
        return `${this.tag}-${this.count++}`;
    }
    setSigners(signers) {
        this.signers = signers.map((s)=>isSapientSigner(s) ? s : new SignerWrapper(s));
    }
    async getSigners() {
        return Promise.all(this.signers.map(async function(s) {
            return s.getAddress();
        }));
    }
    subscribe(observer) {
        this.observers.push(observer);
        return ()=>{
            this.observers = this.observers.filter((o)=>o !== observer);
        };
    }
    async notifyObservers(id, status, metadata) {
        await Promise.all([
            ...this.signers.map(async function(signer) {
                return signer.notifyStatusChange(id, status, metadata);
            }),
            ...this.observers.map(async function(observer) {
                return observer(status, metadata);
            })
        ]);
    }
    async buildDeployTransaction(metadata) {
        let bundle;
        for (const signer of this.signers){
            const newBundle = await signer.buildDeployTransaction(metadata);
            if (bundle === undefined) // Use first bundle as base
            bundle = newBundle;
            else if (newBundle != null && newBundle.transactions) // Combine deploy transactions
            bundle.transactions = newBundle.transactions.concat(bundle.transactions);
        }
        return bundle;
    }
    async predecorateSignedTransactions(metadata) {
        const output = [];
        for (const signer of this.signers)output.push(...await signer.predecorateSignedTransactions(metadata != null ? metadata : {}));
        return output;
    }
    async decorateTransactions(bundle, metadata) {
        for (const signer of this.signers)bundle = await signer.decorateTransactions(bundle, metadata != null ? metadata : {});
        return bundle;
    }
    signMessage(args) {
        var _this = this;
        const id = this.pullId();
        return new Promise(async function(resolve) {
            const { message, metadata, callback, candidates } = args;
            const status = {
                ended: false,
                message,
                signers: {}
            };
            let lastMetadata = metadata != null ? metadata : {};
            const onNewMetadata = (newMetadata)=>{
                lastMetadata = newMetadata;
                _this.notifyObservers(id, status, lastMetadata);
            };
            const onStatusUpdate = ()=>{
                try {
                    _this.notifyObservers(id, status, lastMetadata);
                    const pending = Object.entries(status.signers).filter(([_, s])=>isSignerStatusPending(s));
                    if (callback && callback(status, onNewMetadata) || pending.length === 0) {
                        status.ended = true;
                        resolve(status);
                        _this.notifyObservers(id, status, lastMetadata);
                        return;
                    }
                } catch (e) {
                    console.error("Error while notifying observers", e);
                }
            };
            // we only call signers that are found in `candidates`
            // if `candidates` is undefined, we call all signers
            let signers = _this.signers;
            if (candidates) {
                const addresses = await Promise.all(_this.signers.map(async function(s) {
                    return s.getAddress();
                }));
                signers = _this.signers.filter((_, i)=>candidates.includes(addresses[i]));
            }
            // build callbacks object
            const accepted = await Promise.allSettled(signers.map(async function(s) {
                const saddr = await s.getAddress();
                status.signers[saddr] = {
                    state: SignerState.SIGNING,
                    request: s.sign(message, metadata != null ? metadata : {}).then((signature)=>{
                        const suffix = s.suffix();
                        status.signers[saddr] = {
                            state: SignerState.SIGNED,
                            signature,
                            suffix
                        };
                        onStatusUpdate();
                        return signature;
                    }).catch((error)=>{
                        status.signers[saddr] = {
                            state: SignerState.ERROR,
                            error
                        };
                        onStatusUpdate();
                        throw error;
                    })
                };
            }));
            for(let i = 0; i < accepted.length; i++){
                const signer = _this.signers[i];
                const promise = accepted[i];
                if (promise.status === "rejected") {
                    const address = await signer.getAddress();
                    console.warn(`signer ${address} rejected the request: ${promise.reason}`);
                    status.signers[address] = {
                        state: SignerState.ERROR,
                        error: new Error(`signer ${address} rejected the request: ${promise.reason}`)
                    };
                }
            }
            onStatusUpdate();
        });
    }
}

},{"ethers":"hdHML","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0cuA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContractType", ()=>ContractType);
parcelHelpers.export(exports, "EventLogDataType", ()=>EventLogDataType);
parcelHelpers.export(exports, "EventLogType", ()=>EventLogType);
parcelHelpers.export(exports, "Indexer", ()=>Indexer);
parcelHelpers.export(exports, "SequenceIndexer", ()=>SequenceIndexer);
parcelHelpers.export(exports, "SortOrder", ()=>SortOrder);
parcelHelpers.export(exports, "TransactionStatus", ()=>TransactionStatus);
parcelHelpers.export(exports, "TransactionType", ()=>TransactionType);
parcelHelpers.export(exports, "TxnTransferType", ()=>TxnTransferType);
parcelHelpers.export(exports, "WebRPCSchemaHash", ()=>WebRPCSchemaHash);
parcelHelpers.export(exports, "WebRPCSchemaVersion", ()=>WebRPCSchemaVersion);
parcelHelpers.export(exports, "WebRPCVersion", ()=>WebRPCVersion);
var global = arguments[3];
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
/* eslint-disable */ // sequence-indexer v0.4.0 b53b368f85445da25796f8cc90459c61425c13f4
// --
// Code generated by webrpc-gen@v0.12.x-dev with typescript@v0.10.0 generator. DO NOT EDIT.
//
// webrpc-gen -schema=indexer.ridl -target=typescript@v0.10.0 -client -out=./clients/indexer.gen.ts
// WebRPC description and code-gen version
const WebRPCVersion = "v1";
// Schema version of your RIDL schema
const WebRPCSchemaVersion = "v0.4.0";
// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = "b53b368f85445da25796f8cc90459c61425c13f4";
//
// Types
//
let ContractType = /*#__PURE__*/ function(ContractType) {
    ContractType["UNKNOWN"] = "UNKNOWN";
    ContractType["ERC20"] = "ERC20";
    ContractType["ERC721"] = "ERC721";
    ContractType["ERC1155"] = "ERC1155";
    ContractType["SEQUENCE_WALLET"] = "SEQUENCE_WALLET";
    ContractType["ERC20_BRIDGE"] = "ERC20_BRIDGE";
    ContractType["ERC721_BRIDGE"] = "ERC721_BRIDGE";
    ContractType["ERC1155_BRIDGE"] = "ERC1155_BRIDGE";
    return ContractType;
}({});
let EventLogType = /*#__PURE__*/ function(EventLogType) {
    EventLogType["UNKNOWN"] = "UNKNOWN";
    EventLogType["BLOCK_ADDED"] = "BLOCK_ADDED";
    EventLogType["BLOCK_REMOVED"] = "BLOCK_REMOVED";
    return EventLogType;
}({});
let EventLogDataType = /*#__PURE__*/ function(EventLogDataType) {
    EventLogDataType["UNKNOWN"] = "UNKNOWN";
    EventLogDataType["TOKEN_TRANSFER"] = "TOKEN_TRANSFER";
    EventLogDataType["NATIVE_TOKEN_TRANSFER"] = "NATIVE_TOKEN_TRANSFER";
    EventLogDataType["SEQUENCE_TXN"] = "SEQUENCE_TXN";
    return EventLogDataType;
}({});
let TxnTransferType = /*#__PURE__*/ function(TxnTransferType) {
    TxnTransferType["UNKNOWN"] = "UNKNOWN";
    TxnTransferType["SEND"] = "SEND";
    TxnTransferType["RECEIVE"] = "RECEIVE";
    return TxnTransferType;
}({});
let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {
    TransactionStatus["FAILED"] = "FAILED";
    TransactionStatus["SUCCESSFUL"] = "SUCCESSFUL";
    return TransactionStatus;
}({});
let TransactionType = /*#__PURE__*/ function(TransactionType) {
    TransactionType["LegacyTxnType"] = "LegacyTxnType";
    TransactionType["AccessListTxnType"] = "AccessListTxnType";
    TransactionType["DynamicFeeTxnType"] = "DynamicFeeTxnType";
    return TransactionType;
}({});
let SortOrder = /*#__PURE__*/ function(SortOrder) {
    SortOrder["DESC"] = "DESC";
    SortOrder["ASC"] = "ASC";
    return SortOrder;
}({});
//
// Client
//
class Indexer {
    constructor(hostname, fetch){
        this.hostname = void 0;
        this.fetch = void 0;
        this.path = "/rpc/Indexer/";
        this.ping = (headers)=>{
            return this.fetch(this.url("Ping"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.version = (headers)=>{
            return this.fetch(this.url("Version"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        version: _data.version
                    };
                });
            });
        };
        this.runtimeStatus = (headers)=>{
            return this.fetch(this.url("RuntimeStatus"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.getChainID = (headers)=>{
            return this.fetch(this.url("GetChainID"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        chainID: _data.chainID
                    };
                });
            });
        };
        this.getEtherBalance = (args, headers)=>{
            return this.fetch(this.url("GetEtherBalance"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        balance: _data.balance
                    };
                });
            });
        };
        this.getTokenBalances = (args, headers)=>{
            return this.fetch(this.url("GetTokenBalances"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        balances: _data.balances
                    };
                });
            });
        };
        this.getTokenSupplies = (args, headers)=>{
            return this.fetch(this.url("GetTokenSupplies"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        contractType: _data.contractType,
                        tokenIDs: _data.tokenIDs
                    };
                });
            });
        };
        this.getTokenSuppliesMap = (args, headers)=>{
            return this.fetch(this.url("GetTokenSuppliesMap"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        supplies: _data.supplies
                    };
                });
            });
        };
        this.getBalanceUpdates = (args, headers)=>{
            return this.fetch(this.url("GetBalanceUpdates"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        balances: _data.balances
                    };
                });
            });
        };
        this.getTransactionHistory = (args, headers)=>{
            return this.fetch(this.url("GetTransactionHistory"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        transactions: _data.transactions
                    };
                });
            });
        };
        this.syncBalance = (args, headers)=>{
            return this.fetch(this.url("SyncBalance"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.fetchTransactionReceipt = (args, headers)=>{
            return this.fetch(this.url("FetchTransactionReceipt"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        receipt: _data.receipt
                    };
                });
            });
        };
        this.fetchTransactionReceiptWithFilter = (args, headers)=>{
            return this.fetch(this.url("FetchTransactionReceiptWithFilter"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        receipt: _data.receipt
                    };
                });
            });
        };
        this.getAllWebhookListeners = (args, headers)=>{
            return this.fetch(this.url("GetAllWebhookListeners"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        listeners: _data.listeners
                    };
                });
            });
        };
        this.getWebhookListener = (args, headers)=>{
            return this.fetch(this.url("GetWebhookListener"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        listener: _data.listener
                    };
                });
            });
        };
        this.addWebhookListener = (args, headers)=>{
            return this.fetch(this.url("AddWebhookListener"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status,
                        listener: _data.listener
                    };
                });
            });
        };
        this.updateWebhookListener = (args, headers)=>{
            return this.fetch(this.url("UpdateWebhookListener"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.removeWebhookListener = (args, headers)=>{
            return this.fetch(this.url("RemoveWebhookListener"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.hostname = hostname;
        this.fetch = (input, init)=>fetch(input, init);
    }
    url(name) {
        return this.hostname + this.path + name;
    }
}
const createHTTPRequest = (body = {}, headers = {})=>{
    return {
        method: "POST",
        headers: _extends({}, headers, {
            "Content-Type": "application/json"
        }),
        body: JSON.stringify(body || {})
    };
};
const buildResponse = (res)=>{
    return res.text().then((text)=>{
        let data;
        try {
            data = JSON.parse(text);
        } catch (err) {
            throw {
                code: "unknown",
                msg: `expecting JSON, got: ${text}`,
                status: res.status
            };
        }
        if (!res.ok) throw data; // webrpc error response
        return data;
    });
};
const fetch = typeof global === "object" ? global.fetch : window.fetch;
class SequenceIndexer extends Indexer {
    constructor(hostname, projectAccessKey, jwtAuth){
        super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch);
        this.projectAccessKey = projectAccessKey;
        this.jwtAuth = jwtAuth;
        this._fetch = (input, init)=>{
            // automatically include jwt and access key auth header to requests
            // if its been set on the api client
            const headers = {};
            const jwtAuth = this.jwtAuth;
            const projectAccessKey = this.projectAccessKey;
            if (jwtAuth && jwtAuth.length > 0) headers["Authorization"] = `BEARER ${jwtAuth}`;
            if (projectAccessKey && projectAccessKey.length > 0) headers["X-Access-Key"] = projectAccessKey;
            // before the request is made
            init.headers = _extends({}, init.headers, headers);
            return fetch(input, init);
        };
        this.fetch = this._fetch;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2CrG1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContractType", ()=>ContractType);
parcelHelpers.export(exports, "Metadata", ()=>Metadata);
parcelHelpers.export(exports, "PropertyType", ()=>PropertyType);
parcelHelpers.export(exports, "SequenceMetadata", ()=>SequenceMetadata);
parcelHelpers.export(exports, "SortOrder", ()=>SortOrder);
parcelHelpers.export(exports, "SwapType", ()=>SwapType);
parcelHelpers.export(exports, "WebRPCSchemaHash", ()=>WebRPCSchemaHash);
parcelHelpers.export(exports, "WebRPCSchemaVersion", ()=>WebRPCSchemaVersion);
parcelHelpers.export(exports, "WebRPCVersion", ()=>WebRPCVersion);
var global = arguments[3];
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
/* eslint-disable */ // sequence-metadata v0.4.0 ef61b3481a4dd4aa5b6a283701d4c15001552e0e
// --
// Code generated by webrpc-gen@v0.12.x-dev with typescript@v0.10.0 generator. DO NOT EDIT.
//
// webrpc-gen -schema=metadata.ridl -target=typescript@v0.10.0 -client -out=./clients/metadata.gen.ts
// WebRPC description and code-gen version
const WebRPCVersion = "v1";
// Schema version of your RIDL schema
const WebRPCSchemaVersion = "v0.4.0";
// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = "ef61b3481a4dd4aa5b6a283701d4c15001552e0e";
//
// Types
//
let ContractType = /*#__PURE__*/ function(ContractType) {
    ContractType["UNKNOWN"] = "UNKNOWN";
    ContractType["ERC20"] = "ERC20";
    ContractType["ERC721"] = "ERC721";
    ContractType["ERC1155"] = "ERC1155";
    return ContractType;
}({});
let PropertyType = /*#__PURE__*/ function(PropertyType) {
    PropertyType["INT"] = "INT";
    PropertyType["STRING"] = "STRING";
    PropertyType["ARRAY"] = "ARRAY";
    PropertyType["GENERIC"] = "GENERIC";
    return PropertyType;
}({});
let SwapType = /*#__PURE__*/ function(SwapType) {
    SwapType["UNKNOWN"] = "UNKNOWN";
    SwapType["BUY"] = "BUY";
    SwapType["SELL"] = "SELL";
    return SwapType;
}({});
let SortOrder = /*#__PURE__*/ function(SortOrder) {
    SortOrder["DESC"] = "DESC";
    SortOrder["ASC"] = "ASC";
    return SortOrder;
}({});
//
// Client
//
class Metadata {
    constructor(hostname, fetch){
        this.hostname = void 0;
        this.fetch = void 0;
        this.path = "/rpc/Metadata/";
        this.ping = (headers)=>{
            return this.fetch(this.url("Ping"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.version = (headers)=>{
            return this.fetch(this.url("Version"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        version: _data.version
                    };
                });
            });
        };
        this.runtimeStatus = (headers)=>{
            return this.fetch(this.url("RuntimeStatus"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.getTokenMetadata = (args, headers)=>{
            return this.fetch(this.url("GetTokenMetadata"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        tokenMetadata: _data.tokenMetadata
                    };
                });
            });
        };
        this.refreshTokenMetadata = (args, headers)=>{
            return this.fetch(this.url("RefreshTokenMetadata"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.getTokenMetadataBatch = (args, headers)=>{
            return this.fetch(this.url("GetTokenMetadataBatch"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        contractTokenMetadata: _data.contractTokenMetadata
                    };
                });
            });
        };
        this.searchTokenMetadata = (args, headers)=>{
            return this.fetch(this.url("SearchTokenMetadata"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        tokenMetadata: _data.tokenMetadata
                    };
                });
            });
        };
        this.searchTokenIDs = (args, headers)=>{
            return this.fetch(this.url("SearchTokenIDs"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        page: _data.page,
                        tokenIds: _data.tokenIds
                    };
                });
            });
        };
        this.tokenCollectionFilters = (args, headers)=>{
            return this.fetch(this.url("TokenCollectionFilters"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        filters: _data.filters
                    };
                });
            });
        };
        this.getContractInfo = (args, headers)=>{
            return this.fetch(this.url("GetContractInfo"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        contractInfo: _data.contractInfo
                    };
                });
            });
        };
        this.getContractInfoBatch = (args, headers)=>{
            return this.fetch(this.url("GetContractInfoBatch"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        contractInfoMap: _data.contractInfoMap
                    };
                });
            });
        };
        this.searchContractInfo = (args, headers)=>{
            return this.fetch(this.url("SearchContractInfo"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        contractInfoList: _data.contractInfoList
                    };
                });
            });
        };
        this.searchContractInfoBatch = (args, headers)=>{
            return this.fetch(this.url("SearchContractInfoBatch"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        contractInfoByChain: _data.contractInfoByChain
                    };
                });
            });
        };
        this.searchMetadata = (args, headers)=>{
            return this.fetch(this.url("SearchMetadata"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        tokenMetadata: _data.tokenMetadata,
                        contractInfo: _data.contractInfo
                    };
                });
            });
        };
        this.projectSetTokenMetadata = (args, headers)=>{
            return this.fetch(this.url("ProjectSetTokenMetadata"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        ok: _data.ok
                    };
                });
            });
        };
        this.getNiftyswapTokenQuantity = (args, headers)=>{
            return this.fetch(this.url("GetNiftyswapTokenQuantity"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        quantity: _data.quantity
                    };
                });
            });
        };
        this.getNiftyswapUnitPrices = (args, headers)=>{
            return this.fetch(this.url("GetNiftyswapUnitPrices"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        prices: _data.prices
                    };
                });
            });
        };
        this.getNiftyswapUnitPricesWithQuantities = (args, headers)=>{
            return this.fetch(this.url("GetNiftyswapUnitPricesWithQuantities"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        prices: _data.prices
                    };
                });
            });
        };
        this.hostname = hostname;
        this.fetch = (input, init)=>fetch(input, init);
    }
    url(name) {
        return this.hostname + this.path + name;
    }
}
const createHTTPRequest = (body = {}, headers = {})=>{
    return {
        method: "POST",
        headers: _extends({}, headers, {
            "Content-Type": "application/json"
        }),
        body: JSON.stringify(body || {})
    };
};
const buildResponse = (res)=>{
    return res.text().then((text)=>{
        let data;
        try {
            data = JSON.parse(text);
        } catch (err) {
            throw {
                code: "unknown",
                msg: `expecting JSON, got: ${text}`,
                status: res.status
            };
        }
        if (!res.ok) throw data; // webrpc error response
        return data;
    });
};
const fetch = typeof global === "object" ? global.fetch : window.fetch;
class SequenceMetadata extends Metadata {
    constructor(hostname = "https://metadata.sequence.app", projectAccessKey, jwtAuth){
        super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch);
        this.projectAccessKey = projectAccessKey;
        this.jwtAuth = jwtAuth;
        this._fetch = (input, init)=>{
            // automatically include jwt and access key auth header to requests
            // if its been set on the api client
            const headers = {};
            const jwtAuth = this.jwtAuth;
            const projectAccessKey = this.projectAccessKey;
            if (jwtAuth && jwtAuth.length > 0) headers["Authorization"] = `BEARER ${jwtAuth}`;
            if (projectAccessKey && projectAccessKey.length > 0) headers["X-Access-Key"] = projectAccessKey;
            // before the request is made
            init.headers = _extends({}, init.headers, headers);
            return fetch(input, init);
        };
        this.fetch = this._fetch;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1XjM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tracker", ()=>tracker);
parcelHelpers.export(exports, "trackers", ()=>index);
var _core = require("@0xsequence/core");
var _migration = require("@0xsequence/migration");
var _ethers = require("ethers");
var _replacer = require("@0xsequence/replacer");
var _idb = require("idb");
class ConfigTracker {
    constructor(){
        this.loadPresignedConfiguration = void 0;
        this.savePresignedConfiguration = void 0;
        this.saveWitnesses = void 0;
        this.configOfImageHash = void 0;
        this.saveWalletConfig = void 0;
        this.imageHashOfCounterfactualWallet = void 0;
        this.saveCounterfactualWallet = void 0;
        this.walletsOfSigner = void 0;
    }
}
var tracker = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ConfigTracker: ConfigTracker
});
class DebugConfigTracker {
    constructor(tracker){
        this.tracker = tracker;
    }
    async loadPresignedConfiguration(args) {
        console.debug("? loadPresignedConfiguration");
        debug(args, "? ");
        return debug(await this.tracker.loadPresignedConfiguration(args), "! ");
    }
    savePresignedConfiguration(args) {
        console.debug("? savePresignedConfiguration");
        debug(args, "? ");
        return this.tracker.savePresignedConfiguration(args);
    }
    saveWitnesses(args) {
        console.debug("? saveWitnesses");
        debug(args, "? ");
        return this.tracker.saveWitnesses(args);
    }
    async configOfImageHash(args) {
        console.debug("? configOfImageHash");
        debug(args, "? ");
        return debug(await this.tracker.configOfImageHash(args), "! ");
    }
    saveWalletConfig(args) {
        console.debug("? saveWalletConfig");
        debug(args, "? ");
        return this.tracker.saveWalletConfig(args);
    }
    async imageHashOfCounterfactualWallet(args) {
        console.debug("? imageHashOfCounterfactualWallet");
        debug(args, "? ");
        return debug(await this.tracker.imageHashOfCounterfactualWallet(args), "! ");
    }
    saveCounterfactualWallet(args) {
        console.debug("? saveCounterfactualWallet");
        debug(args, "? ");
        return this.tracker.saveCounterfactualWallet(args);
    }
    async walletsOfSigner(args) {
        console.debug("? walletsOfSigner");
        debug(args, "? ");
        return debug(await this.tracker.walletsOfSigner(args), "! ");
    }
    async getMigration(address, fromImageHash, fromVersion, chainId) {
        console.debug("? getMigration");
        debug({
            address,
            fromImageHash,
            fromVersion,
            chainId
        }, "? ");
        return debug(await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId), "! ");
    }
    saveMigration(address, signed, contexts) {
        console.debug("? saveMigration");
        debug({
            address,
            signed,
            contexts
        }, "? ");
        return this.tracker.saveMigration(address, signed, contexts);
    }
}
function debug(value, prefix = "") {
    switch(value){
        case undefined:
            console.debug(prefix + "undefined");
            break;
        default:
            JSON.stringify(value, undefined, 2).split("\n").map((line)=>prefix + line).forEach((line)=>console.debug(line));
            break;
    }
    return value;
}
var debug$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    DebugConfigTracker: DebugConfigTracker
});
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
class MemoryTrackerStore {
    constructor(){
        this.configs = {};
        this.v2Nodes = {};
        this.counterfactualWallets = {};
        this.payloads = {};
        this.signatures = {};
        this.migrations = {};
        this.loadConfig = (imageHash)=>{
            return Promise.resolve(this.configs[imageHash]);
        };
        this.saveConfig = (imageHash, config)=>{
            this.configs[imageHash] = config;
            return Promise.resolve();
        };
        this.loadV2Node = (nodeHash)=>{
            return Promise.resolve(this.v2Nodes[nodeHash]);
        };
        this.saveV2Node = (nodeHash, node)=>{
            this.v2Nodes[nodeHash] = node;
            return Promise.resolve();
        };
        this.loadCounterfactualWallet = (wallet)=>{
            return Promise.resolve(this.counterfactualWallets[wallet]);
        };
        this.saveCounterfactualWallet = (wallet, imageHash, context)=>{
            this.counterfactualWallets[wallet] = {
                imageHash,
                context
            };
            return Promise.resolve();
        };
        this.loadPayloadOfSubdigest = (subdigest)=>{
            return Promise.resolve(this.payloads[subdigest]);
        };
        this.savePayloadOfSubdigest = (subdigest, payload)=>{
            this.payloads[subdigest] = payload;
            return Promise.resolve();
        };
        this.loadSubdigestsOfSigner = (signer)=>{
            return Promise.resolve(Object.keys(this.signatures[signer] || {}));
        };
        this.loadSignatureOfSubdigest = (signer, subdigest)=>{
            var _this$signatures$sign;
            return Promise.resolve((_this$signatures$sign = this.signatures[signer]) == null ? void 0 : _this$signatures$sign[subdigest]);
        };
        this.saveSignatureOfSubdigest = (signer, subdigest, payload)=>{
            if (!this.signatures[signer]) this.signatures[signer] = {};
            this.signatures[signer][subdigest] = payload;
            return Promise.resolve();
        };
        this.loadMigrationsSubdigest = (wallet, fromVersion, toVersion)=>{
            var _this$migrations$wall;
            return Promise.resolve(((_this$migrations$wall = this.migrations[wallet]) == null || (_this$migrations$wall = _this$migrations$wall[fromVersion]) == null ? void 0 : _this$migrations$wall[toVersion]) || []);
        };
        this.saveMigrationsSubdigest = (wallet, fromVersion, toVersion, subdigest, toImageHash)=>{
            if (!this.migrations[wallet]) this.migrations[wallet] = {};
            if (!this.migrations[wallet][fromVersion]) this.migrations[wallet][fromVersion] = {};
            if (!this.migrations[wallet][fromVersion][toVersion]) this.migrations[wallet][fromVersion][toVersion] = [];
            this.migrations[wallet][fromVersion][toVersion].push({
                subdigest,
                toImageHash
            });
            return Promise.resolve();
        };
    }
}
function recreateBigNumbers(object) {
    if (object === undefined) return undefined;
    const result = {};
    for (const key of Object.keys(object)){
        const val = object[key];
        if (val._isBigNumber === true && val._hex !== undefined && typeof val._hex === "string" && val._hex.length !== "") // Entry is a big number
        result[key] = (0, _ethers.ethers).BigNumber.from(val);
        else if (Array.isArray(val)) // Entry is an array, recurse
        result[key] = val.map((v)=>recreateBigNumbers(v));
        else if (typeof val === "object" && val !== null) // Entry is another object, recurse
        result[key] = recreateBigNumbers(val);
        else // Entry is a primitive, just copy
        result[key] = val;
    }
    return result;
}
class IndexedDBStore {
    constructor(dbName){
        var _this = this;
        this.dbName = dbName;
        this._lazyDb = void 0;
        this.loadConfig = async function(imageHash) {
            const db = await _this.getDb();
            return db.get("configs", imageHash).then((c)=>recreateBigNumbers(c));
        };
        this.saveConfig = async function(imageHash, config) {
            const db = await _this.getDb();
            await db.put("configs", config, imageHash);
        };
        this.loadV2Node = async function(nodeHash) {
            const db = await _this.getDb();
            return db.get("v2Nodes", nodeHash).then((c)=>recreateBigNumbers(c));
        };
        this.saveV2Node = async function(nodeHash, node) {
            const db = await _this.getDb();
            await db.put("v2Nodes", node, nodeHash);
        };
        this.loadCounterfactualWallet = async function(wallet) {
            const db = await _this.getDb();
            return db.get("counterfactualWallets", wallet);
        };
        this.saveCounterfactualWallet = async function(wallet, imageHash, context) {
            const db = await _this.getDb();
            await db.put("counterfactualWallets", {
                imageHash,
                context
            }, wallet);
        };
        this.loadPayloadOfSubdigest = async function(subdigest) {
            const db = await _this.getDb();
            return db.get("payloads", subdigest).then((c)=>recreateBigNumbers(c));
        };
        this.savePayloadOfSubdigest = async function(subdigest, payload) {
            const db = await _this.getDb();
            await db.put("payloads", payload, subdigest);
        };
        this.loadSubdigestsOfSigner = async function(signer) {
            const db = await _this.getDb();
            const index = await db.getAllKeysFromIndex("signatures", "signer", IDBKeyRange.only(signer));
            return index.map((key)=>key.split("-")[0]);
        };
        this.loadSignatureOfSubdigest = async function(signer, subdigest) {
            const db = await _this.getDb();
            const signature = await db.get("signatures", [
                subdigest,
                signer
            ].join("-"));
            return signature == null ? void 0 : signature.signature;
        };
        this.saveSignatureOfSubdigest = async function(signer, subdigest, payload) {
            const db = await _this.getDb();
            await db.put("signatures", {
                signature: payload,
                signer
            }, [
                subdigest,
                signer
            ].join("-"));
        };
        this.loadMigrationsSubdigest = async function(wallet, fromVersion, toVersion) {
            const db = await _this.getDb();
            const index = await db.getAllFromIndex("migrations", "jump", IDBKeyRange.only([
                wallet,
                fromVersion,
                toVersion
            ]));
            return index.map((key)=>({
                    subdigest: key.subdigest,
                    toImageHash: key.toImageHash
                }));
        };
        this.saveMigrationsSubdigest = async function(wallet, fromVersion, toVersion, subdigest, toImageHash) {
            const db = await _this.getDb();
            await db.put("migrations", {
                wallet,
                fromVersion,
                toVersion,
                subdigest,
                toImageHash
            }, subdigest);
        };
    }
    async getDb() {
        if (this._lazyDb) return this._lazyDb;
        const dbName = this.dbName;
        this._lazyDb = await (0, _idb.openDB)(dbName, 1, {
            upgrade (db, oldVersion, newVersion, transaction) {
                console.log(`upgrading ${dbName} from ${oldVersion} to ${newVersion} - ${transaction}`);
                if (oldVersion === 0) {
                    db.createObjectStore("configs");
                    db.createObjectStore("v2Nodes");
                    db.createObjectStore("counterfactualWallets");
                    db.createObjectStore("payloads");
                    const signatures = db.createObjectStore("signatures");
                    signatures.createIndex("signer", "signer", {
                        unique: false
                    });
                    const migrations = db.createObjectStore("migrations");
                    migrations.createIndex("jump", [
                        "wallet",
                        "fromVersion",
                        "toVersion"
                    ]);
                }
            }
        });
        return this._lazyDb;
    }
}
function isPlainNode(node) {
    return node.left !== undefined && node.right !== undefined;
}
function isPlainNested(node) {
    return node.weight !== undefined && node.threshold !== undefined && node.tree !== undefined;
}
function isPlainV2Config(config) {
    return config.version === 2 && config.threshold !== undefined && config.checkpoint !== undefined && config.tree !== undefined && typeof config.tree === "string";
}
var index$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    isPlainNode: isPlainNode,
    isPlainNested: isPlainNested,
    isPlainV2Config: isPlainV2Config,
    MemoryTrackerStore: MemoryTrackerStore,
    recreateBigNumbers: recreateBigNumbers,
    IndexedDBStore: IndexedDBStore
});
class LocalConfigTracker {
    constructor(// TODO: The provider is only used to determine that EIP1271 signatures have *some* validity
    // but when reconstructing a presigned transaction we should do the replacement once per chain.
    // For now, it's recommended to use Mainnet as the provider.
    provider, store = new MemoryTrackerStore(), useEIP5719 = false){
        var _this = this;
        this.provider = provider;
        this.store = store;
        this.useEIP5719 = useEIP5719;
        this.cachedEIP5719 = void 0;
        this.loadTopology = async function(hash) {
            const node = await _this.store.loadV2Node(hash);
            if (!node) return {
                nodeHash: hash
            };
            if (isPlainNode(node)) {
                const [left, right] = await Promise.all([
                    _this.loadTopology(node.left),
                    _this.loadTopology(node.right)
                ]);
                return {
                    left,
                    right
                };
            }
            if (isPlainNested(node)) return {
                weight: (0, _ethers.ethers).BigNumber.from(node.weight),
                threshold: (0, _ethers.ethers).BigNumber.from(node.threshold),
                tree: await _this.loadTopology(node.tree)
            };
            return node;
        };
        this.saveTopology = async function(node) {
            if ((0, _core.v2).config.isNodeLeaf(node)) return; // Nothing to do, this is a dead-end
            const hash = (0, _core.v2).config.hashNode(node);
            if ((0, _core.v2).config.isNode(node)) {
                const saveLeft = _this.saveTopology(node.left);
                const saveRight = _this.saveTopology(node.right);
                const saveThis = _this.store.saveV2Node(hash, {
                    left: (0, _core.v2).config.hashNode(node.left),
                    right: (0, _core.v2).config.hashNode(node.right)
                });
                await Promise.all([
                    saveLeft,
                    saveRight,
                    saveThis
                ]);
                return;
            }
            if ((0, _core.v2).config.isNestedLeaf(node)) {
                const saveTree = _this.saveTopology(node.tree);
                const saveThis = _this.store.saveV2Node(hash, {
                    weight: (0, _ethers.ethers).BigNumber.from(node.weight).toString(),
                    threshold: (0, _ethers.ethers).BigNumber.from(node.threshold).toString(),
                    tree: (0, _core.v2).config.hashNode(node.tree)
                });
                await Promise.all([
                    saveTree,
                    saveThis
                ]);
                return;
            }
            // If it's a normal leaf, then we just store it
            if ((0, _core.v2).config.isSignerLeaf(node)) return _this.store.saveV2Node(hash, {
                address: node.address,
                weight: node.weight
            });
            if ((0, _core.v2).config.isSubdigestLeaf(node)) return _this.store.saveV2Node(hash, {
                subdigest: node.subdigest
            });
            throw new Error(`Unknown topology type: ${node}`);
        };
        this.saveWalletConfig = async function(args) {
            const { config } = args;
            if ((0, _core.v1).config.ConfigCoder.isWalletConfig(config)) {
                // We can store the configuration as-is
                const imageHash = (0, _core.v1).config.ConfigCoder.imageHashOf(config);
                return _this.store.saveConfig(imageHash, config);
            }
            if ((0, _core.v2).config.ConfigCoder.isWalletConfig(config)) {
                // We split the configuration in a list of nodes, and store them individually
                // then we can reconstruct it. This also means we can combine multiple configurations
                // if they share information
                const imageHash = (0, _core.v2).config.ConfigCoder.imageHashOf(config);
                // This is an optimization, it allows us to avoid splitting the tree if it's already complete
                if ((0, _core.v2).config.isComplete(config.tree)) return _this.store.saveConfig(imageHash, config);
            // TODO: Re-enable storing partial v2 configs once
            // we have more performant code to reconstructing them
            // in the meantime, rely on the remote tracker
            // const storeTree = this.saveTopology(config.tree)
            // const storeConfig = this.store.saveConfig(imageHash, {
            //   version: 2,
            //   threshold: ethers.BigNumber.from(config.threshold).toString(),
            //   checkpoint: ethers.BigNumber.from(config.checkpoint).toString(),
            //   tree: v2.config.hashNode(config.tree)
            // })
            // await Promise.all([storeTree, storeConfig])
            }
            return;
        };
        this.configOfImageHashCache = {};
        this.configOfImageHash = async function(args) {
            const { imageHash } = args;
            if (_this.configOfImageHashCache[args.imageHash]) return _this.configOfImageHashCache[args.imageHash];
            const config = await _this.store.loadConfig(imageHash);
            if (!config) return undefined;
            if (config.version === 1 || config.version === 2 && !isPlainV2Config(config)) {
                _this.configOfImageHashCache[args.imageHash] = config;
                return config;
            }
            if (isPlainV2Config(config)) {
                const fullConfig = {
                    version: 2,
                    threshold: (0, _ethers.ethers).BigNumber.from(config.threshold),
                    checkpoint: (0, _ethers.ethers).BigNumber.from(config.checkpoint),
                    tree: await _this.loadTopology(config.tree)
                };
                _this.configOfImageHashCache[args.imageHash] = fullConfig;
                return fullConfig;
            }
            throw new Error(`Unknown config type: ${config}`);
        };
        this.saveCounterfactualWallet = async function(args) {
            const { config, context } = args;
            const imageHash = (0, _core.universal).genericCoderFor(config.version).config.imageHashOf(config);
            await Promise.all([
                _this.saveWalletConfig({
                    config
                }),
                ...context.map((ctx)=>{
                    const address = (0, _core.commons).context.addressOf(ctx, imageHash);
                    return _this.store.saveCounterfactualWallet(address, imageHash, ctx);
                })
            ]);
        };
        this.imageHashOfCounterfactualWallet = async function(args) {
            const { wallet } = args;
            const result = await _this.store.loadCounterfactualWallet(wallet);
            if (!result) return undefined;
            return {
                imageHash: result.imageHash,
                context: result.context
            };
        };
        this.savePayload = async function(args) {
            const { payload } = args;
            const subdigest = (0, _core.commons).signature.subdigestOf(payload);
            await _this.store.savePayloadOfSubdigest(subdigest, payload);
        };
        this.payloadOfSubdigestCache = {};
        this.payloadOfSubdigest = async function(args) {
            if (_this.payloadOfSubdigestCache[args.subdigest]) return _this.payloadOfSubdigestCache[args.subdigest];
            const { subdigest } = args;
            const res = await _this.store.loadPayloadOfSubdigest(subdigest);
            if (res) _this.payloadOfSubdigestCache[subdigest] = res;
            return res;
        };
        this.savePresignedConfiguration = async function(args) {
            // Presigned configurations only work with v2 (for now)
            // so we can assume that the signature is for a v2 configuration
            const decoded = (0, _core.v2).signature.SignatureCoder.decode(args.signature);
            const nextImageHash = (0, _core.universal).genericCoderFor(args.nextConfig.version).config.imageHashOf(args.nextConfig);
            const message = (0, _core.v2).chained.messageSetImageHash(nextImageHash);
            const digest = (0, _ethers.ethers).utils.keccak256(message);
            const payload = {
                message,
                address: args.wallet,
                chainId: 0,
                digest
            };
            const savePayload = _this.savePayload({
                payload
            });
            const saveNextConfig = _this.saveWalletConfig({
                config: args.nextConfig
            });
            const recovered = await (0, _core.v2).signature.SignatureCoder.recover(decoded, payload, _this.provider);
            // Save the recovered configuration and all signature parts
            const signatures = (0, _core.v2).signature.signaturesOf(recovered.config.tree);
            await Promise.all([
                savePayload,
                saveNextConfig,
                _this.saveWalletConfig({
                    config: recovered.config
                }),
                ...signatures.map((sig)=>_this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))
            ]);
        };
        this.loadPresignedConfiguration = async function(args) {
            const { wallet, fromImageHash, longestPath } = args;
            const fromConfig = await _this.configOfImageHash({
                imageHash: fromImageHash
            });
            if (!fromConfig || !(0, _core.v2).config.ConfigCoder.isWalletConfig(fromConfig)) return [];
            // Get all subdigests for the config members
            const signers = (0, _core.v2).config.signersOf(fromConfig.tree).map((s)=>s.address);
            const subdigestsOfSigner = await Promise.all(signers.map((s)=>_this.store.loadSubdigestsOfSigner(s)));
            const subdigests = [
                ...new Set(subdigestsOfSigner.flat())
            ];
            // Get all unique payloads
            const payloads = await Promise.all([
                ...new Set(subdigests)
            ].map(async function(s) {
                return _extends({}, await _this.payloadOfSubdigest({
                    subdigest: s
                }), {
                    subdigest: s
                });
            }));
            // Get all possible next imageHashes based on the payloads
            const nextImageHashes = payloads.filter((p)=>(p == null ? void 0 : p.message) && (p == null ? void 0 : p.address) && p.address === wallet).map((p)=>({
                    payload: p,
                    nextImageHash: (0, _core.v2).chained.decodeMessageSetImageHash(p.message)
                })).filter((p)=>p == null ? void 0 : p.nextImageHash);
            // Build a signature for each next imageHash
            // and filter out the ones that don't have enough weight
            let bestCandidate;
            const nextConfigsAndCheckpoints = await Promise.all(nextImageHashes.map(async function({ nextImageHash, payload }) {
                const nextConfig = await _this.configOfImageHash({
                    imageHash: nextImageHash
                });
                if (!nextConfig || !(0, _core.v2).config.isWalletConfig(nextConfig)) return undefined;
                const nextCheckpoint = (0, _ethers.ethers).BigNumber.from(nextConfig.checkpoint);
                return {
                    nextConfig,
                    nextCheckpoint,
                    nextImageHash,
                    payload
                };
            }));
            const sortedNextConfigsAndCheckpoints = nextConfigsAndCheckpoints.filter((c)=>c !== undefined).filter((c)=>c.nextCheckpoint.gt(fromConfig.checkpoint)).sort((a, b)=>// If we are looking for the longest path, sort by ascending checkpoint
                // because we want to find the smalles jump, and we should start with the
                // closest one. If we are not looking for the longest path, sort by
                // descending checkpoint, because we want to find the largest jump.
                //
                // We don't have a guarantee that all "next configs" will be valid
                // so worst case scenario we will need to try all of them.
                // But we can try to optimize for the most common case.
                a.nextCheckpoint.gt(b.nextCheckpoint) ? longestPath ? 1 : -1 : longestPath ? -1 : 1);
            for (const entry of sortedNextConfigsAndCheckpoints){
                const { nextConfig, nextCheckpoint, nextImageHash, payload } = entry;
                if (bestCandidate) {
                    const bestCheckpoint = bestCandidate.checkpoint;
                    if (longestPath) {
                        // Only consider candidates earlier than our current best
                        if (nextCheckpoint.gte(bestCheckpoint)) continue;
                    } else {
                        // Only consider candidates later than our current best
                        if (nextCheckpoint.lte(bestCheckpoint)) continue;
                    }
                }
                // Get all signatures (for all signers) for this subdigest
                const signatures = new Map((await Promise.all(signers.map(async function(signer) {
                    const signature = await _this.store.loadSignatureOfSubdigest(signer, payload.subdigest);
                    if (!signature) return [
                        signer,
                        undefined
                    ];
                    const replacedSignature = (0, _ethers.ethers).utils.hexlify(_this.useEIP5719 ? await _this.cachedEIP5719.runByEIP5719(signer, payload.subdigest, signature) : signature);
                    const isDynamic = (0, _core.commons).signer.tryRecoverSigner(payload.subdigest, replacedSignature) !== signer;
                    return [
                        signer,
                        {
                            isDynamic,
                            signature: replacedSignature
                        }
                    ];
                }))).filter((signature)=>Boolean(signature[1])));
                // Skip if we don't have ANY signatures (it can never reach the threshold)
                if (signatures.size === 0) continue;
                // Encode the full signature (to see if it has enough weight)
                const encoded = (0, _core.v2).signature.SignatureCoder.encodeSigners(fromConfig, signatures, [], 0);
                if (encoded.weight.lt(fromConfig.threshold)) continue;
                // Save the new best candidate
                bestCandidate = {
                    nextImageHash,
                    checkpoint: (0, _ethers.ethers).BigNumber.from(nextConfig.checkpoint),
                    signature: encoded.encoded
                };
            }
            if (!bestCandidate) return [];
            // Get the next step
            const nextStep = await _this.loadPresignedConfiguration({
                wallet,
                fromImageHash: bestCandidate.nextImageHash,
                longestPath
            });
            return [
                {
                    wallet,
                    nextImageHash: bestCandidate.nextImageHash,
                    signature: bestCandidate.signature
                },
                ...nextStep
            ];
        };
        this.saveWitnesses = async function(args) {
            const payload = {
                digest: args.digest,
                address: args.wallet,
                chainId: args.chainId
            };
            const subdigest = (0, _core.commons).signature.subdigestOf(payload);
            await Promise.all([
                _this.savePayload({
                    payload
                }),
                ...args.signatures.filter((signature)=>{
                    // We don't support saving witnesses for non-recoverable signatures
                    // we could change this eventually, but the issue is that the witness may become invalid
                    return (0, _core.commons).signer.canRecover(signature);
                }).map((signature)=>{
                    const signer = (0, _core.commons).signer.recoverSigner(subdigest, signature);
                    return _this.store.saveSignatureOfSubdigest(signer, subdigest, signature);
                })
            ]);
        };
        this.walletsOfSigner = async function(args) {
            const subdigests = await _this.store.loadSubdigestsOfSigner(args.signer);
            const payloads = await Promise.all(subdigests.map((s)=>_this.payloadOfSubdigest({
                    subdigest: s
                }))).then((p)=>p.filter((p)=>p !== undefined));
            // filter unique wallets, and provide a proof for each wallet
            const result = [];
            for (const payload of payloads){
                const wallet = payload.address;
                if (result.find((r)=>r.wallet === wallet)) continue;
                const subdigest = (0, _core.commons).signature.subdigestOf(payload);
                const signature = await _this.store.loadSignatureOfSubdigest(args.signer, subdigest);
                if (!signature) continue;
                result.push({
                    wallet,
                    proof: {
                        digest: payload.digest,
                        chainId: (0, _ethers.ethers).BigNumber.from(payload.chainId),
                        signature: (0, _ethers.ethers).utils.hexlify(signature)
                    }
                });
            }
            return result;
        };
        this.cachedEIP5719 = new (0, _replacer.CachedEIP5719)(provider);
    }
    async saveMigration(address, signed, contexts) {
        const fromVersion = signed.fromVersion;
        if (fromVersion !== 1) throw new Error("Migration not supported");
        if (!(0, _core.v2).config.isWalletConfig(signed.toConfig)) throw new Error("Invalid to config");
        // Validate migration transaction
        const { newImageHash, address: decodedAddress } = (0, _migration.migration).v1v2.decodeTransaction(signed.tx, contexts);
        if (decodedAddress !== address) throw new Error("Invalid migration transaction - address");
        if ((0, _core.v2).config.ConfigCoder.imageHashOf(signed.toConfig) != newImageHash) throw new Error("Invalid migration transaction - config");
        // Split signature and save each part
        const message = (0, _core.commons).transaction.packMetaTransactionsData(signed.tx.nonce, signed.tx.transactions);
        const digest = (0, _ethers.ethers).utils.keccak256(message);
        const payload = {
            chainId: signed.tx.chainId,
            message,
            address,
            digest
        };
        const subdigest = (0, _core.commons).signature.subdigestOf(payload);
        const savePayload = this.savePayload({
            payload
        });
        const saveToConfig = this.saveWalletConfig({
            config: signed.toConfig
        });
        const decoded = (0, _core.v1).signature.SignatureCoder.decode(signed.tx.signature);
        const recovered = await (0, _core.v1).signature.SignatureCoder.recover(decoded, payload, this.provider);
        // Save the recovered config, the migrate transaction, and all signature parts
        const signatures = (0, _core.v1).signature.SignatureCoder.signaturesOf(recovered.config);
        await Promise.all([
            savePayload,
            saveToConfig,
            this.saveWalletConfig({
                config: recovered.config
            }),
            this.store.saveMigrationsSubdigest(address, fromVersion, fromVersion + 1, subdigest, newImageHash),
            ...signatures.map((sig)=>this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))
        ]);
    }
    async getMigration(address, fromImageHash, fromVersion, chainId) {
        var _this2 = this;
        // Get the current config and all possible migration payloads
        const [currentConfig, txs] = await Promise.all([
            this.configOfImageHash({
                imageHash: fromImageHash
            }),
            this.store.loadMigrationsSubdigest(address, fromVersion, fromVersion + 1)
        ]);
        const coder = (0, _core.universal).coderFor(fromVersion);
        if (!currentConfig) // We may not be able to find the config, because the migration is still not copied locally
        // in that case we consider as we don't have any migration
        return undefined;
        if (!coder.config.isWalletConfig(currentConfig)) // throw new Error("Invalid from config - version")
        // better to not fail here, some other tracker may be able to handle this migration
        return undefined;
        // We need to process every migration candidate individually
        // and see which one has enough signers to be valid (for the current config)
        const candidates = await Promise.all(txs.map(async function(tx) {
            const { subdigest, toImageHash } = tx;
            const payload = await _this2.payloadOfSubdigest({
                subdigest
            });
            if (!payload || !payload.message) return undefined;
            if (!(0, _ethers.ethers).BigNumber.from(chainId).eq(payload.chainId)) return undefined;
            const signers = coder.config.signersOf(currentConfig).map((s)=>s.address);
            // Get all signatures (for all signers) for this subdigest
            const signatures = new Map((await Promise.all(signers.map(async function(signer) {
                const signature = await _this2.store.loadSignatureOfSubdigest(signer, subdigest);
                if (!signature) return [
                    signer,
                    undefined
                ];
                const replacedSignature = (0, _ethers.ethers).utils.hexlify(_this2.useEIP5719 ? await _this2.cachedEIP5719.runByEIP5719(signer, subdigest, signature) : signature);
                const isDynamic = (0, _core.commons).signer.tryRecoverSigner(subdigest, replacedSignature) !== signer;
                return [
                    signer,
                    {
                        isDynamic,
                        signature: replacedSignature
                    }
                ];
            }))).filter((signature)=>Boolean(signature[1])));
            // Encode signature parts into a single signature
            const encoded = coder.signature.encodeSigners(currentConfig, signatures, [], chainId);
            if (!encoded || encoded.weight < currentConfig.threshold) return undefined;
            // Unpack payload (it should have transactions)
            const [nonce, transactions] = (0, _core.commons).transaction.unpackMetaTransactionsData(payload.message);
            return {
                tx: {
                    entrypoint: address,
                    transactions: (0, _core.commons).transaction.fromTxAbiEncode(transactions),
                    chainId: chainId,
                    nonce: nonce,
                    signature: encoded.encoded,
                    intent: {
                        id: subdigest,
                        wallet: address
                    }
                },
                toConfig: await _this2.configOfImageHash({
                    imageHash: toImageHash
                }),
                fromVersion,
                toVersion: fromVersion + 1
            };
        })).then((c)=>c.filter((c)=>c !== undefined));
        // Return the first valid candidate
        return candidates[0];
    }
    updateProvider(provider) {
        this.provider = provider;
    }
}
var local = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    LocalConfigTracker: LocalConfigTracker
});
//
// Types
//
let SignatureType = /*#__PURE__*/ function(SignatureType) {
    SignatureType["EIP712"] = "EIP712";
    SignatureType["EthSign"] = "EthSign";
    SignatureType["EIP1271"] = "EIP1271";
    return SignatureType;
}({});
//
// Client
//
class Sessions {
    constructor(hostname, fetch1){
        this.hostname = void 0;
        this.fetch = void 0;
        this.path = "/rpc/Sessions/";
        this.ping = (headers)=>{
            return this.fetch(this.url("Ping"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.config = (args, headers)=>{
            return this.fetch(this.url("Config"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        version: _data.version,
                        config: _data.config
                    };
                });
            });
        };
        this.wallets = (args, headers)=>{
            return this.fetch(this.url("Wallets"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        wallets: _data.wallets
                    };
                });
            });
        };
        this.deployHash = (args, headers)=>{
            return this.fetch(this.url("DeployHash"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        deployHash: _data.deployHash,
                        context: _data.context
                    };
                });
            });
        };
        this.configUpdates = (args, headers)=>{
            return this.fetch(this.url("ConfigUpdates"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        updates: _data.updates
                    };
                });
            });
        };
        this.migrations = (args, headers)=>{
            return this.fetch(this.url("Migrations"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        migrations: _data.migrations
                    };
                });
            });
        };
        this.saveConfig = (args, headers)=>{
            return this.fetch(this.url("SaveConfig"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.saveWallet = (args, headers)=>{
            return this.fetch(this.url("SaveWallet"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.saveSignature = (args, headers)=>{
            return this.fetch(this.url("SaveSignature"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.saveSignerSignatures = (args, headers)=>{
            return this.fetch(this.url("SaveSignerSignatures"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.saveMigration = (args, headers)=>{
            return this.fetch(this.url("SaveMigration"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.hostname = hostname;
        this.fetch = (input, init)=>fetch1(input, init);
    }
    url(name) {
        return this.hostname + this.path + name;
    }
}
const createHTTPRequest = (body = {}, headers = {})=>{
    return {
        method: "POST",
        headers: _extends({}, headers, {
            "Content-Type": "application/json"
        }),
        body: JSON.stringify(body || {})
    };
};
const buildResponse = (res)=>{
    return res.text().then((text)=>{
        let data;
        try {
            data = JSON.parse(text);
        } catch (err) {
            throw {
                code: "unknown",
                msg: `expecting JSON, got: ${text}`,
                status: res.status
            };
        }
        if (!res.ok) throw data; // webrpc error response
        return data;
    });
};
class RemoteConfigTracker {
    constructor(hostname, onlyRecoverable = true){
        this.onlyRecoverable = onlyRecoverable;
        this.sessions = void 0;
        this.sessions = new Sessions(hostname, fetch);
    }
    async loadPresignedConfiguration(args) {
        try {
            const { updates } = await this.sessions.configUpdates({
                wallet: args.wallet,
                fromImageHash: args.fromImageHash,
                allUpdates: args.longestPath
            });
            return updates.map(({ toImageHash, signature })=>({
                    wallet: args.wallet,
                    nextImageHash: toImageHash,
                    signature
                }));
        } catch (error) {
            if (is404NotFound(error)) return [];
            else throw error;
        }
    }
    async savePresignedConfiguration(args) {
        const config = args.nextConfig;
        const imageHash = (0, _core.universal).genericCoderFor(config.version).config.imageHashOf(config);
        const message = (0, _core.v2).signature.setImageHashStruct(imageHash);
        const digest = (0, _ethers.ethers).utils.keccak256(message);
        await this.sessions.saveSignature({
            wallet: args.wallet,
            digest,
            chainID: "0",
            signature: args.signature,
            toConfig: encodeConfig(config)
        });
    }
    async saveWitnesses(args) {
        let filteredSignatures = args.signatures;
        if (this.onlyRecoverable) filteredSignatures = filteredSignatures.filter((signature)=>{
            return (0, _core.commons).signer.canRecover(signature);
        });
        await this.sessions.saveSignerSignatures({
            wallet: args.wallet,
            digest: args.digest,
            chainID: numberString(args.chainId),
            signatures: filteredSignatures
        });
    }
    async configOfImageHash(args) {
        try {
            const { version, config } = await this.sessions.config(args);
            return decodeConfig(version, config);
        } catch (error) {
            if (is404NotFound(error)) return;
            else throw error;
        }
    }
    async saveWalletConfig(args) {
        const config = encodeConfig(args.config);
        await this.sessions.saveConfig({
            version: args.config.version,
            config
        });
    }
    async imageHashOfCounterfactualWallet(args) {
        try {
            const { deployHash, context } = await this.sessions.deployHash(args);
            return {
                imageHash: deployHash,
                context
            };
        } catch (error) {
            if (is404NotFound(error)) return;
            else throw error;
        }
    }
    async saveCounterfactualWallet(args) {
        const deployConfig = encodeConfig(args.config);
        await this.sessions.saveWallet({
            version: args.config.version,
            deployConfig
        });
    }
    async walletsOfSigner(args) {
        const { wallets } = await this.sessions.wallets(args);
        return Object.entries(wallets).map(([wallet, { digest, chainID, type, signature }])=>{
            switch(type){
                case SignatureType.EIP712:
                    signature += (0, _ethers.ethers).utils.hexlify((0, _core.commons).signer.SigType.EIP712).slice(2);
                    break;
                case SignatureType.EthSign:
                    signature += (0, _ethers.ethers).utils.hexlify((0, _core.commons).signer.SigType.ETH_SIGN).slice(2);
                    break;
                case SignatureType.EIP1271:
                    signature += (0, _ethers.ethers).utils.hexlify((0, _core.commons).signer.SigType.WALLET_BYTES32).slice(2);
                    break;
            }
            return {
                wallet,
                proof: {
                    digest,
                    signature,
                    chainId: (0, _ethers.ethers).BigNumber.from(chainID)
                }
            };
        });
    }
    async getMigration(wallet, fromImageHash, fromVersion, chainId) {
        var _this = this;
        const chainIdString = numberString(chainId);
        const { migrations } = await this.sessions.migrations({
            wallet,
            fromVersion,
            fromImageHash,
            chainID: chainIdString
        });
        const chooseMigration = async function chooseMigration(chainId) {
            const migrations_ = migrations[chainId];
            if (migrations_) {
                const toVersions = Object.keys(migrations_).map(Number).sort((a, b)=>b - a);
                for (const toVersion of toVersions){
                    for (const [toHash, transactions] of Object.entries(migrations_[toVersion]))try {
                        const toConfig = await _this.configOfImageHash({
                            imageHash: toHash
                        });
                        if (toConfig) return {
                            fromVersion,
                            toVersion,
                            toConfig,
                            tx: {
                                entrypoint: transactions.executor,
                                transactions: transactions.transactions,
                                nonce: transactions.nonce,
                                signature: transactions.signature,
                                chainId,
                                intent: {
                                    id: (0, _core.commons).transaction.subdigestOfTransactions(wallet, chainId, transactions.nonce, transactions.transactions),
                                    wallet
                                }
                            }
                        };
                    } catch (error) {
                        console.error(error);
                    }
                }
            }
            return;
        };
        const migration = await chooseMigration(chainIdString);
        if (migration) return migration;
        for(const _chainId in migrations)if (_chainId !== chainIdString) {
            const _migration = await chooseMigration(_chainId);
            if (_migration) return _migration;
        }
        return;
    }
    async saveMigration(wallet, signed, _contexts) {
        await this.sessions.saveMigration({
            wallet,
            fromVersion: signed.fromVersion,
            toVersion: signed.toVersion,
            toConfig: encodeConfig(signed.toConfig),
            executor: signed.tx.entrypoint,
            transactions: signed.tx.transactions.map(encodeTransaction),
            nonce: numberString(signed.tx.nonce),
            signature: signed.tx.signature,
            chainID: numberString(signed.tx.chainId)
        });
    }
}
function encodeConfig(config) {
    switch(config.version){
        case 1:
            if ((0, _core.v1).config.ConfigCoder.isWalletConfig(config)) return {
                threshold: numberNumber(config.threshold),
                signers: config.signers.map(({ weight, address })=>({
                        weight: numberNumber(weight),
                        address
                    }))
            };
            else throw new Error(`not a v${config.version} config: ${config}`);
        case 2:
            if ((0, _core.v2).config.ConfigCoder.isWalletConfig(config)) return {
                threshold: numberNumber(config.threshold),
                checkpoint: numberNumber(config.checkpoint),
                tree: encodeV2ConfigTree(config.tree)
            };
            else throw new Error(`not a v${config.version} config: ${config}`);
        default:
            throw new Error(`unknown version ${config.version}`);
    }
}
function encodeV2ConfigTree(tree) {
    if ((0, _core.v2).config.isNode(tree)) return {
        left: encodeV2ConfigTree(tree.left),
        right: encodeV2ConfigTree(tree.right)
    };
    else if ((0, _core.v2).config.isSignerLeaf(tree)) return {
        weight: numberNumber(tree.weight),
        address: tree.address
    };
    else if ((0, _core.v2).config.isNestedLeaf(tree)) return {
        weight: numberNumber(tree.weight),
        threshold: numberNumber(tree.threshold),
        tree: encodeV2ConfigTree(tree.tree)
    };
    else if ((0, _core.v2).config.isNodeLeaf(tree)) return {
        node: tree.nodeHash
    };
    else return _extends({}, tree);
}
function decodeConfig(version, config) {
    switch(version){
        case 1:
            return _extends({}, config, {
                version
            });
        case 2:
            return _extends({}, config, {
                version,
                tree: decodeV2ConfigTree(config.tree)
            });
        default:
            throw new Error(`unknown version ${version}`);
    }
}
function decodeV2ConfigTree(tree) {
    switch(typeof tree){
        case "object":
            const tree_ = _extends({}, tree);
            if (tree_.left !== undefined) tree_.left = decodeV2ConfigTree(tree_.left);
            if (tree_.right !== undefined) tree_.right = decodeV2ConfigTree(tree_.right);
            if (tree_.tree !== undefined) tree_.tree = decodeV2ConfigTree(tree_.tree);
            if (tree_.node !== undefined) {
                tree_.nodeHash = tree_.node;
                delete tree_.node;
            }
            return tree_;
        default:
            throw new Error(`v2 config tree ${tree} is not an object`);
    }
}
function encodeTransaction(transaction) {
    return {
        to: transaction.to,
        value: transaction.value !== undefined ? numberString(transaction.value) : undefined,
        data: transaction.data !== undefined ? (0, _ethers.ethers).utils.hexlify(transaction.data) : undefined,
        gasLimit: transaction.gasLimit !== undefined ? numberString(transaction.gasLimit) : undefined,
        delegateCall: transaction.delegateCall,
        revertOnError: transaction.revertOnError
    };
}
function numberNumber(n) {
    return (0, _ethers.ethers).BigNumber.from(n).toNumber();
}
function numberString(n) {
    return (0, _ethers.ethers).BigNumber.from(n).toString();
}
function is404NotFound(error) {
    return typeof error === "object" && error.status === 404;
}
var index$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    RemoteConfigTracker: RemoteConfigTracker
});
function raceUntil(promises, fallback, evalRes) {
    return new Promise((resolve)=>{
        let count = 0;
        promises.forEach((p)=>p.then((val)=>{
                if (evalRes(val)) resolve(val);
                else {
                    count++;
                    if (count === promises.length) resolve(fallback);
                }
            }).catch(()=>{
                // Ignore
                count++;
                if (count === promises.length) resolve(fallback);
            }));
    });
}
async function allSafe(promises, fallback) {
    return Promise.all(promises.map((promise)=>promise.catch(()=>fallback)));
}
class MultipleTracker {
    constructor(trackers){
        this.trackers = trackers;
    }
    async configOfImageHash(args) {
        const requests = this.trackers.map(async function(t, i) {
            return {
                res: await t.configOfImageHash(args),
                i
            };
        });
        // We try to find a complete configuration, we race so that we don't wait for all trackers to respond
        const result1 = await raceUntil(requests, undefined, (val)=>{
            if ((val == null ? void 0 : val.res) === undefined) return false;
            return (0, _core.universal).genericCoderFor(val.res.version).config.isComplete(val.res);
        });
        if (result1 != null && result1.res) {
            // Skip saving the config to the tracker that returned the result
            this.saveWalletConfig({
                config: result1.res,
                skipTracker: result1.i
            });
            return result1.res;
        }
        // If we haven't found a complete configuration yet, it either means that the configuration is not complete
        // (and thus we need to combine all results) or that the configuration is not found at all
        // but we try to combine all results anyway
        const tmptracker = new LocalConfigTracker(undefined); // TODO: Fix this, provider not needed anyway
        const results = await allSafe(requests, undefined);
        for (const r of results)if (r != null && r.res) await tmptracker.saveWalletConfig({
            config: r.res
        });
        const result2 = await tmptracker.configOfImageHash(args);
        if (result2) this.saveWalletConfig({
            config: result2
        });
        return result2;
    }
    async saveWalletConfig(args) {
        await Promise.all(this.trackers.map((t, i)=>{
            if (i === args.skipTracker) return;
            return t.saveWalletConfig(args);
        }));
    }
    async imageHashOfCounterfactualWallet(args) {
        const imageHash = await raceUntil(this.trackers.map((t)=>t.imageHashOfCounterfactualWallet(args)), undefined, (result)=>Boolean(result));
        if (imageHash) this.configOfImageHash({
            imageHash: imageHash.imageHash
        }).then((config)=>{
            if (config) this.saveCounterfactualWallet({
                config,
                context: [
                    imageHash.context
                ]
            });
        });
        return imageHash;
    }
    async saveCounterfactualWallet(args) {
        await Promise.all(this.trackers.map((t, i)=>{
            if (i === args.skipTracker) return;
            return t.saveCounterfactualWallet(args);
        }));
    }
    async walletsOfSigner(args) {
        // We can't race here, because there is no "correct" response
        // we just return the union of all results, skipping duplicates
        const results = await allSafe(this.trackers.map((t)=>t.walletsOfSigner(args)), []).then((r)=>r.flat());
        const wallets = {};
        for (const r of results)wallets[r.wallet] = r.proof;
        // TODO: This will send redundant information back to the trackers
        // consider optimizing this for better performance during login
        const result = Object.keys(wallets).map((w)=>({
                wallet: w,
                proof: wallets[w]
            }));
        const witnesses = new Map();
        result.forEach(({ wallet, proof: { digest, chainId, signature } })=>{
            const key = `${wallet}-${digest}-${chainId}`;
            let signatures = witnesses.get(key);
            if (!signatures) {
                signatures = {
                    wallet,
                    digest,
                    chainId,
                    signatures: []
                };
                witnesses.set(key, signatures);
            }
            signatures.signatures.push(signature);
        });
        witnesses.forEach((witnesses)=>this.saveWitnesses(witnesses));
        return result;
    }
    async saveWitnesses(args) {
        await Promise.all(this.trackers.map((t)=>t.saveWitnesses(args)));
    }
    async loadPresignedConfiguration(args) {
        var _this = this;
        // We can't race here, because any of the trackers could have a new "link" in the chain
        const results = await allSafe(this.trackers.map((t)=>t.loadPresignedConfiguration(args)), []);
        // The "best" result is the one with the highest checkpoint
        const checkpoints = await allSafe(results.map(async function(r) {
            const last = r[r.length - 1];
            // TODO: This will fire a lot of requests, optimize it
            const config = await _this.configOfImageHash({
                imageHash: last.nextImageHash
            });
            if (!config) return undefined;
            return {
                checkpoint: (0, _core.universal).genericCoderFor(config.version).config.checkpointOf(config),
                result: r
            };
        }), undefined);
        const best = checkpoints.reduce((acc, val)=>{
            if (!val) return acc;
            if (!acc) return val;
            if (val.checkpoint.gt(acc.checkpoint)) return val;
            return acc;
        });
        if (!best) return [];
        const configs = new Map();
        const config = (imageHash)=>{
            if (!configs.has(imageHash)) configs.set(imageHash, this.configOfImageHash({
                imageHash
            }));
            return configs.get(imageHash);
        };
        best.result.forEach(async function(res) {
            const nextConfig = await config(res.nextImageHash);
            if (nextConfig) _this.savePresignedConfiguration({
                wallet: args.wallet,
                nextConfig,
                signature: res.signature
            });
        });
        return best.result;
    }
    async savePresignedConfiguration(args) {
        await Promise.all(this.trackers.map((t)=>t.savePresignedConfiguration(args)));
    }
    async getMigration(address, fromImageHash, fromVersion, chainId) {
        // TODO: Backfeed migration results to other trackers
        const results = await Promise.all(this.trackers.map((t)=>t.getMigration(address, fromImageHash, fromVersion, chainId)));
        return results.find((r)=>!!r);
    }
    async saveMigration(address, signed, contexts) {
        await Promise.all(this.trackers.map((t)=>t.saveMigration(address, signed, contexts)));
    }
}
class CachedTracker {
    constructor(tracker, cache, contexts){
        this.tracker = tracker;
        this.cache = cache;
        this.contexts = contexts;
    }
    async loadPresignedConfiguration(args) {
        var _this = this;
        // We need to check both, and return the one with the highest checkpoint
        // eventually we could try to combine them, but for now we'll just return
        // the one with the highest checkpoint
        const results = [
            this.tracker.loadPresignedConfiguration(args),
            this.cache.loadPresignedConfiguration(args)
        ];
        let best;
        // If both results end with the same image hash, we can just return the longest/shortest one
        const [result1, result2] = await Promise.all(results);
        if (result1.length > 0 && result2.length > 0 && result1[result1.length - 1].nextImageHash === result2[result2.length - 1].nextImageHash) best = args.longestPath === true ? result1.length > result2.length ? result1 : result2 : result1.length < result2.length ? result1 : result2;
        else {
            var _checkpoints$reduce$r, _checkpoints$reduce;
            // Otherwise we need to check the checkpoints
            // this requires us to fetch the config for each image hash
            const checkpoints = await Promise.all(results.map(async function(result) {
                const r = await result;
                const last = r[r.length - 1];
                if (!last) return undefined;
                // TODO: This will fire a lot of requests, optimize it
                const config = await _this.configOfImageHash({
                    imageHash: last.nextImageHash
                });
                if (!config) return undefined;
                return {
                    checkpoint: (0, _core.universal).genericCoderFor(config.version).config.checkpointOf(config),
                    result: r
                };
            }));
            best = (_checkpoints$reduce$r = (_checkpoints$reduce = checkpoints.reduce((acc, val)=>{
                if (!val) return acc;
                if (!acc) return val;
                if (val.checkpoint.gt(acc.checkpoint)) return val;
                return acc;
            })) == null ? void 0 : _checkpoints$reduce.result) != null ? _checkpoints$reduce$r : [];
        }
        if (!best) return [];
        return best;
    }
    async savePresignedConfiguration(args) {
        await Promise.all([
            this.tracker.savePresignedConfiguration(args),
            this.cache.savePresignedConfiguration(args)
        ]);
    }
    async configOfImageHash(args) {
        // We first check the cache, if it's not there, we check the tracker
        // and then we save it to the cache
        if (args.noCache !== true) {
            const config = await this.cache.configOfImageHash(args);
            if (config) return config;
        }
        const config2 = await this.tracker.configOfImageHash(args);
        if (config2) await this.cache.saveWalletConfig({
            config: config2
        });
        return config2;
    }
    async saveWalletConfig(args) {
        await Promise.all([
            this.tracker.saveWalletConfig(args),
            this.cache.saveWalletConfig(args)
        ]);
    }
    async imageHashOfCounterfactualWallet(args) {
        // We first check the cache, if it's not there, we check the tracker
        // and then we save it to the cache
        if (args.noCache !== true) {
            const result1 = await this.cache.imageHashOfCounterfactualWallet(args);
            if (result1) return result1;
        }
        const result2 = await this.tracker.imageHashOfCounterfactualWallet(args);
        if (result2) {
            // TODO: We shouldn't need to get the config to save the counterfactual wallet
            const config = await this.configOfImageHash({
                imageHash: result2.imageHash
            });
            if (config) await this.cache.saveCounterfactualWallet({
                config,
                context: [
                    result2.context
                ]
            });
        }
        return result2;
    }
    async saveCounterfactualWallet(args) {
        await Promise.all([
            this.tracker.saveCounterfactualWallet(args),
            this.cache.saveCounterfactualWallet(args)
        ]);
    }
    async walletsOfSigner(args) {
        if (args.noCache) return this.tracker.walletsOfSigner(args);
        // In this case we need to both aggregate the results from the cache and the tracker
        // and then dedupe the results
        const results = await Promise.all([
            this.tracker.walletsOfSigner(args),
            this.cache.walletsOfSigner(args)
        ]);
        const wallets = new Map();
        for (const result of results)for (const wallet of result)wallets.set(wallet.wallet, wallet);
        return Array.from(wallets.values());
    }
    async saveWitnesses(args) {
        await Promise.all([
            this.tracker.saveWitnesses(args),
            this.cache.saveWitnesses(args)
        ]);
    }
    async getMigration(address, fromImageHash, fromVersion, chainId) {
        // We first check the cache, if it's not there, we check the tracker
        // NOTICE: we could eventually try to combine the two, but now we just have 1 migration
        // so it's not worth it.
        const migration1 = await this.cache.getMigration(address, fromImageHash, fromVersion, chainId);
        if (migration1) return migration1;
        const migration2 = await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId);
        if (migration2) await this.cache.saveMigration(address, migration2, this.contexts);
        return migration2;
    }
    async saveMigration(address, signed, contexts) {
        await Promise.all([
            this.tracker.saveMigration(address, signed, contexts),
            this.cache.saveMigration(address, signed, contexts)
        ]);
    }
}
class PromiseCache {
    constructor(){
        this.cache = void 0;
        this.cache = new Map();
    }
    do(key, validMilliseconds, task, ...args) {
        key = `${key}:${(0, _ethers.ethers).utils.keccak256((0, _ethers.ethers).utils.toUtf8Bytes(JSON.stringify(args, deterministically)))}`;
        let entry = this.cache.get(key);
        if (entry) {
            if (entry.expiration) {
                if (new Date() >= entry.expiration) {
                    entry = undefined;
                    this.cache.delete(key);
                }
            }
        }
        if (!entry) {
            const entry_ = {
                promise: task(...args)
            };
            if (validMilliseconds !== undefined) entry_.promise = entry_.promise.then((result)=>{
                entry_.expiration = new Date(Date.now() + validMilliseconds);
                return result;
            });
            entry = entry_;
            this.cache.set(key, entry);
        }
        return entry.promise;
    }
}
function deterministically(_key, value) {
    if (typeof value === "object" && value !== null && !Array.isArray(value)) return Object.fromEntries(Object.entries(value).sort());
    return value;
}
function isDedupedTracker(tracker) {
    return tracker instanceof DedupedTracker;
}
// This tracks wraps another tracker and dedupes calls to it, so in any calls
// are sent in short succession, only the first call is forwarded to the
// underlying tracker, and the rest are ignored.
class DedupedTracker {
    constructor(tracker, window = 50, verbose = false){
        this.tracker = tracker;
        this.window = window;
        this.verbose = verbose;
        this.cache = new PromiseCache();
    }
    invalidateCache() {
        this.cache = new PromiseCache();
    }
    configOfImageHash(args) {
        return this.cache.do("configOfImageHash", this.window, (args)=>this.tracker.configOfImageHash(args), args);
    }
    getMigration(address, fromImageHash, fromVersion, chainId) {
        return this.cache.do("getMigration", this.window, (...args)=>this.tracker.getMigration(...args), address, fromImageHash, fromVersion, chainId);
    }
    saveMigration(address, signed, contexts) {
        return this.cache.do("saveMigration", undefined, (...args)=>this.tracker.saveMigration(...args), address, signed, contexts);
    }
    loadPresignedConfiguration(args) {
        return this.cache.do("loadPresignedConfiguration", this.window, (args)=>this.tracker.loadPresignedConfiguration(args), args);
    }
    savePresignedConfiguration(args) {
        return this.cache.do("savePresignedConfiguration", undefined, (args)=>this.tracker.savePresignedConfiguration(args), args);
    }
    saveWitnesses(args) {
        return this.cache.do("saveWitnesses", undefined, (args)=>this.tracker.saveWitnesses(args), args);
    }
    saveWalletConfig(args) {
        return this.cache.do("saveWalletConfig", undefined, (args)=>this.tracker.saveWalletConfig(args), args);
    }
    imageHashOfCounterfactualWallet(args) {
        return this.cache.do("imageHashOfCounterfactualWallet", undefined, (args)=>this.tracker.imageHashOfCounterfactualWallet(args), args);
    }
    saveCounterfactualWallet(args) {
        return this.cache.do("saveCounterfactualWallet", undefined, (args)=>this.tracker.saveCounterfactualWallet(args), args);
    }
    walletsOfSigner(args) {
        return this.cache.do("walletsOfSigner", this.window, (args)=>this.tracker.walletsOfSigner(args), args);
    }
    updateProvider(provider) {
        if (this.tracker instanceof LocalConfigTracker) this.tracker.updateProvider(provider);
    }
}
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    debug: debug$1,
    local: local,
    remote: index$1,
    stores: index$2,
    raceUntil: raceUntil,
    allSafe: allSafe,
    MultipleTracker: MultipleTracker,
    CachedTracker: CachedTracker,
    isDedupedTracker: isDedupedTracker,
    DedupedTracker: DedupedTracker
});

},{"@0xsequence/core":"cIuGJ","@0xsequence/migration":"l6xLq","ethers":"hdHML","@0xsequence/replacer":"4RR3E","idb":"kozAz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4RR3E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CachedEIP5719", ()=>CachedEIP5719);
parcelHelpers.export(exports, "URISolverIPFS", ()=>URISolverIPFS);
parcelHelpers.export(exports, "eip1271Contract", ()=>eip1271Contract);
parcelHelpers.export(exports, "eip5719Contract", ()=>eip5719Contract);
parcelHelpers.export(exports, "isValidSignature", ()=>isValidSignature);
parcelHelpers.export(exports, "runByEIP5719", ()=>runByEIP5719);
var _ethers = require("ethers");
var _abi = require("@0xsequence/abi");
var _core = require("@0xsequence/core");
function useGateway(uri, gateway) {
    const clean = uri.replace("ipfs://ipfs/", "").replace("ipfs://", "");
    if (uri.startsWith("ipfs://")) return `${gateway}${clean}`;
    return uri;
}
function isIPFS(uri) {
    return uri.startsWith("ipfs://");
}
class CachedEIP5719 {
    constructor(provider, solver, window = 1000){
        this.provider = provider;
        this.solver = solver;
        this.window = window;
        this.pending = new Map();
    }
    async runByEIP5719(address, digest, signature) {
        const key = `${address}-${digest}-${signature}`;
        const now = Date.now();
        if (this.pending.has(key) && now - this.pending.get(key).timestamp < this.window) return this.pending.get(key).promise;
        const promise = runByEIP5719(address, this.provider, digest, signature, this.solver);
        this.pending.set(key, {
            timestamp: now,
            promise
        });
        return promise;
    }
}
function eip5719Contract(address, provider) {
    // TODO: for some reason walletContracts is not being loaded from local
    // remove this code once fixed
    const abi = [
        {
            inputs: [
                {
                    internalType: "bytes32",
                    type: "bytes32"
                }
            ],
            name: "getAlternativeSignature",
            outputs: [
                {
                    internalType: "string",
                    type: "string"
                }
            ],
            stateMutability: "view",
            type: "function"
        }
    ];
    return new (0, _ethers.ethers).Contract(address, abi, provider);
}
function eip1271Contract(address, provider) {
    return new (0, _ethers.ethers).Contract(address, (0, _abi.walletContracts).erc1271.abi, provider);
}
async function isValidSignature(address, provider, digest, signature) {
    // First we try to validate the signature using Ethers
    try {
        const addr = (0, _ethers.ethers).utils.recoverAddress(digest, signature);
        if (addr.toLowerCase() === address.toLowerCase()) return true;
    } catch (_unused) {}
    // Then we try to validate the signature using EIP1271
    try {
        const contract = eip1271Contract(address, provider);
        const value = await contract.isValidSignature(digest, signature);
        if (value === (0, _abi.walletContracts).erc1271.returns) return true;
    } catch (_unused2) {}
    // If all else fails, we return false
    return false;
}
async function tryAwait(promise) {
    try {
        return await promise;
    } catch (_unused3) {
        return undefined;
    }
}
async function runByEIP5719(address, provider, digest, signature, solver, tries = 0) {
    if (tries > 10) throw new Error("EIP5719 - Too many tries");
    if ((0, _core.commons).signer.canRecover(signature)) {
        const recoveredAddr = (0, _core.commons).signer.recoverSigner(digest, signature);
        if (recoveredAddr && recoveredAddr.toLowerCase() === address.toLowerCase()) return signature;
    }
    try {
        if (await (0, _core.commons).signer.isValidSignature(address, digest, signature, provider)) return signature;
    } catch (_unused4) {}
    const altUri = await tryAwait(eip5719Contract(address, provider).getAlternativeSignature(digest));
    if (!altUri || altUri === "") throw new Error("EIP5719 - Invalid signature and no alternative signature");
    const altSignature = (0, _ethers.ethers).utils.hexlify(await (solver || new URISolverIPFS()).resolve(altUri));
    if (!altSignature || altSignature === "") throw new Error("EIP5719 - Empty alternative signature");
    if (altSignature === (0, _ethers.ethers).utils.hexlify(signature)) throw new Error("EIP5719 - Alternative signature is invalid or the same");
    return runByEIP5719(address, provider, digest, altSignature, solver, tries + 1);
}
class URISolverIPFS {
    constructor(gateway = "https://cloudflare-ipfs.com/ipfs/"){
        var _this = this;
        this.gateway = gateway;
        this.uri = (uri)=>{
            if (isIPFS(uri)) return useGateway(uri, this.gateway);
            return uri;
        };
        this.resolve = async function(uri) {
            const url = _this.uri(uri);
            const res = await fetch(url);
            if (!res.ok) throw new Error(`URISolverIPFS - Failed to fetch ${url}`);
            return await res.text();
        };
    }
}

},{"ethers":"hdHML","@0xsequence/abi":"hbXMf","@0xsequence/core":"cIuGJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9AD2Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthMethod", ()=>AuthMethod);
parcelHelpers.export(exports, "GuardSigner", ()=>GuardSigner);
parcelHelpers.export(exports, "getAuthUpdateProofTypedData", ()=>getAuthUpdateProofTypedData);
parcelHelpers.export(exports, "getOwnershipProofTypedData", ()=>getOwnershipProofTypedData);
var _core = require("@0xsequence/core");
var _signhub = require("@0xsequence/signhub");
var _utils = require("@0xsequence/utils");
var _ethers = require("ethers");
var global = arguments[3];
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
//
// Types
//
//
// Client
//
class Guard {
    constructor(hostname, fetch){
        this.hostname = void 0;
        this.fetch = void 0;
        this.path = "/rpc/Guard/";
        this.ping = (headers)=>{
            return this.fetch(this.url("Ping"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.version = (headers)=>{
            return this.fetch(this.url("Version"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        version: _data.version
                    };
                });
            });
        };
        this.runtimeStatus = (headers)=>{
            return this.fetch(this.url("RuntimeStatus"), createHTTPRequest({}, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        status: _data.status
                    };
                });
            });
        };
        this.getSignerConfig = (args, headers)=>{
            return this.fetch(this.url("GetSignerConfig"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        signerConfig: _data.signerConfig
                    };
                });
            });
        };
        this.sign = (args, headers)=>{
            return this.fetch(this.url("Sign"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        sig: _data.sig
                    };
                });
            });
        };
        this.signWith = (args, headers)=>{
            return this.fetch(this.url("SignWith"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        sig: _data.sig
                    };
                });
            });
        };
        this.authMethods = (args, headers)=>{
            return this.fetch(this.url("AuthMethods"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        methods: _data.methods,
                        active: _data.active
                    };
                });
            });
        };
        this.setPIN = (args, headers)=>{
            return this.fetch(this.url("SetPIN"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.resetPIN = (args, headers)=>{
            return this.fetch(this.url("ResetPIN"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.createTOTP = (args, headers)=>{
            return this.fetch(this.url("CreateTOTP"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        uri: _data.uri
                    };
                });
            });
        };
        this.commitTOTP = (args, headers)=>{
            return this.fetch(this.url("CommitTOTP"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        codes: _data.codes
                    };
                });
            });
        };
        this.resetTOTP = (args, headers)=>{
            return this.fetch(this.url("ResetTOTP"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.reset2FA = (args, headers)=>{
            return this.fetch(this.url("Reset2FA"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {};
                });
            });
        };
        this.recoveryCodes = (args, headers)=>{
            return this.fetch(this.url("RecoveryCodes"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        codes: _data.codes
                    };
                });
            });
        };
        this.resetRecoveryCodes = (args, headers)=>{
            return this.fetch(this.url("ResetRecoveryCodes"), createHTTPRequest(args, headers)).then((res)=>{
                return buildResponse(res).then((_data)=>{
                    return {
                        codes: _data.codes
                    };
                });
            });
        };
        this.hostname = hostname;
        this.fetch = (input, init)=>fetch(input, init);
    }
    url(name) {
        return this.hostname + this.path + name;
    }
}
const createHTTPRequest = (body = {}, headers = {})=>{
    return {
        method: "POST",
        headers: _extends({}, headers, {
            "Content-Type": "application/json"
        }),
        body: JSON.stringify(body || {})
    };
};
const buildResponse = (res)=>{
    return res.text().then((text)=>{
        let data;
        try {
            data = JSON.parse(text);
        } catch (err) {
            throw {
                code: "unknown",
                msg: `expecting JSON, got: ${text}`,
                status: res.status
            };
        }
        if (!res.ok) throw data; // webrpc error response
        return data;
    });
};
const fetch = typeof global === "object" ? global.fetch : window.fetch;
class GuardSigner {
    constructor(address, url, appendSuffix = false){
        this.address = address;
        this.url = url;
        this.appendSuffix = appendSuffix;
        this.guard = void 0;
        this.guard = new Guard(url, fetch);
    }
    async getAddress() {
        return this.address;
    }
    async buildDeployTransaction(_metadata) {
        return undefined;
    }
    async predecorateSignedTransactions(_metadata) {
        return [];
    }
    async decorateTransactions(bundle, _metadata) {
        return bundle;
    }
    async sign(message, metadata) {
        var _metadata$parts;
        if (!(0, _core.commons).isWalletSignRequestMetadata(metadata)) throw new Error("expected sequence signature request metadata");
        const guardTotpCode = metadata.guardTotpCode;
        // Building auxData, notice: this uses the old v1 format
        // TODO: We should update the guard API so we can pass the metadata directly
        const coder = (0, _core.universal).genericCoderFor(metadata.config.version);
        const { encoded } = coder.signature.encodeSigners(metadata.config, (_metadata$parts = metadata.parts) != null ? _metadata$parts : new Map(), [], metadata.chainId);
        return (await this.guard.signWith({
            signer: this.address,
            request: {
                msg: (0, _ethers.ethers).utils.hexlify(message),
                auxData: this.packMsgAndSig(metadata.address, metadata.digest, encoded, metadata.chainId),
                chainId: (0, _ethers.ethers).BigNumber.from(metadata.chainId).toNumber()
            },
            token: guardTotpCode ? {
                id: AuthMethod.TOTP,
                token: guardTotpCode
            } : undefined
        })).sig;
    }
    notifyStatusChange(_id, _status, _metadata) {}
    async getAuthMethods(proof) {
        let response;
        if ("jwt" in proof) response = await this.guard.authMethods({}, {
            Authorization: `BEARER ${proof.jwt}`
        });
        else {
            const signedProof = await signOwnershipProof(proof);
            response = await this.guard.authMethods({
                proof: {
                    wallet: signedProof.walletAddress,
                    timestamp: signedProof.timestamp.getTime(),
                    signer: signedProof.signerAddress,
                    signature: signedProof.signature
                }
            });
        }
        return _extends({}, response, {
            methods: response.methods.map(parseAuthMethod)
        });
    }
    async setPin(pin, proof) {
        const signedProof = await signAuthUpdateProof(proof);
        if (pin === undefined) await this.guard.resetPIN({
            timestamp: signedProof.timestamp.getTime(),
            signature: signedProof.signature
        }, {
            Authorization: `BEARER ${proof.jwt}`
        });
        else await this.guard.setPIN({
            pin,
            timestamp: signedProof.timestamp.getTime(),
            signature: signedProof.signature
        }, {
            Authorization: `BEARER ${proof.jwt}`
        });
    }
    resetPin(proof) {
        return this.setPin(undefined, proof);
    }
    async createTotp(proof) {
        const signedProof = await signAuthUpdateProof(proof);
        const { uri } = await this.guard.createTOTP({
            timestamp: signedProof.timestamp.getTime(),
            signature: signedProof.signature
        }, {
            Authorization: `BEARER ${proof.jwt}`
        });
        return new URL(uri);
    }
    async commitTotp(token, jwt) {
        const { codes } = await this.guard.commitTOTP({
            token
        }, {
            Authorization: `BEARER ${jwt}`
        });
        return codes;
    }
    async resetTotp(proof) {
        const signedProof = await signAuthUpdateProof(proof);
        await this.guard.resetTOTP({
            timestamp: signedProof.timestamp.getTime(),
            signature: signedProof.signature
        }, {
            Authorization: `BEARER ${proof.jwt}`
        });
    }
    async reset2fa(recoveryCode, proof) {
        if ("jwt" in proof) await this.guard.reset2FA({
            code: recoveryCode
        }, {
            Authorization: `BEARER ${proof.jwt}`
        });
        else {
            const signedProof = await signOwnershipProof(proof);
            await this.guard.reset2FA({
                code: recoveryCode,
                proof: {
                    wallet: signedProof.walletAddress,
                    timestamp: signedProof.timestamp.getTime(),
                    signer: signedProof.signerAddress,
                    signature: signedProof.signature
                }
            });
        }
    }
    async getRecoveryCodes(proof) {
        const signedProof = await signAuthUpdateProof(proof);
        const { codes } = await this.guard.recoveryCodes({
            timestamp: signedProof.timestamp.getTime(),
            signature: signedProof.signature
        }, {
            Authorization: `BEARER ${proof.jwt}`
        });
        return codes;
    }
    async resetRecoveryCodes(proof) {
        const signedProof = await signAuthUpdateProof(proof);
        const { codes } = await this.guard.resetRecoveryCodes({
            timestamp: signedProof.timestamp.getTime(),
            signature: signedProof.signature
        }, {
            Authorization: `BEARER ${proof.jwt}`
        });
        return codes;
    }
    packMsgAndSig(address, msg, sig, chainId) {
        return (0, _ethers.ethers).utils.defaultAbiCoder.encode([
            "address",
            "uint256",
            "bytes",
            "bytes"
        ], [
            address,
            chainId,
            msg,
            sig
        ]);
    }
    suffix() {
        return this.appendSuffix ? [
            3
        ] : [];
    }
}
let AuthMethod = /*#__PURE__*/ function(AuthMethod) {
    AuthMethod["PIN"] = "PIN";
    AuthMethod["TOTP"] = "TOTP";
    return AuthMethod;
}({});
function parseAuthMethod(method) {
    switch(method){
        case AuthMethod.PIN:
        case AuthMethod.TOTP:
            return method;
        default:
            throw new Error(`unknown auth method '${method}'`);
    }
}
function isSignedOwnershipProof(proof) {
    return "signerAddress" in proof && typeof proof.signerAddress === "string";
}
async function signOwnershipProof(proof) {
    if (isSignedOwnershipProof(proof)) return proof;
    else {
        const signer = (0, _signhub.signers).isSapientSigner(proof.signer) ? proof.signer : new (0, _signhub.signers).SignerWrapper(proof.signer);
        const signerAddress = await signer.getAddress();
        const timestamp = new Date();
        const typedData = getOwnershipProofTypedData(proof.walletAddress, timestamp);
        const digest = (0, _utils.encodeTypedDataDigest)(typedData);
        return {
            walletAddress: proof.walletAddress,
            timestamp,
            signerAddress,
            signature: (0, _ethers.ethers).utils.hexlify(await signer.sign(digest, {}))
        };
    }
}
async function signAuthUpdateProof(proof) {
    if ("wallet" in proof) {
        var _typedData$domain$cha;
        const timestamp = new Date();
        const typedData = getAuthUpdateProofTypedData(timestamp);
        const signature = await proof.wallet.signTypedData(typedData.domain, typedData.types, typedData.message, (_typedData$domain$cha = typedData.domain.chainId) != null ? _typedData$domain$cha : 1, "eip6492");
        return {
            jwt: proof.jwt,
            timestamp,
            signature
        };
    } else return proof;
}
function getOwnershipProofTypedData(wallet, timestamp) {
    return {
        domain,
        types: {
            AuthMethods: [
                {
                    name: "wallet",
                    type: "address"
                },
                {
                    name: "timestamp",
                    type: "string"
                }
            ]
        },
        message: {
            wallet: (0, _ethers.ethers).utils.getAddress(wallet),
            timestamp: toUTCString(timestamp)
        }
    };
}
function getAuthUpdateProofTypedData(timestamp) {
    return {
        domain,
        types: {
            AuthUpdate: [
                {
                    name: "timestamp",
                    type: "string"
                }
            ]
        },
        message: {
            timestamp: toUTCString(timestamp)
        }
    };
}
const domain = {
    name: "Sequence Guard",
    version: "1",
    chainId: 1
};
function toUTCString(date) {
    return date.toUTCString().replace("GMT", "UTC");
}

},{"@0xsequence/core":"cIuGJ","@0xsequence/signhub":"jyR3Z","@0xsequence/utils":"7jY5X","ethers":"hdHML","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7BTRB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Multicall", ()=>Multicall);
parcelHelpers.export(exports, "providers", ()=>index);
var _ethers = require("ethers");
var _abi = require("@0xsequence/abi");
var _utils = require("@0xsequence/utils");
var _network = require("@0xsequence/network");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
let JsonRpcMethod = /*#__PURE__*/ function(JsonRpcMethod) {
    JsonRpcMethod["ethCall"] = "eth_call";
    JsonRpcMethod["ethGetBalance"] = "eth_getBalance";
    JsonRpcMethod["ethGetCode"] = "eth_getCode";
    return JsonRpcMethod;
}({});
async function safeSolve(promise, def) {
    try {
        return await promise;
    } catch (e) {
        const d = def instanceof Function ? def(e) : def;
        return d;
    }
}
function partition(array, callback) {
    return array.reduce(function(result, element, i) {
        callback(element, i) ? result[0].push(element) : result[1].push(element);
        return result;
    }, [
        [],
        []
    ]);
}
function parseBlockTag(cand) {
    if (cand === undefined) return "latest";
    switch(cand){
        case "earliest":
        case "latest":
        case "pending":
            return cand;
    }
    return (0, _ethers.BigNumber).from(cand);
}
function eqBlockTag(a, b) {
    if (a === b) return true;
    if ((0, _ethers.BigNumber).isBigNumber(a)) {
        if ((0, _ethers.BigNumber).isBigNumber(b)) return a.eq(b);
        return false;
    }
    if ((0, _ethers.BigNumber).isBigNumber(b)) return false;
    return a === b;
}
const DefaultMulticallOptions = {
    batchSize: 50,
    timeWindow: 50,
    // SequenceUtils: v2
    contract: "0xdbbFa3cB3B087B64F4ef5E3D20Dda2488AA244e6",
    verbose: false
};
class Multicall {
    constructor(options){
        var _this = this;
        this.batchableJsonRpcMethods = [
            JsonRpcMethod.ethCall,
            JsonRpcMethod.ethGetCode,
            JsonRpcMethod.ethGetBalance
        ];
        this.multicallInterface = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).sequenceUtils.abi);
        this.options = void 0;
        this.timeout = void 0;
        this.queue = [];
        this.scheduleExecution = ()=>{
            if (this.queue.length > 0) {
                if (this.timeout) clearTimeout(this.timeout);
                this.timeout = setTimeout(this.run, this.options.timeWindow);
            }
        };
        this.handle = (next, request, callback)=>{
            // Schedule for batching and return
            if (this.batchableJsonRpcMethods.find((m)=>m === request.method)) {
                this.queue.push({
                    request: request,
                    callback: callback,
                    next: next
                });
                if (this.options.verbose) console.log("Scheduling call", request.method);
                this.scheduleExecution();
                return;
            }
            if (this.options.verbose) console.log("Forwarded call", request.method);
            // Move to next handler
            return next(request, callback);
        };
        this.run = async function() {
            /* eslint-disable no-var */ if (_this.options.verbose) console.log("Processing multicall");
            // Read items from queue
            const limit = Math.min(_this.options.batchSize, _this.queue.length);
            if (limit === 0) {
                if (_this.options.verbose) console.log("Skip multicall, empty queue");
                return;
            }
            // Skip multicall on single item
            if (limit === 1) {
                _this.forward(_this.queue[0]);
                _this.queue = [];
                if (_this.options.verbose) console.log("Skip multicall, single item");
                return;
            }
            if (_this.options.verbose) console.log("Resolving", limit);
            // Get batch from queue
            var items = _this.queue.slice(0, limit);
            // Update queue
            _this.queue = limit === _this.queue.length ? [] : _this.queue.slice(limit);
            if (_this.options.verbose) console.log("Updated queue", _this.queue.length);
            if (_this.queue.length !== 0) {
                if (_this.options.verbose) console.log("Scheduling next batch");
                _this.scheduleExecution();
            }
            // Get next candidate
            const next = items[0].next;
            let blockTag;
            // Partition incompatible calls
            var [items, discartItems] = partition(items, (item)=>{
                try {
                    // Mixed next callbacks
                    if (item.next !== next) return false;
                    switch(item.request.method){
                        case JsonRpcMethod.ethCall:
                            // Unsupported eth_call parameters
                            if (item.request.params[0].from || item.request.params[0].gasPrice || item.request.params[0].value) return false;
                        case JsonRpcMethod.ethGetBalance:
                        case JsonRpcMethod.ethGetCode:
                            // Mixed blockTags
                            const itemBlockTag = parseBlockTag(item.request.params[1]);
                            if (blockTag === undefined) blockTag = itemBlockTag;
                            if (!eqBlockTag(itemBlockTag, blockTag)) return false;
                    }
                    return true;
                } catch (_unused) {
                    return false;
                }
            });
            // Forward discarted items
            // end execution if no items remain
            if (discartItems.length !== 0) {
                if (_this.options.verbose) console.log("Forwarding incompatible calls", discartItems.length);
                _this.forward(discartItems);
                if (items.length === 0) {
                    if (_this.options.verbose) console.log("Skip multicall, all calls are incompatible");
                    return;
                }
            }
            // Aggregate all calls
            let callParams = items.map((v)=>{
                try {
                    switch(v.request.method){
                        case JsonRpcMethod.ethCall:
                            return {
                                delegateCall: false,
                                revertOnError: false,
                                target: v.request.params[0].to,
                                data: v.request.params[0].data,
                                gasLimit: v.request.params[0].gas ? v.request.params[0].gas : 0,
                                value: 0
                            };
                        case JsonRpcMethod.ethGetCode:
                            return {
                                delegateCall: false,
                                revertOnError: false,
                                target: _this.options.contract,
                                gasLimit: 0,
                                value: 0,
                                data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction("callCode"), [
                                    v.request.params[0]
                                ])
                            };
                        case JsonRpcMethod.ethGetBalance:
                            return {
                                delegateCall: false,
                                revertOnError: false,
                                target: _this.options.contract,
                                gasLimit: 0,
                                value: 0,
                                data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction("callBalanceOf"), [
                                    v.request.params[0]
                                ])
                            };
                        default:
                            return null;
                    }
                } catch (_unused2) {
                    return null;
                }
            });
            // Filter calls with enconding errors and forward items
            var [items, discartItems] = partition(items, (_, i)=>callParams[i] !== undefined);
            callParams = callParams.filter((c)=>c);
            if (discartItems.length !== 0) {
                if (_this.options.verbose) console.log("Forwarding calls on error", discartItems.length);
                _this.forward(discartItems);
                if (items.length === 0) {
                    if (_this.options.verbose) console.log("Skip multicall, all calls had encoding errors");
                    return;
                }
            }
            // Encode multicall
            let encodedCall;
            try {
                if (_this.options.verbose) console.log("Encoding multicall");
                encodedCall = _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction("multiCall"), [
                    callParams
                ]);
            } catch (err) {
                if (_this.options.verbose) console.warn("Error encoding multicall, forwarding one by one", err);
                _this.forward(items);
                return;
            }
            // Forward single multicall rpc call
            const reqId = (0, _utils.getRandomInt)();
            // TODO: fix types below..
            const res = await safeSolve(// @ts-ignore
            (0, _utils.promisify)(next)({
                id: reqId,
                jsonrpc: (0, _network.JsonRpcVersion),
                method: JsonRpcMethod.ethCall,
                params: [
                    {
                        to: _this.options.contract,
                        value: 0,
                        data: encodedCall
                    },
                    (0, _ethers.BigNumber).isBigNumber(blockTag) ? blockTag.toNumber() : blockTag
                ]
            }), (e)=>({
                    jsonrpc: (0, _network.JsonRpcVersion),
                    id: reqId,
                    result: undefined,
                    error: e
                }));
            // Error calling multicall
            // Forward all calls to middleware
            // @ts-ignore
            if (res.error) {
                if (_this.options.verbose) console.warn("Error calling multicall, forwarding one by one", res.error);
                return _this.forward(items);
            }
            // Decode result from multicall
            let decoded;
            try {
                // @ts-ignore
                decoded = _this.multicallInterface.decodeFunctionResult(_this.multicallInterface.getFunction("multiCall"), res.result);
            } catch (err) {
                if (_this.options.verbose) console.warn("Error decoding multicall result, forwarding one by one", err);
                _this.forward(items);
                return;
            }
            // Send results for each request
            // errors fallback through the middleware
            if (_this.options.verbose) console.log("Got response for", items.length);
            items.forEach((item, index)=>{
                if (!decoded[0][index]) {
                    if (_this.options.verbose) console.warn(`Multicall error for ${item.request.method} not found`);
                    _this.forward(item);
                } else switch(item.request.method){
                    case JsonRpcMethod.ethCall:
                        item.callback(undefined, {
                            jsonrpc: item.request.jsonrpc,
                            id: item.request.id,
                            result: decoded[1][index]
                        });
                        break;
                    case JsonRpcMethod.ethGetCode:
                        item.callback(undefined, {
                            jsonrpc: item.request.jsonrpc,
                            id: item.request.id,
                            result: (0, _ethers.ethers).utils.defaultAbiCoder.decode([
                                "bytes"
                            ], decoded[1][index])[0]
                        });
                        break;
                    case JsonRpcMethod.ethGetBalance:
                        item.callback(undefined, {
                            jsonrpc: item.request.jsonrpc,
                            id: item.request.id,
                            result: (0, _ethers.ethers).utils.defaultAbiCoder.decode([
                                "uint256"
                            ], decoded[1][index])[0]
                        });
                        break;
                }
            });
        };
        this.options = options ? _extends({}, Multicall.DefaultOptions, options) : Multicall.DefaultOptions;
        if (this.options.batchSize <= 0) throw new Error(`Invalid batch size of ${this.options.batchSize}`);
    }
    forward(entries) {
        if (Array.isArray(entries)) entries.forEach((e)=>e.next(e.request, e.callback));
        else entries.next(entries.request, entries.callback);
    }
    static isMulticall(cand) {
        return cand && cand.handle !== undefined && cand.conf !== undefined && Multicall.isMulticallOptions(cand.options);
    }
    static isMulticallOptions(cand) {
        return cand !== undefined && cand.batchSize !== undefined && cand.timeWindow !== undefined && cand.contract !== undefined;
    }
}
Multicall.DefaultOptions = _extends({}, DefaultMulticallOptions);
const ProxyMethods = [
    "getNetwork",
    "getBlockNumber",
    "getGasPrice",
    "getTransactionCount",
    "getStorageAt",
    "sendTransaction",
    "estimateGas",
    "getBlock",
    "getTransaction",
    "getTransactionReceipt",
    "getLogs",
    "emit",
    "litenerCount",
    "addListener",
    "removeListener",
    "waitForTransaction",
    "detectNetwork",
    "getBlockWithTransactions"
];
class MulticallProvider extends (0, _ethers.ethers).providers.BaseProvider {
    constructor(provider, multicall){
        var _this;
        super(provider.getNetwork());
        _this = this;
        this.provider = provider;
        this.multicall = void 0;
        this.getResolver = async function(name) {
            const provider = _this.provider;
            if (provider.getResolver) {
                const ogResolver = await provider.getResolver(await name);
                if (!ogResolver) return null;
                return new (0, _ethers.ethers).providers.Resolver(_this, ogResolver.address, ogResolver.name);
            }
            return provider.getResolver(await name);
        };
        this.next = async function(req, callback) {
            try {
                switch(req.method){
                    case JsonRpcMethod.ethCall:
                        _this.callback(req, callback, await _this.provider.call(req.params[0], req.params[1]));
                        break;
                    case JsonRpcMethod.ethGetCode:
                        _this.callback(req, callback, await _this.provider.getCode(req.params[0], req.params[1]));
                        break;
                    case JsonRpcMethod.ethGetBalance:
                        _this.callback(req, callback, await _this.provider.getBalance(req.params[0], req.params[1]));
                        break;
                }
            } catch (e) {
                _this.callback(req, callback, undefined, e);
            }
        };
        this.listenerCount = provider.listenerCount.bind(provider);
        this.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);
        ProxyMethods.forEach((m)=>{
            if (provider[m] !== undefined) this[m] = (...args)=>provider[m](...args);
        });
    }
    callback(req, callback, resp, err) {
        callback(err, {
            jsonrpc: (0, _network.JsonRpcVersion),
            id: req.id,
            result: resp,
            error: err
        });
    }
    async call(transaction, blockTag) {
        return this.rpcCall(JsonRpcMethod.ethCall, transaction, blockTag);
    }
    async getCode(addressOrName, blockTag) {
        return this.rpcCall(JsonRpcMethod.ethGetCode, addressOrName, blockTag);
    }
    async getBalance(addressOrName, blockTag) {
        return this.rpcCall(JsonRpcMethod.ethGetBalance, addressOrName, blockTag);
    }
    async rpcCall(method, ...params) {
        const reqId = (0, _utils.getRandomInt)();
        const resp = await (0, _utils.promisify)(this.multicall.handle)(this.next, {
            jsonrpc: (0, _network.JsonRpcVersion),
            id: reqId,
            method: method,
            params: params
        });
        return resp.result;
    }
}
class MulticallExternalProvider {
    constructor(provider, multicall){
        this.provider = provider;
        this.multicall = void 0;
        this.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);
        if (provider.send) {
            const next = async function next(req, callback) {
                provider.send(req, callback);
            };
            this.send = (request, callback)=>{
                this.multicall.handle(next, request, callback);
            };
        }
        if (provider.sendAsync) {
            const next = async function next(req, callback) {
                provider.sendAsync(req, callback);
            };
            this.sendAsync = (request, callback)=>{
                this.multicall.handle(next, request, callback);
            };
        }
    }
    get isMetaMask() {
        return this.provider.isMetaMask;
    }
    get isStatus() {
        return this.provider.isStatus;
    }
}
const multicallMiddleware = (multicall)=>(next)=>{
        const lib = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);
        return (request, callback)=>{
            return lib.handle(next, request, callback);
        };
    };
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ProxyMethods: ProxyMethods,
    MulticallProvider: MulticallProvider,
    MulticallExternalProvider: MulticallExternalProvider,
    multicallMiddleware: multicallMiddleware
});

},{"ethers":"hdHML","@0xsequence/abi":"hbXMf","@0xsequence/utils":"7jY5X","@0xsequence/network":"01lBM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1PHQ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseInjectedTransport", ()=>BaseInjectedTransport);
parcelHelpers.export(exports, "BaseProviderTransport", ()=>BaseProviderTransport);
parcelHelpers.export(exports, "BaseWalletTransport", ()=>BaseWalletTransport);
parcelHelpers.export(exports, "CHANNEL_ID", ()=>CHANNEL_ID);
parcelHelpers.export(exports, "DefaultChainIdTracker", ()=>DefaultChainIdTracker);
parcelHelpers.export(exports, "DefaultProviderConfig", ()=>DefaultProviderConfig);
parcelHelpers.export(exports, "ErrSignedInRequired", ()=>ErrSignedInRequired);
parcelHelpers.export(exports, "EventType", ()=>EventType);
parcelHelpers.export(exports, "ExtensionMessageHandler", ()=>ExtensionMessageHandler);
parcelHelpers.export(exports, "ExtensionMessageProvider", ()=>ExtensionMessageProvider);
parcelHelpers.export(exports, "InitState", ()=>InitState);
parcelHelpers.export(exports, "LocalStorage", ()=>LocalStorage);
parcelHelpers.export(exports, "MemoryItemStore", ()=>MemoryItemStore);
parcelHelpers.export(exports, "MuxMessageProvider", ()=>MuxMessageProvider);
parcelHelpers.export(exports, "OpenState", ()=>OpenState);
parcelHelpers.export(exports, "PROVIDER_OPEN_TIMEOUT", ()=>PROVIDER_OPEN_TIMEOUT);
parcelHelpers.export(exports, "ProviderError", ()=>ProviderError);
parcelHelpers.export(exports, "ProxyMessageChannel", ()=>ProxyMessageChannel);
parcelHelpers.export(exports, "ProxyMessageChannelPort", ()=>ProxyMessageChannelPort);
parcelHelpers.export(exports, "ProxyMessageHandler", ()=>ProxyMessageHandler);
parcelHelpers.export(exports, "ProxyMessageProvider", ()=>ProxyMessageProvider);
parcelHelpers.export(exports, "SequenceClient", ()=>SequenceClient);
parcelHelpers.export(exports, "SequenceClientSession", ()=>SequenceClientSession);
parcelHelpers.export(exports, "SequenceProvider", ()=>SequenceProvider);
parcelHelpers.export(exports, "SequenceSigner", ()=>SequenceSigner);
parcelHelpers.export(exports, "SingleNetworkSequenceProvider", ()=>SingleNetworkSequenceProvider);
parcelHelpers.export(exports, "SingleNetworkSequenceSigner", ()=>SingleNetworkSequenceSigner);
parcelHelpers.export(exports, "UnrealMessageHandler", ()=>UnrealMessageHandler);
parcelHelpers.export(exports, "UnrealMessageProvider", ()=>UnrealMessageProvider);
parcelHelpers.export(exports, "WalletRequestHandler", ()=>WalletRequestHandler);
parcelHelpers.export(exports, "WindowMessageHandler", ()=>WindowMessageHandler);
parcelHelpers.export(exports, "WindowMessageProvider", ()=>WindowMessageProvider);
parcelHelpers.export(exports, "WindowSessionParams", ()=>WindowSessionParams);
parcelHelpers.export(exports, "getWallet", ()=>getWallet);
parcelHelpers.export(exports, "initWallet", ()=>initWallet);
parcelHelpers.export(exports, "isBrowserExtension", ()=>isBrowserExtension);
parcelHelpers.export(exports, "isMuxTransportTemplate", ()=>isMuxTransportTemplate);
parcelHelpers.export(exports, "isProviderTransport", ()=>isProviderTransport);
parcelHelpers.export(exports, "isUnityPlugin", ()=>isUnityPlugin);
parcelHelpers.export(exports, "isValidMessageSignature", ()=>isValidMessageSignature);
parcelHelpers.export(exports, "isValidSignature", ()=>isValidSignature);
parcelHelpers.export(exports, "isValidTypedDataSignature", ()=>isValidTypedDataSignature);
parcelHelpers.export(exports, "isWalletUpToDate", ()=>isWalletUpToDate);
parcelHelpers.export(exports, "messageToBytes", ()=>messageToBytes);
parcelHelpers.export(exports, "nextMessageIdx", ()=>nextMessageIdx);
parcelHelpers.export(exports, "prefixEIP191Message", ()=>prefixEIP191Message);
parcelHelpers.export(exports, "resolveArrayProperties", ()=>resolveArrayProperties);
parcelHelpers.export(exports, "trimEIP191Prefix", ()=>trimEIP191Prefix);
parcelHelpers.export(exports, "unregisterWallet", ()=>unregisterWallet);
parcelHelpers.export(exports, "useBestStore", ()=>useBestStore);
var _eventemitter2 = require("eventemitter2");
var _utils = require("@0xsequence/utils");
var _ethers = require("ethers");
var _network = require("@0xsequence/network");
var _core = require("@0xsequence/core");
var _auth = require("@0xsequence/auth");
var _abi = require("@0xsequence/abi");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function isProviderTransport(transport) {
    return transport && typeof transport === "object" && typeof transport.register === "function" && typeof transport.unregister === "function" && typeof transport.openWallet === "function" && typeof transport.closeWallet === "function" && typeof transport.isOpened === "function" && typeof transport.isConnected === "function" && typeof transport.on === "function";
}
// ProviderMessageCallback is used to respond to ProviderMessage requests. The error
// argument is for exceptions during the execution, and response is the response payload
// which may contain the result or an error payload from the wallet.
// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging
// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging
class WindowSessionParams extends URLSearchParams {
    static new(init) {
        return new URLSearchParams(init);
    }
}
let EventType = /*#__PURE__*/ function(EventType) {
    EventType["OPEN"] = "open";
    EventType["CLOSE"] = "close";
    EventType["MESSAGE"] = "message";
    EventType["CONNECT"] = "connect";
    EventType["DISCONNECT"] = "disconnect";
    EventType["ACCOUNTS_CHANGED"] = "accountsChanged";
    EventType["CHAIN_CHANGED"] = "chainChanged";
    EventType["NETWORKS"] = "networks";
    EventType["WALLET_CONTEXT"] = "walletContext";
    EventType["INIT"] = "init";
    EventType["DEBUG"] = "_debug";
    return EventType;
}({});
let OpenState = /*#__PURE__*/ function(OpenState) {
    OpenState[OpenState["CLOSED"] = 0] = "CLOSED";
    OpenState[OpenState["OPENING"] = 1] = "OPENING";
    OpenState[OpenState["OPENED"] = 2] = "OPENED";
    return OpenState;
}({});
let InitState = /*#__PURE__*/ function(InitState) {
    InitState[InitState["NIL"] = 0] = "NIL";
    InitState[InitState["SENT_NONCE"] = 1] = "SENT_NONCE";
    InitState[InitState["OK"] = 2] = "OK";
    return InitState;
}({});
/** Options to further customize the wallet experience. */ /** light and dark are the main themes, to use other themes in wallet settings,
 * you can use the camel case version of the name in the wallet settings.
 * For example: "Blue Dark" on wallet UI can be passed as "blueDark" */ // | 'large'
class ProviderError extends Error {
    constructor(message){
        super(message);
        this.name = "ProviderError";
    }
}
const ErrSignedInRequired = new ProviderError("Wallet is not signed in. Connect a wallet and try again.");
// TODO: lets build some nice error handling tools, prob in /utils ...
// This is required by viem, it expects a provider to have an EIP-1193 compliant `request` attribute.
const PROVIDER_OPEN_TIMEOUT = 30000; // in ms
let _messageIdx = 0;
const nextMessageIdx = ()=>++_messageIdx;
class BaseProviderTransport {
    constructor(){
        var _this = this;
        this.pendingMessageRequests = [];
        this.responseCallbacks = new Map();
        this.state = void 0;
        this.confirmationOnly = false;
        this.events = new (0, _eventemitter2.EventEmitter2)();
        this.openPayload = void 0;
        this.connectPayload = void 0;
        this.accountsChangedPayload = void 0;
        this.networksPayload = void 0;
        this.walletContextPayload = void 0;
        this._sessionId = void 0;
        this._init = void 0;
        this._registered = void 0;
        this.sendAsync = async function(request, callback, chainId) {
            // here, we receive the message from the dapp provider call
            if (_this.state === OpenState.CLOSED) // flag the wallet to auto-close once user submits input. ie.
            // prompting to sign a message or transaction
            _this.confirmationOnly = true;
            // open/focus the wallet.
            // automatically open the wallet when a provider request makes it here.
            //
            // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.
            //
            // TODO: how does this behave with a session has expired?
            _this.openWallet(undefined, {
                type: "jsonRpcRequest",
                method: request.method
            }, chainId);
            // send message request, await, and then execute callback after receiving the response
            try {
                if (!_this.isOpened()) await _this.waitUntilOpened(); // will throw on timeout
                const response = await _this.sendMessageRequest({
                    idx: nextMessageIdx(),
                    type: EventType.MESSAGE,
                    data: request,
                    chainId: chainId
                });
                callback(undefined, response.data);
            } catch (err) {
                callback(err);
            }
        };
        // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet
        this.sendMessageRequest = async function(message) {
            return new Promise((resolve, reject)=>{
                if ((!message.idx || message.idx <= 0) && message.type !== "init") reject(new Error("message idx not set"));
                const responseCallback = (error, response)=>{
                    if (error) reject(error);
                    else if (response) resolve(response);
                    else throw new Error("no valid response to return");
                };
                const idx = message.idx;
                if (!_this.responseCallbacks.get(idx)) _this.responseCallbacks.set(idx, responseCallback);
                else reject(new Error("duplicate message idx, should never happen"));
                if (!_this.isOpened()) {
                    (0, _utils.logger).debug("pushing to pending requests", message);
                    _this.pendingMessageRequests.push(message);
                } else _this.sendMessage(message);
            });
        };
        this.waitUntilOpened = async function(openTimeout = PROVIDER_OPEN_TIMEOUT) {
            let opened = false;
            return Promise.race([
                new Promise((_, reject)=>{
                    const timeout = setTimeout(()=>{
                        clearTimeout(timeout);
                        // only emit close if the timeout wins the race
                        if (!opened) {
                            _this.state = OpenState.CLOSED;
                            _this.events.emit("close", {
                                code: 1005,
                                message: "opening wallet timed out"
                            });
                        }
                        reject(new Error("opening wallet timed out"));
                    }, openTimeout);
                }),
                new Promise((resolve)=>{
                    if (_this.isOpened()) {
                        var _this$openPayload;
                        opened = true;
                        resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);
                        return;
                    }
                    _this.events.once("open", (openInfo)=>{
                        _this.openPayload = openInfo;
                        opened = true;
                        resolve(openInfo.session);
                    });
                })
            ]);
        };
        this.waitUntilConnected = async function() {
            await _this.waitUntilOpened();
            const connect = new Promise((resolve)=>{
                if (_this.connectPayload) {
                    resolve(_this.connectPayload);
                    return;
                }
                _this.events.once("connect", (connectDetails)=>{
                    _this.connectPayload = connectDetails;
                    resolve(connectDetails);
                });
            });
            const closeWallet = new Promise((_, reject)=>{
                _this.events.once("close", (error)=>{
                    if (error) reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));
                    else reject(new Error(`user closed the wallet`));
                });
            });
            return Promise.race([
                connect,
                closeWallet
            ]);
        };
        this.state = OpenState.CLOSED;
        this._registered = false;
        this._init = InitState.NIL;
    }
    get registered() {
        return this._registered;
    }
    register() {
        throw new Error("abstract method");
    }
    unregister() {
        throw new Error("abstract method");
    }
    openWallet(path, intent, networkId) {
        throw new Error("abstract method");
    }
    closeWallet() {
        throw new Error("abstract method");
    }
    isOpened() {
        return this.registered && this.state === OpenState.OPENED;
    }
    isConnected() {
        var _this$openPayload2;
        // if we're registered, and we have the account details, then we are connected
        const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;
        return this.registered && session !== undefined && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;
    }
    // handleMessage will handle message received from the remote wallet
    handleMessage(message) {
        var _this2 = this;
        // init incoming for initial handshake with transport.
        // always respond to INIT messages, e.g. on popup window reload
        if (message.type === EventType.INIT) {
            (0, _utils.logger).debug("MessageProvider, received INIT message", message);
            const { nonce } = message.data;
            if (!nonce || nonce.length == 0) {
                (0, _utils.logger).error("invalid init nonce");
                return;
            }
            this._init = InitState.OK;
            this.sendMessage({
                idx: -1,
                type: EventType.INIT,
                data: {
                    sessionId: this._sessionId,
                    nonce: nonce
                }
            });
        }
        if (this._init !== InitState.OK) // if provider is not init'd, then we drop any received messages. the only
        // message we will process is of event type 'init', as our acknowledgement
        return;
        // message is either a notification, or its a ProviderMessageResponse
        (0, _utils.logger).debug("RECEIVED MESSAGE FROM WALLET", message.idx, message);
        const requestIdx = message.idx;
        const responseCallback = this.responseCallbacks.get(requestIdx);
        if (requestIdx) this.responseCallbacks.delete(requestIdx);
        // OPEN response
        //
        // Flip opened flag, and flush the pending queue
        if (message.type === EventType.OPEN && !this.isOpened()) {
            var _message$data, _message$data2;
            if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {
                (0, _utils.logger).debug("open event received from wallet, but does not match sessionId", this._sessionId);
                return;
            }
            // check if open error occured due to invalid defaultNetworkId
            if ((_message$data2 = message.data) != null && _message$data2.error) {
                var _message$data3;
                const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);
                (0, _utils.logger).error(err);
                this.close();
                throw err;
            }
            // success!
            this.state = OpenState.OPENED;
            this.openPayload = message.data;
            this.events.emit("open", this.openPayload);
            // flush pending requests when connected
            if (this.pendingMessageRequests.length !== 0) {
                const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);
                pendingMessageRequests.forEach(async function(pendingMessageRequest) {
                    _this2.sendMessage(pendingMessageRequest);
                });
            }
            return;
        }
        // MESSAGE resposne
        if (message.type === EventType.MESSAGE) {
            // Require user confirmation, bring up wallet to prompt for input then close
            // TODO: perhaps apply technique like in multicall to queue messages within
            // a period of time, then close the window if responseCallbacks is empty, this is better.
            if (this.confirmationOnly) setTimeout(()=>{
                if (this.responseCallbacks.size === 0) this.closeWallet();
            }, 500); // TODO: be smarter about timer as we're processing the response callbacks..
            if (!responseCallback) // NOTE: this would occur if 'idx' isn't set, which should never happen
            // or when we register two handler, or duplicate messages with the same idx are sent,
            // all of which should be prevented prior to getting to this point
            throw new Error("impossible state");
            // Callback to original caller
            if (responseCallback) {
                this.events.emit("message", message);
                responseCallback(message.data.error, message);
                return;
            }
        }
        // ACCOUNTS_CHANGED -- when a user logs in or out
        if (message.type === EventType.ACCOUNTS_CHANGED) {
            this.accountsChangedPayload = {
                accounts: []
            };
            if (message.data && message.data.length > 0) {
                this.accountsChangedPayload = {
                    accounts: [
                        (0, _ethers.ethers).utils.getAddress(message.data[0])
                    ],
                    origin: message.origin
                };
                this.events.emit("accountsChanged", this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);
            } else this.events.emit("accountsChanged", [], message.origin);
            return;
        }
        // CHAIN_CHANGED -- when a user changes their default chain
        if (message.type === EventType.CHAIN_CHANGED) {
            this.events.emit("chainChanged", message.data, message.origin);
            return;
        }
        // NOTIFY NETWORKS -- when a user connects or logs in
        if (message.type === EventType.NETWORKS) {
            this.networksPayload = message.data;
            this.events.emit("networks", this.networksPayload);
            return;
        }
        // NOTIFY WALLET_CONTEXT -- when a user connects or logs in
        if (message.type === EventType.WALLET_CONTEXT) {
            this.walletContextPayload = message.data;
            this.events.emit("walletContext", this.walletContextPayload);
            return;
        }
        // NOTIFY CLOSE -- when wallet instructs to close
        if (message.type === EventType.CLOSE) {
            if (this.state !== OpenState.CLOSED) this.close(message.data);
        }
        // NOTIFY CONNECT -- when wallet instructs we've connected
        if (message.type === EventType.CONNECT) {
            this.connectPayload = message.data;
            this.events.emit("connect", this.connectPayload);
        }
        // NOTIFY DISCONNECT -- when wallet instructs to disconnect
        if (message.type === EventType.DISCONNECT) {
            if (this.isConnected()) {
                this.events.emit("disconnect", message.data, message.origin);
                this.close();
            }
        }
    }
    sendMessage(message) {
        throw new Error("abstract method");
    }
    on(event, fn) {
        this.events.on(event, fn);
    }
    once(event, fn) {
        this.events.once(event, fn);
    }
    emit(event, ...args) {
        return this.events.emit(event, ...args);
    }
    close(error) {
        if (this.state === OpenState.CLOSED) return;
        this.state = OpenState.CLOSED;
        this.confirmationOnly = false;
        this._sessionId = undefined;
        (0, _utils.logger).info("closing wallet and flushing!");
        // flush pending requests and return error to all callbacks
        this.pendingMessageRequests.length = 0;
        this.responseCallbacks.forEach((responseCallback)=>{
            responseCallback(_extends({}, new Error("wallet closed"), {
                code: 4001
            }));
        });
        this.responseCallbacks.clear();
        this.connectPayload = undefined;
        this.openPayload = undefined;
        this.accountsChangedPayload = undefined;
        this.networksPayload = undefined;
        this.walletContextPayload = undefined;
        this.events.emit("close", error);
    }
}
function messageIsExemptFromEIP191Prefix(message) {
    return EIP_191_PREFIX_EXCEPTIONS.some((e)=>e.predicate(message));
}
const EIP_191_PREFIX_EXCEPTIONS = [
    // NOTE: Decentraland does not support 191 correctly.
    {
        name: "Decentraland Exception",
        predicate: isDecentralandLoginMessage
    },
    // NOTE: 0x v3 does not support 191 correctly.
    // See https://gov.0x.org/t/zeip-proposal-fix-v3-eip-191-non-compliance-when-validating-eip-1271-signatures/3396 for more info.
    {
        name: "0x v3 Exception",
        predicate: isZeroExV3Order
    }
];
const DCL_REGEX = /^Decentraland Login\nEphemeral address: 0x[a-fA-F0-9]{40}\nExpiration: (\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)((-(\d{2}):(\d{2})|Z)?)$/;
function isDecentralandLoginMessage(bytes) {
    try {
        const stringified = (0, _ethers.ethers).utils.toUtf8String(bytes);
        return DCL_REGEX.test(stringified);
    } catch (_unused) {
        return false;
    }
}
// try to interpret bytes as abi-encoded 0x v3 OrderWithHash -
// see https://github.com/0xProject/0x-protocol-specification/blob/master/v3/v3-specification.md
function isZeroExV3Order(bytes) {
    const abi = new (0, _ethers.ethers).utils.Interface(ZeroXV3EIP1271OrderWithHashAbi);
    try {
        abi.decodeFunctionData("OrderWithHash", bytes);
        return true;
    } catch (err) {
        // failed to decode ABI, so it's not a v3 order.
        return false;
    }
}
const ZeroXV3EIP1271OrderWithHashAbi = [
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "makerAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "takerAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "feeRecipientAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "senderAddress",
                        type: "address"
                    },
                    {
                        internalType: "uint256",
                        name: "makerAssetAmount",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "takerAssetAmount",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "makerFee",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "takerFee",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "expirationTimeSeconds",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "salt",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "makerAssetData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "takerAssetData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "makerFeeAssetData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "takerFeeAssetData",
                        type: "bytes"
                    }
                ],
                internalType: "struct IEIP1271Data.Order",
                name: "order",
                type: "tuple"
            },
            {
                internalType: "bytes32",
                name: "orderHash",
                type: "bytes32"
            }
        ],
        name: "OrderWithHash",
        outputs: [],
        stateMutability: "pure",
        type: "function"
    }
];
const eip191prefix = (0, _ethers.ethers).utils.toUtf8Bytes("\x19Ethereum Signed Message:\n");
const messageToBytes = (message)=>{
    if ((0, _ethers.ethers).utils.isBytes(message) || (0, _ethers.ethers).utils.isHexString(message)) return (0, _ethers.ethers).utils.arrayify(message);
    return (0, _ethers.ethers).utils.toUtf8Bytes(message);
};
const prefixEIP191Message = (message)=>{
    const messageBytes = messageToBytes(message);
    if (messageIsExemptFromEIP191Prefix(messageBytes)) return messageBytes;
    else return (0, _ethers.ethers).utils.concat([
        eip191prefix,
        (0, _ethers.ethers).utils.toUtf8Bytes(String(messageBytes.length)),
        messageBytes
    ]);
};
const trimEIP191Prefix = (prefixedMessage)=>{
    // If the message is not prefixed, we return the message as is.
    if (JSON.stringify(prefixedMessage.slice(0, eip191prefix.length)) !== JSON.stringify(eip191prefix)) return prefixedMessage;
    // We have two parts to remove.
    // First is the EIP-191 prefix.
    const ethereumSignedMessagePartSlicedArray = prefixedMessage.slice(eip191prefix.length);
    // Second is the digits added which represent length of the message without the prefix
    // and we need to find the prefix that will match this.
    // Here first we take the max prefix char length, and check if as a number it is bigger
    // than the length of the message (since prefix is added to represent length of original message),
    // if it is we remove 1 from char length, if not we keep the max prefix char length.
    // As an example for the case where , if the message is 123456789, the expected prefix char is 9, with starting value 9123456789
    // the char length of the total message with the prefix is 10, so the max prefix char length we start is 2 from [1,0], and as a number 10, it is longer
    // than the length of the message after removing prefix (10 - 2 = 8), so we slice 1 char less, which is 9, and we get the correct prefix.
    const maxPrefixCharLength = String(ethereumSignedMessagePartSlicedArray.length).length;
    let prefixCharLenght;
    let prefixAsNumber;
    try {
        prefixAsNumber = Number((0, _ethers.ethers).utils.toUtf8String(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
    } catch (_unused) {
        prefixAsNumber = Number((0, _ethers.ethers).utils.hexlify(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
    }
    if (prefixAsNumber > ethereumSignedMessagePartSlicedArray.length || !Number.isInteger(prefixAsNumber)) prefixCharLenght = maxPrefixCharLength - 1;
    else prefixCharLenght = maxPrefixCharLength;
    const prefixRevertedMessage = ethereumSignedMessagePartSlicedArray.slice(prefixCharLenght);
    return prefixRevertedMessage;
};
const isValidSignature = async (address, digest, sig, provider)=>{
    const reader = new (0, _core.commons).reader.OnChainReader(provider);
    return reader.isValidSignature(address, digest, sig);
};
// Verify message signature
const isValidMessageSignature = async (address, message, signature, provider)=>{
    const prefixed = prefixEIP191Message(message);
    const digest = (0, _utils.encodeMessageDigest)(prefixed);
    return isValidSignature(address, digest, signature, provider);
};
// Verify typedData signature
const isValidTypedDataSignature = (address, typedData, signature, provider)=>{
    return isValidSignature(address, (0, _utils.encodeTypedDataDigest)(typedData), signature, provider);
};
const isBrowserExtension = ()=>window.location.protocol === "chrome-extension:" || window.location.protocol === "moz-extension:";
const isUnityPlugin = ()=>!!navigator.userAgent.match(/UnitySequence/i);
// /**
//  * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status
//  *
//  * @param {Status} of the wallet
//  */
const isWalletUpToDate = (status)=>{
    return status.onChain.deployed && status.fullyMigrated;
};
class MemoryItemStore {
    constructor(){
        this.callbacks = [];
        this.store = {};
    }
    getItem(key) {
        return this.store[key] || null;
    }
    setItem(key, value) {
        this.store[key] = value;
        this.callbacks.filter((c)=>c.key === key).forEach((c)=>c.cb(value));
    }
    removeItem(key) {
        delete this.store[key];
    }
    onItemChange(key, cb) {
        this.callbacks.push({
            key,
            cb
        });
        return ()=>{
            this.callbacks = this.callbacks.filter((c)=>c.cb !== cb);
        };
    }
}
class LocalStorage {
    static isAvailable() {
        return typeof window === "object" && typeof window.localStorage === "object";
    }
    constructor(){
        this.callbacks = [];
        if (!LocalStorage.isAvailable()) throw new Error("LocalStorage is not available");
        window.addEventListener("storage", (e)=>{
            const { key } = e;
            const cb = this.callbacks.filter((c)=>c.key === key);
            cb.forEach((c)=>c.cb(this.getItem(key)));
        });
    }
    getItem(key) {
        return window.localStorage.getItem(key);
    }
    setItem(key, value) {
        window.localStorage.setItem(key, value);
        // Trigger callbacks
        // NOTICE: the event is not triggered on the same window
        this.callbacks.filter((c)=>c.key === key).forEach((c)=>c.cb(value));
    }
    removeItem(key) {
        window.localStorage.removeItem(key);
        // Trigger callbacks
        // NOTICE: the event is not triggered on the same window
        this.callbacks.filter((c)=>c.key === key).forEach((c)=>c.cb(null));
    }
    onItemChange(key, cb) {
        this.callbacks.push({
            key,
            cb
        });
        return ()=>{
            this.callbacks = this.callbacks.filter((c)=>c.cb !== cb);
        };
    }
}
function useBestStore() {
    if (LocalStorage.isAvailable()) return new LocalStorage();
    return new MemoryItemStore();
}
async function resolveArrayProperties(object) {
    if (Array.isArray(object)) // T must include array type
    return Promise.all(object.map((o)=>(0, _ethers.ethers).utils.resolveProperties(o)));
    return (0, _ethers.ethers).utils.resolveProperties(object);
}
const TRANSPORT_SESSION_LS_KEY = "@sequence.transportSession";
class BaseWalletTransport {
    constructor(walletRequestHandler){
        var _this = this;
        this.walletRequestHandler = void 0;
        this._sessionId = void 0;
        this._registered = void 0;
        this._init = void 0;
        this._initNonce = void 0;
        this._initCallback = void 0;
        // appOrigin identifies the dapp's origin which opened the app. A transport
        // will auto-detect and set this value if it can. This is determined
        // as the parent app/window which opened the wallet.
        this.appOrigin = void 0;
        this.sendAsync = async function(request, callback, chainId) {
            throw new Error("abstract method");
        };
        this.handleMessage = async function(message) {
            const request = message;
            // ensure initial handshake is complete before accepting
            // other kinds of messages.
            if (_this._init !== InitState.OK) {
                if (request.type === EventType.INIT) {
                    if (_this.isValidInitAck(message)) // successful init
                    {
                        if (_this._initCallback) _this._initCallback();
                    } else {
                        // failed init
                        if (_this._initCallback) _this._initCallback("invalid init");
                        return;
                    }
                }
                return;
            }
            // ensure signer is ready to handle requests
            // if (this.walletRequestHandler.getSigner() === undefined) {
            //   await this.walletRequestHandler.signerReady()
            // }
            // handle request
            switch(request.type){
                case EventType.OPEN:
                    {
                        if (_this._init !== InitState.OK) return;
                        const session = {
                            sessionId: request.data.sessionId,
                            intent: request.data.intent,
                            networkId: request.data.networkId
                        };
                        await _this.open(session);
                        return;
                    }
                case EventType.CLOSE:
                    if (_this._init !== InitState.OK) return;
                    // noop. just here to capture the message so event emitters may be notified
                    return;
                case EventType.MESSAGE:
                    {
                        const response = await _this.walletRequestHandler.sendMessageRequest(request);
                        _this.sendMessage(response);
                        response.data.error;
                        return;
                    }
                default:
                    (0, _utils.logger).error(`unexpected payload type ${request.type}`);
            }
        };
        // sendMessageRequest sends a ProviderMessageRequest to the wallet post-message transport
        this.sendMessageRequest = async function(message) {
            return _this.walletRequestHandler.sendMessageRequest(message);
        };
        this.open = async function({ sessionId, intent, networkId }) {
            if (sessionId) {
                _this._sessionId = (0, _utils.sanitizeNumberString)(sessionId);
                // persist transport session in localstorage for restoring after redirect/reload
                _this.saveTransportSession({
                    sessionId,
                    intent,
                    networkId
                });
            }
            _this.walletRequestHandler.setOpenIntent(intent);
            // init handshake for certain transports, before we can open the communication.
            //
            // for example, with the window-transport, we have to exchange messages to determine the
            // origin host of the dapp.
            await _this.init();
            // determine chainId from networkId (string or number)
            let chainId = undefined;
            try {
                if (networkId) {
                    const network = (0, _network.findSupportedNetwork)(networkId);
                    if (network) chainId = network.chainId;
                    else throw new Error(`unknown network ${networkId}`);
                } else // if not provided, use defaultChainId
                chainId = _this.walletRequestHandler.defaultChainId();
            } catch (err) {
                console.error(err);
            }
            // Prepare connect options from intent
            if (intent && intent.type === "connect" && intent.options) {
                const connectOptions = intent.options;
                const authorizeOptions = connectOptions; // overlapping types
                // Sanity/integrity check the intent payload, and set authorization origin
                // if its been determined as part of the init handshake from earlier.
                if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
                    if (!isBrowserExtension()) {
                        if (authorizeOptions.origin !== _this.appOrigin) throw new Error("origin is invalid");
                    }
                } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) // ie. when we can't determine the origin in our transport, but dapp provides it to us.
                // we just sanitize the origin host.
                connectOptions.origin = (0, _utils.sanitizeHost)(authorizeOptions.origin);
                else if (_this.appOrigin) // ie. when we auto-determine the origin such as in window-transport
                connectOptions.origin = _this.appOrigin;
                if (connectOptions.app) connectOptions.app = (0, _utils.sanitizeAlphanumeric)(connectOptions.app);
                if (connectOptions.networkId) networkId = connectOptions.networkId;
                else if (networkId) connectOptions.networkId = networkId;
                // Set connect options on the walletRequestHandler as our primary
                // wallet controller, and fall back to networkId if necessary
                _this.walletRequestHandler.setConnectOptions(connectOptions);
            } else _this.walletRequestHandler.setConnectOptions(undefined);
            // ensure signer is ready
            await _this.walletRequestHandler.getAccount();
            // Notify open and proceed to prompt for connection if intended
            if (!await _this.walletRequestHandler.isSignedIn()) {
                // open wallet without a specific connected chainId, as the user is not signed in
                _this.notifyOpen({
                    sessionId: _this._sessionId
                });
                return true;
            } else // prompt user with a connect request. the options will be used as previously set above.
            // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.
            // upon cancellation by user, the walletRequestHandler will throw an error
            if (intent && intent.type === "connect") {
                // Failed to set default network on open
                // Fail silently here so we can continue with connect flow and ask
                // user to connect on a different network if necessary
                if (!chainId || chainId <= 0) console.log("Failed to set default network on open");
                // notify wallet is opened, without session details
                _this.notifyOpen({
                    sessionId: _this._sessionId
                });
                try {
                    const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);
                    if (connectDetails.connected) _this.walletRequestHandler.notifyConnect(connectDetails);
                } catch (err) {
                    (0, _utils.logger).warn("promptConnect not connected:", err);
                } finally{
                    // auto-close by default, unless intent is to keep open
                    if (!intent.options || intent.options.keepWalletOpened !== true) _this.notifyClose();
                }
            } else {
                // Using default network
                // Failed to set default network on open -- quit + close
                if (!chainId || chainId <= 0) {
                    _this.notifyOpen({
                        sessionId: _this._sessionId,
                        error: `failed to open wallet on network ${networkId}`
                    });
                    return false;
                }
                // user is already connected, notify session details.
                // TODO: in future, keep list if 'connected' dapps / sessions in the session
                // controller, and only sync with allowed apps
                _this.notifyOpen({
                    sessionId: _this._sessionId,
                    chainId: `${chainId}`,
                    session: await _this.walletRequestHandler.walletSession(chainId)
                });
            }
            return true;
        };
        this.saveTransportSession = (session)=>{
            useBestStore().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));
        };
        this.getCachedTransportSession = async function() {
            const session = useBestStore().getItem(TRANSPORT_SESSION_LS_KEY);
            try {
                return session ? JSON.parse(session) : null;
            } catch (err) {
                console.error(`unable to parse transport session: ${session}`);
                return null;
            }
        };
        this.walletRequestHandler = walletRequestHandler;
        this._init = InitState.NIL;
        this.walletRequestHandler.on("connect", (connectDetails)=>{
            if (!this.registered) return;
            // means user has logged in and wallet is connected to the app
            this.notifyConnect(connectDetails);
        });
        this.walletRequestHandler.on("disconnect", (error, origin)=>{
            if (!this.registered) return;
            // means user has logged out the app / disconnected wallet from the app
            this.notifyDisconnect(error, origin);
        });
        this.walletRequestHandler.on("accountsChanged", (accounts, origin)=>{
            if (!this.registered) return;
            this.notifyAccountsChanged(accounts, origin);
        });
        this.walletRequestHandler.on("networks", (networks)=>{
            if (!this.registered) return;
            this.notifyNetworks(networks);
            if (!networks || networks.length === 0) this.notifyChainChanged("0x0");
            else this.notifyChainChanged((0, _ethers.ethers).utils.hexValue(networks.find((network)=>network.isDefaultChain).chainId));
        });
        this.walletRequestHandler.on("chainChanged", (chainIdHex, origin)=>{
            this.notifyChainChanged(chainIdHex, origin);
        });
        this.walletRequestHandler.on("walletContext", (walletContext)=>{
            if (!this.registered || !walletContext) return;
            this.notifyWalletContext(walletContext);
        });
        this.walletRequestHandler.on("close", (error)=>{
            if (!this.registered) return;
            this.notifyClose(error);
        });
    }
    get registered() {
        return this._registered;
    }
    register() {
        throw new Error("abstract method");
    }
    unregister() {
        throw new Error("abstract method");
    }
    sendMessage(message) {
        throw new Error("abstract method");
    }
    notifyOpen(openInfo) {
        const { chainId, sessionId, session, error } = openInfo;
        this.sendMessage({
            idx: -1,
            type: EventType.OPEN,
            data: {
                chainId,
                sessionId,
                session,
                error
            }
        });
    }
    notifyClose(error) {
        this.sendMessage({
            idx: -1,
            type: EventType.CLOSE,
            data: error ? {
                error
            } : null
        });
    }
    notifyConnect(connectDetails) {
        this.sendMessage({
            idx: -1,
            type: EventType.CONNECT,
            data: connectDetails
        });
    }
    notifyDisconnect(error, origin) {
        this.sendMessage({
            idx: -1,
            type: EventType.DISCONNECT,
            data: error ? {
                error
            } : null,
            origin
        });
    }
    notifyAccountsChanged(accounts, origin) {
        this.sendMessage({
            idx: -1,
            type: EventType.ACCOUNTS_CHANGED,
            data: accounts,
            origin
        });
    }
    notifyChainChanged(chainIdHex, origin) {
        this.sendMessage({
            idx: -1,
            type: EventType.CHAIN_CHANGED,
            data: chainIdHex,
            origin
        });
    }
    notifyNetworks(networks) {
        this.sendMessage({
            idx: -1,
            type: EventType.NETWORKS,
            data: networks
        });
    }
    notifyWalletContext(walletContext) {
        this.sendMessage({
            idx: -1,
            type: EventType.WALLET_CONTEXT,
            data: walletContext
        });
    }
    isValidInitAck(message) {
        if (this._init === InitState.OK) {
            // we're already in init state, we shouldn't handle this message
            (0, _utils.logger).warn("isValidInitAck, already in init'd state, so inquiry is invalid.");
            return false;
        }
        if (message.type !== EventType.INIT) {
            (0, _utils.logger).warn("isValidInitAck, invalid message type, expecting init");
            return false;
        }
        const { sessionId, nonce } = message.data;
        if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {
            (0, _utils.logger).error("invalid init ack");
            return false;
        }
        if (sessionId !== this._sessionId || nonce !== this._initNonce) {
            (0, _utils.logger).error("invalid init ack match");
            return false;
        }
        // all checks pass, its true
        return true;
    }
    init() {
        return new Promise((resolve, reject)=>{
            // avoid re-init`ing, or if there is a transport which doesn't require
            // it, then it may set this._init to OK in its constructor.
            if (this._init === InitState.OK) {
                resolve();
                return;
            }
            if (this._init !== InitState.NIL || this._initCallback) {
                reject("transport init is in progress");
                return;
            }
            // start init timeout, if we don't receive confirmation
            // from provider within this amount of time, then we timeout
            const initTimeout = setTimeout(()=>{
                (0, _utils.logger).warn("transport init timed out");
                if (this._initCallback) this._initCallback("transport init timed out");
            }, PROVIDER_OPEN_TIMEOUT / 2);
            // setup callback as we receive the init message async in the handleMessage function
            this._initCallback = (error)=>{
                this._initCallback = undefined; // reset
                clearTimeout(initTimeout);
                if (error) reject(error);
                else {
                    this._init = InitState.OK;
                    resolve();
                }
            };
            // send init request with random nonce to the provider, where we expect
            // for the provider to echo it back to us as complete handshake
            this._initNonce = `${performance.now()}`;
            this.sendMessage({
                idx: -1,
                type: EventType.INIT,
                data: {
                    nonce: this._initNonce
                }
            });
            this._init = InitState.SENT_NONCE;
        // NOTE: the promise will resolve in the _initCallback method
        // which will be called from either handleMessage or the initTimeout
        });
    }
}
class ProxyMessageChannel {
    constructor(){
        this.app = void 0;
        this.wallet = void 0;
        const port1 = new ProxyMessageChannelPort();
        const port2 = new ProxyMessageChannelPort();
        port1.conn = port2;
        port2.conn = port1;
        this.app = port1;
        this.wallet = port2;
    }
}
class ProxyMessageChannelPort {
    constructor(){
        this.conn = void 0;
        this.events = new (0, _eventemitter2.EventEmitter2)();
        // handle messages which hit this port
        this.handleMessage = (message)=>{
            throw new Error("ProxyMessageChannelPort is not registered");
        };
        // send messages to the connected port
        this.sendMessage = (message)=>{
            this.conn.handleMessage(message);
            // trigger events
            if (message.type === "open") this.events.emit("open", message);
            if (message.type === "close") this.events.emit("close", message);
            if (message.type === "connect") this.events.emit("connect", message);
            if (message.type === "disconnect") this.events.emit("disconnect", message);
        };
    }
    on(event, fn) {
        this.events.on(event, fn);
    }
    once(event, fn) {
        this.events.once(event, fn);
    }
}
class ProxyMessageProvider extends BaseProviderTransport {
    constructor(port){
        super();
        this.port = void 0;
        this.register = ()=>{
            this.port.handleMessage = (message)=>{
                this.handleMessage(message);
            };
            this.on("open", (...args)=>{
                this.port.events.emit("open", ...args);
            });
            this.on("close", (...args)=>{
                this.port.events.emit("close", ...args);
            });
            this.on("connect", (...args)=>{
                this.port.events.emit("connect", ...args);
            });
            this.on("disconnect", (...args)=>{
                this.port.events.emit("disconnect", ...args);
            });
            this._registered = true;
        };
        this.unregister = ()=>{
            this._registered = false;
            this.closeWallet();
            this.events.removeAllListeners();
            // @ts-ignore
            this.port.handleMessage = undefined;
        };
        this.openWallet = (path, intent, networkId)=>{
            if (this.state === OpenState.CLOSED) {
                this.state = OpenState.OPENING;
                const sessionId = `${performance.now()}`;
                this._sessionId = sessionId;
                this.sendMessage({
                    idx: -1,
                    type: EventType.OPEN,
                    data: {
                        path,
                        intent,
                        networkId,
                        sessionId
                    }
                });
            }
        };
        this.state = OpenState.CLOSED;
        this.port = port;
        if (!port) throw new Error("port argument cannot be empty");
        // disable init handshake for proxy-transport, we set it to OK, to
        // consider it in completed state.
        this._init = InitState.OK;
    }
    closeWallet() {
        this.sendMessage({
            idx: -1,
            type: EventType.CLOSE,
            data: null
        });
        this.close();
    }
    sendMessage(message) {
        if (!message.idx) throw new Error("message idx is empty");
        this.port.sendMessage(message);
    }
}
class ProxyMessageHandler extends BaseWalletTransport {
    constructor(walletRequestHandler, port){
        super(walletRequestHandler);
        this.port = void 0;
        this.port = port;
        this._init = InitState.OK;
    }
    register() {
        this.port.handleMessage = (message)=>{
            this.handleMessage(message);
        };
        this._registered = true;
    }
    // note: we can't decide whether to restore the session within register(), because session info is
    // received asyncronously via EventType.OPEN after register() is executed.
    // And in the case of a redirect/reload, EventType.OPEN is not sent at all,
    // because the wallet is already open.
    //
    // call this method from wallet redirect hander when a session restore is needed
    async restoreSession() {
        const cachedSession = await this.getCachedTransportSession();
        if (cachedSession) this.open(cachedSession);
    }
    unregister() {
        // @ts-ignore
        this.port.handleMessage = undefined;
        this._registered = false;
    }
    sendMessage(message) {
        this.port.sendMessage(message);
    }
}
/**
 * This will redirect console logs from Sequence.js & the wallet to the Unreal console, for debugging purposes.
 */ function overrideLogs(side) {
    var _window$ue;
    if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport && !window.logsOverriddenForUnreal) {
        var _window$ue2;
        const t = (_window$ue2 = window.ue) == null ? void 0 : _window$ue2.sequencewallettransport;
        console.log = (...args)=>{
            t.logfromjs(`${side}: ${stringify(args)}`);
        };
        console.warn = (...args)=>{
            t.warnfromjs(`${side}: ${stringify(args)}`);
        };
        console.error = (...args)=>{
            t.errorfromjs(`${side}: ${stringify(args)}`);
        };
        window.logsOverriddenForUnreal = true;
    }
}
function stringify(things) {
    return things.map((a)=>typeof a === "object" ? a instanceof Error ? a.message : JSON.stringify(a) : String(a)).join(" ");
}
let registeredUnrealMessageProvider;
// all lowercase is an annoying limitation of Unreal CEF BindUObject
/**
 * Initialized on dApp side
 */ class UnrealMessageProvider extends BaseProviderTransport {
    constructor(walletAppURL){
        super();
        this.walletURL = void 0;
        this.register = ()=>{
            var _window$ue;
            overrideLogs("dapp");
            if (registeredUnrealMessageProvider) {
                // overriding the registered message provider
                registeredUnrealMessageProvider.unregister();
                registeredUnrealMessageProvider = this;
            }
            // listen for incoming messages from wallet
            if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport) window.ue.sequencewallettransport.onmessagefromwallet = this.onUnrealCallback;
            registeredUnrealMessageProvider = this;
            this._registered = true;
            console.log("registering transport!");
        };
        this.unregister = ()=>{
            var _window$ue2;
            this._registered = false;
            this.closeWallet();
            // disable message listener
            if (registeredUnrealMessageProvider === this) registeredUnrealMessageProvider = undefined;
            if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromwallet) === this.onUnrealCallback) delete window.ue.sequencewallettransport.onmessagefromwallet;
            // clear event listeners
            this.events.removeAllListeners();
        };
        this.openWallet = (path, intent, networkId)=>{
            if (this.isOpened()) {
                // TODO focus wallet
                console.log("wallet already open!");
                return;
            }
            console.log("opening wallet!");
            // Instantiate new walletURL for this call
            const walletURL = new URL(this.walletURL.href);
            const windowSessionParams = new WindowSessionParams();
            if (path) walletURL.pathname = path.toLowerCase();
            // Set session, intent and network id on walletURL
            this._init = InitState.NIL;
            this._sessionId = `${performance.now()}`;
            windowSessionParams.set("sid", this._sessionId);
            if (intent) // encode intent as base64 url-encoded param
            windowSessionParams.set("intent", (0, _utils.base64EncodeObject)(intent));
            if (networkId) windowSessionParams.set("net", `${networkId}`);
            // serialize params
            walletURL.search = windowSessionParams.toString();
            console.log("opening wallet to", walletURL.href);
            window.open(walletURL.href);
        };
        // onmessage, receives ProviderMessageResponse from the wallet unreal transport
        this.onUnrealCallback = (message)=>{
            if (!message) throw new Error("ProviderMessage object is empty");
            // handle message with base message provider
            this.handleMessage(message);
        };
        this.walletURL = new URL(walletAppURL);
    }
    closeWallet() {
        this.close();
    }
    // all lowercase is an annoying limitation of Unreal CEF BindUObject
    sendMessage(message) {
        var _window$ue3;
        const postedMessage = typeof message !== "string" ? JSON.stringify(message) : message;
        console.log("Sending message to wallet:", postedMessage);
        (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetowallet(postedMessage);
    }
}
// all lowercase is an annoying limitation of Unreal CEF BindUObject
/**
 * Initialized on Wallet side
 */ class UnrealMessageHandler extends BaseWalletTransport {
    constructor(walletRequestHandler){
        super(walletRequestHandler);
        // onmessage is called when (the wallet) receives request messages from the dapp
        // over the unreal json-messaging transport
        this.onMessageFromUnreal = (request)=>{
            // Wallet always expects json-rpc request messages from a dapp
            (0, _utils.logger).debug("RECEIVED MESSAGE", request);
            // Handle message via the base transport
            this.handleMessage(request);
        };
        this.getUnrealTransportSession = (windowParams)=>{
            const params = new WindowSessionParams(windowParams);
            return {
                sessionId: params.get("sid"),
                networkId: params.get("net"),
                intent: (0, _utils.base64DecodeObject)(params.get("intent"))
            };
        };
        this._init = InitState.NIL;
    }
    async register(windowHref) {
        var _window$ue;
        if (((_window$ue = window.ue) == null ? void 0 : _window$ue.sequencewallettransport) === undefined) return;
        overrideLogs("wallet");
        // record open details (sessionId + default network) from the window url
        const { search: rawParams } = new URL(windowHref || window.location.href);
        let session = this.getUnrealTransportSession(rawParams);
        // provider should always include sid when opening a new window
        const isNewWindowSession = !!session.sessionId;
        // attempt to restore previous session in the case of a redirect or window reload
        if (!isNewWindowSession) session = await this.getCachedTransportSession();
        if (!session) {
            (0, _utils.logger).error("unreal session is undefined");
            return;
        }
        // listen for window-transport requests
        window.ue.sequencewallettransport.onmessagefromsequencejs = this.onMessageFromUnreal;
        this._registered = true;
        // send open event to the app which opened us
        this.open(session).then((opened)=>{
            if (!opened) {
                var _session;
                const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
                (0, _utils.logger).error(err);
                this.notifyClose({
                    message: err
                });
                window.close();
            }
        }).catch((e)=>{
            var _session2;
            const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;
            (0, _utils.logger).error(err);
            this.notifyClose({
                message: err
            });
            window.close();
        });
    }
    unregister() {
        var _window$ue2;
        if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromsequencejs) === this.onMessageFromUnreal) delete window.ue.sequencewallettransport.onmessagefromsequencejs;
        this._registered = false;
    }
    // sendMessage sends message to the dapp window
    sendMessage(message) {
        var _window$ue3;
        if (message.type !== EventType.INIT && this._init !== InitState.OK) {
            (0, _utils.logger).error("impossible state, should not be calling postMessage until inited");
            return;
        }
        // prepare payload
        const payload = JSON.stringify(message);
        // post-message to app.
        (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetosequencejs(payload);
    }
}
const CHANNEL_ID = "sequence-extension-message-handler";
class ExtensionMessageHandler extends BaseWalletTransport {
    constructor(walletRequestHandler, runtime){
        super(walletRequestHandler);
        this.runtime = runtime;
        this.port = void 0;
        this._init = InitState.OK;
    }
    register() {
        this._registered = true;
        this.port = this.runtime.connect({
            name: CHANNEL_ID
        });
    }
    sendMessage(message) {
        (0, _utils.logger).info("[ExtensionMessageHandler send]", message);
        this.port.postMessage(message);
    }
}
class ExtensionMessageProvider extends BaseProviderTransport {
    constructor(runtime){
        super();
        this.register = ()=>{
            this._registered = true;
        };
        runtime.onConnect.addListener((port)=>{
            if (port.name === CHANNEL_ID) {
                this._init = InitState.OK;
                port.onMessage.addListener((message)=>{
                    this.handleMessage(message);
                });
            }
        });
    }
    sendMessage(message) {
    //noop
    }
    unregister() {
    //noop
    }
    openWallet(path, intent, networkId) {
    //noop
    }
    closeWallet() {
    //noop
    }
}
// to be used on injected window.ethereum EIP1193 proxy
class BaseInjectedTransport extends (0, _eventemitter2.EventEmitter2) {
    constructor(stream){
        var _this;
        super();
        _this = this;
        this.stream = stream;
        this.responseCallbacks = new Map();
        this._messageIdx = 0;
        this.nextMessageIdx = ()=>++this._messageIdx;
        this.handleMessage = (message)=>{
            if (!message.type || !message.data) return;
            (0, _utils.logger).info("[received message]", message);
            const requestIdx = message.idx;
            const responseCallback = this.responseCallbacks.get(requestIdx);
            if (requestIdx) this.responseCallbacks.delete(requestIdx);
            switch(message.type){
                case EventType.MESSAGE:
                    if (responseCallback) {
                        this.emit(EventType.MESSAGE, message);
                        responseCallback(message.data.error, message);
                    } else // NOTE: this would occur if 'idx' isn't set, which should never happen
                    // or when we register two handler, or duplicate messages with the same idx are sent,
                    // all of which should be prevented prior to getting to this point
                    throw new Error("impossible state");
                    break;
                case EventType.DISCONNECT:
                case EventType.ACCOUNTS_CHANGED:
                case EventType.CHAIN_CHANGED:
                    this.emit(message.type, message.data);
                    break;
                default:
                    console.error("unknown message type", message);
                    break;
            }
        };
        this.sendMessageRequest = async function(message) {
            return new Promise((resolve, reject)=>{
                if (!message.idx || message.idx <= 0) reject(new Error("message idx not set"));
                const responseCallback = (error, response)=>{
                    if (error) reject(error);
                    else if (response) resolve(response);
                    else throw new Error("no valid response to return");
                };
                const { idx } = message;
                if (!_this.responseCallbacks.get(idx)) _this.responseCallbacks.set(idx, responseCallback);
                else reject(new Error("duplicate message idx, should never happen"));
                _this.sendMessage(message);
            });
        };
        this.stream.on("data", this.handleMessage);
    }
    sendMessage(message) {
        if (!this.stream.writable) console.error("window post message stream is not writable");
        this.stream.write(message);
    }
}
// ..
let registeredWindowMessageProvider;
class WindowMessageProvider extends BaseProviderTransport {
    constructor(walletAppURL){
        super();
        this.walletURL = void 0;
        this.walletWindow = void 0;
        this.register = ()=>{
            if (registeredWindowMessageProvider) {
                // overriding the registered message provider
                registeredWindowMessageProvider.unregister();
                registeredWindowMessageProvider = this;
            }
            // listen for incoming messages from wallet
            window.addEventListener("message", this.onWindowEvent);
            registeredWindowMessageProvider = this;
            // open heartbeat
            this.on("open", ()=>{
                // Heartbeat to track if window closed
                const popup = this.walletWindow;
                const interval = setInterval(()=>{
                    if (popup && popup.closed) {
                        clearInterval(interval);
                        this.close();
                    }
                }, 500);
            });
            // close clean up
            this.on("close", ()=>{
                if (this.walletWindow) {
                    this.walletWindow.close();
                    this.walletWindow = null;
                }
            });
            this._registered = true;
        };
        this.unregister = ()=>{
            this._registered = false;
            this.closeWallet();
            // disable message listener
            if (registeredWindowMessageProvider === this) registeredWindowMessageProvider = undefined;
            window.removeEventListener("message", this.onWindowEvent);
            // clear event listeners
            this.events.removeAllListeners();
        };
        this.openWallet = (path, intent, networkId)=>{
            if (this.walletWindow && this.isOpened()) {
                // TODO: update the location of window to path
                this.walletWindow.focus();
                return;
            }
            // Instantiate new walletURL for this call
            const walletURL = new URL(this.walletURL.href);
            const windowSessionParams = new WindowSessionParams();
            if (path && path !== "") walletURL.pathname = path.toLowerCase();
            // Set session, intent and network id on walletURL
            this._init = InitState.NIL;
            this._sessionId = `${performance.now()}`;
            windowSessionParams.set("sid", this._sessionId);
            if (intent) {
                // for the window-transport, we eagerly/optimistically set the origin host
                // when connecting to the wallet, however, this will be verified and enforced
                // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.
                if (intent.type === "connect") {
                    if (!intent.options) intent.options = {
                        app: window.location.origin
                    };
                    // skip setting origin host if we're in an browser extension execution context
                    // allow origin that is passed in
                    if (!isBrowserExtension() && !isUnityPlugin() && intent.options) intent.options.origin = window.location.origin;
                }
                // encode intent as base64 url-encoded param
                windowSessionParams.set("intent", (0, _utils.base64EncodeObject)(intent));
            }
            if (networkId) windowSessionParams.set("net", `${networkId}`);
            // Open popup window on center of the app window
            let windowSize;
            let windowPos;
            if (isBrowserExtension()) {
                windowSize = [
                    450,
                    750
                ];
                windowPos = [
                    Math.abs(window.screen.width / 2 - windowSize[0] / 2),
                    Math.abs(window.screen.height / 2 - windowSize[1] / 2)
                ];
            } else {
                windowSize = [
                    450,
                    750
                ];
                windowPos = [
                    Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2),
                    Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)
                ];
            }
            const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` + `,width=${windowSize[0]},height=${windowSize[1]}` + `,left=${windowPos[0]},top=${windowPos[1]}`;
            // serialize params
            walletURL.search = windowSessionParams.toString();
            this.walletWindow = window.open(walletURL.href, "sequence.app", windowFeatures);
        // TODO: move this somewhere else
        // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.
        // Popup blocking detection and notice
        // let warned = false
        // const warnPopupBlocked = () => {
        //   if (warned) return
        //   warned = true
        //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only
        //   throw new Error('popup is blocked')
        // }
        // const popupCheck = setTimeout(() => {
        //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {
        //     // popup is definitely blocked if we reach here.
        //     warnPopupBlocked()
        //   }
        // }, 1000)
        // const popupBlocked = popup === null || popup === undefined
        // if (popupBlocked) {
        //   warnPopupBlocked()
        //   return
        // }
        };
        // onmessage, receives ProviderMessageResponse from the wallet post-message transport
        this.onWindowEvent = (event)=>{
            // Security check, ensure message is coming from wallet origin url
            if (event.origin !== this.walletURL.origin) // Safetly can skip events not from the wallet
            return;
            let message;
            try {
                message = JSON.parse(event.data);
            } catch (err) {
                // event is not a ProviderMessage JSON object, skip
                return;
            }
            if (!message) throw new Error("ProviderMessage object is empty");
            // handle message with base message provider
            this.handleMessage(message);
        };
        this.walletURL = new URL(walletAppURL);
    }
    closeWallet() {
        var _this$walletWindow;
        this.close();
        (_this$walletWindow = this.walletWindow) == null || _this$walletWindow.close();
    }
    sendMessage(message) {
        if (!this.walletWindow) {
            (0, _utils.logger).warn("WindowMessageProvider: sendMessage failed as walletWindow is unavailable");
            return;
        }
        const postedMessage = typeof message !== "string" ? JSON.stringify(message) : message;
        this.walletWindow.postMessage(postedMessage, this.walletURL.origin);
    }
}
class WindowMessageHandler extends BaseWalletTransport {
    constructor(walletRequestHandler){
        var _this;
        super(walletRequestHandler);
        _this = this;
        this.parentWindow = void 0;
        this._isPopup = false;
        // onmessage is called when (the wallet) receives request messages from the dapp
        // over the window post-messaging transport
        this.onWindowEvent = async function(event) {
            if (!event.origin || event.origin === "") // skip same-origin or when event.origin is empty/undefined
            return;
            if (_this.appOrigin && event.origin !== _this.appOrigin) // skip message as not from expected app origin
            return;
            // Wallet always expects json-rpc request messages from a dapp
            let request;
            try {
                request = JSON.parse(event.data);
            } catch (err) {
                // event is not a ProviderMessage JSON object, skip
                return;
            }
            (0, _utils.logger).debug("RECEIVED MESSAGE", request);
            // Record event origin for valid init ack
            if (_this._init !== InitState.OK && _this.isValidInitAck(request)) _this.appOrigin = event.origin;
            if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {
                // impossible state
                (0, _utils.logger).error("impossible state, init.OK and appOrigin required");
                return;
            }
            // Handle message via the base transport
            _this.handleMessage(request);
        };
        this.getWindowTransportSession = (windowParams)=>{
            const params = new WindowSessionParams(windowParams);
            return {
                sessionId: params.get("sid"),
                networkId: params.get("net"),
                intent: (0, _utils.base64DecodeObject)(params.get("intent"))
            };
        };
        this._init = InitState.NIL;
    }
    async register(windowHref) {
        const isPopup = parent.window.opener !== null;
        this._isPopup = isPopup;
        if (isPopup !== true) return;
        // record open details (sessionId + default network) from the window url
        const { pathname, search: rawParams } = new URL(windowHref || window.location.href);
        let session = this.getWindowTransportSession(rawParams);
        // provider should always include sid when opening a new window
        const isNewWindowSession = !!session.sessionId;
        // attempt to restore previous session in the case of a redirect or window reload
        if (!isNewWindowSession) session = await this.getCachedTransportSession();
        if (!session) {
            (0, _utils.logger).error("window session is undefined");
            return;
        }
        // record parent window instance for communication
        this.parentWindow = parent.window.opener;
        // listen for window-transport requests
        window.addEventListener("message", this.onWindowEvent, false);
        this._registered = true;
        // send open event to the app which opened us
        this.open(session).then((opened)=>{
            if (!opened) {
                var _session;
                const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
                (0, _utils.logger).error(err);
                this.notifyClose({
                    message: err
                });
                window.close();
            }
        }).catch((e)=>{
            var _session2;
            const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;
            (0, _utils.logger).error(err);
            this.notifyClose({
                message: err
            });
            window.close();
        });
    }
    unregister() {
        window.removeEventListener("message", this.onWindowEvent);
        this._registered = false;
    }
    // postMessage sends message to the dapp window
    sendMessage(message) {
        // prepare payload
        const payload = JSON.stringify(message);
        // post-message to app.
        // only for init requests, we send to '*' origin
        if (message.type === EventType.INIT) this.postMessage(payload, true);
        else this.postMessage(payload);
    }
    get isPopup() {
        return this._isPopup;
    }
    postMessage(message, init = false) {
        if (init !== true && this._init !== InitState.OK) {
            (0, _utils.logger).error("impossible state, should not be calling postMessage until inited");
            return;
        }
        if (init) // init message transmission to global target -- for 'init' payloads only
        this.parentWindow.postMessage(message, "*");
        else // open message transmission
        if (this.appOrigin && this.appOrigin.length > 4) // just above '.com'
        this.parentWindow.postMessage(message, this.appOrigin);
        else (0, _utils.logger).error("unable to postMessage as parentOrigin is invalid");
    }
}
function isMuxTransportTemplate(obj) {
    return obj && typeof obj === "object" && (obj.windowTransport && typeof obj.windowTransport === "object" || obj.proxyTransport && typeof obj.proxyTransport === "object" || obj.extensionTransport && typeof obj.extensionTransport === "object" || obj.unrealTransport && typeof obj.unrealTransport === "object") && // One of the transports must be enabled
    (obj.windowTransport && obj.windowTransport.enabled || obj.proxyTransport && obj.proxyTransport.enabled || obj.extensionTransport && obj.extensionTransport.enabled || obj.unrealTransport && obj.unrealTransport.enabled);
}
class MuxMessageProvider {
    constructor(...messageProviders){
        var _this = this;
        this.messageProviders = void 0;
        this.provider = void 0;
        this.register = ()=>{
            if (this.messageProviders.length === 1) {
                this.provider = this.messageProviders[0];
                this.provider.register();
                return;
            }
            // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes
            // when the browser quits or restarts, the "open" event is never triggered. Perhaps the code here is fine,
            // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet
            // below, in which case one of the events will register. So perhaps this is fine.
            this.messageProviders.forEach((m)=>{
                m.register();
                m.once("open", ()=>{
                    // the first one to open is the winner, and others will be unregistered
                    if (!this.provider) {
                        this.provider = m;
                        // unregister other providers
                        this.messageProviders.forEach((m)=>{
                            if (this.provider !== m) m.unregister();
                        });
                    }
                });
            });
        };
        this.unregister = ()=>{
            this.messageProviders.forEach((m)=>m.unregister());
            this.provider = undefined;
        };
        this.openWallet = (path, intent, networkId)=>{
            if (this.provider) {
                this.provider.openWallet(path, intent, networkId);
                return;
            }
            this.messageProviders.forEach((m)=>m.openWallet(path, intent, networkId));
        };
        this.sendAsync = async function(request, callback, chainId) {
            if (_this.provider) {
                _this.provider.sendAsync(request, callback, chainId);
                return;
            }
            throw new Error("impossible state, wallet must be opened first");
        };
        this.sendMessageRequest = async function(message) {
            if (_this.provider) return _this.provider.sendMessageRequest(message);
            throw new Error("impossible state, wallet must be opened first");
        };
        this.waitUntilOpened = async function() {
            if (_this.provider) return _this.provider.waitUntilOpened();
            return Promise.race(_this.messageProviders.map((p)=>p.waitUntilOpened()));
        };
        this.waitUntilConnected = async function() {
            if (_this.provider) return _this.provider.waitUntilConnected();
            throw new Error("impossible state, wallet must be opened first");
        };
        this.messageProviders = messageProviders;
        this.provider = undefined;
    }
    static new(template) {
        var _template$windowTrans, _template$proxyTransp, _template$extensionTr, _template$unrealTrans;
        const muxMessageProvider = new MuxMessageProvider();
        if ((_template$windowTrans = template.windowTransport) != null && _template$windowTrans.enabled && typeof window === "object" && template.walletAppURL) {
            const windowMessageProvider = new WindowMessageProvider(template.walletAppURL);
            muxMessageProvider.add(windowMessageProvider);
        }
        if ((_template$proxyTransp = template.proxyTransport) != null && _template$proxyTransp.enabled) {
            const proxyMessageProvider = new ProxyMessageProvider(template.proxyTransport.appPort);
            muxMessageProvider.add(proxyMessageProvider);
        }
        if ((_template$extensionTr = template.extensionTransport) != null && _template$extensionTr.enabled) {
            const extensionMessageProvider = new ExtensionMessageProvider(template.extensionTransport.runtime);
            muxMessageProvider.add(extensionMessageProvider);
        // NOTE/REVIEW: see note in mux-message-provider
        //
        // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to
        // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break
        // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.
        }
        if ((_template$unrealTrans = template.unrealTransport) != null && _template$unrealTrans.enabled && template.windowTransport && template.walletAppURL) {
            const unrealMessageProvider = new UnrealMessageProvider(template.walletAppURL);
            muxMessageProvider.add(unrealMessageProvider);
        }
        muxMessageProvider.register();
        return muxMessageProvider;
    }
    add(...messageProviders) {
        this.messageProviders.push(...messageProviders);
    }
    closeWallet() {
        if (this.provider) this.provider.closeWallet();
    }
    isOpened() {
        if (this.provider) return this.provider.isOpened();
        return false;
    }
    isConnected() {
        if (this.provider) return this.provider.isConnected();
        return false;
    }
    on(event, fn) {
        if (this.provider) {
            this.provider.on(event, fn);
            return;
        }
        this.messageProviders.forEach((m)=>{
            m.on(event, fn);
        });
    }
    once(event, fn) {
        if (this.provider) {
            this.provider.once(event, fn);
            return;
        }
        this.messageProviders.forEach((m)=>{
            m.once(event, fn);
        });
    }
    emit(event, ...args) {
        if (this.provider) return this.provider.emit(event, ...args);
        for(let i = 0; i < this.messageProviders.length; i++)this.messageProviders[i].emit(event, ...args);
        return true;
    }
    sendMessage(message) {
        if (!message.idx || message.idx <= 0) throw new Error("message idx is empty");
        if (this.provider) this.provider.sendMessage(message);
        else throw new Error("impossible state, wallet must be opened first");
    }
    handleMessage(message) {
        if (this.provider) {
            this.provider.handleMessage(message);
            return;
        }
        throw new Error("impossible state, wallet must be opened first");
    }
}
function toExtended(transactions) {
    if (transactions.length === 0) throw new Error("No transaction provided");
    const [first, ...rest] = transactions;
    return _extends({}, first, {
        auxiliary: rest
    });
}
function fromExtended(transaction) {
    return [
        transaction,
        ...transaction.auxiliary || []
    ];
}
function validateTransactionRequest(wallet, transaction) {
    const transactions = (0, _core.commons).transaction.fromTransactionish(wallet, transaction);
    const unwound = (0, _core.commons).transaction.unwind(wallet, transactions);
    unwound.forEach((transaction)=>validateTransaction(wallet, transaction));
}
function validateTransaction(wallet, transaction) {
    if (transaction.to.toLowerCase() === wallet.toLowerCase()) {
        if (transaction.data) {
            const data = (0, _ethers.ethers).utils.arrayify(transaction.data);
            if (data.length >= 4 && !isCreateContractCall(data)) throw new Error("self calls are forbidden");
        }
    }
    if (transaction.delegateCall) throw new Error("delegate calls are forbidden");
}
function isCreateContractCall(data) {
    const walletInterface = new (0, _ethers.ethers).utils.Interface((0, _abi.walletContracts).mainModule.abi);
    try {
        walletInterface.decodeFunctionData("createContract", data);
        return true;
    } catch (_unused) {
        return false;
    }
}
const SIGNER_READY_TIMEOUT = 10000;
class WalletRequestHandler {
    constructor(_account, prompter, networks){
        var _this = this;
        // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined
        // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course
        // a Signer value is the actually interface to a signed-in account
        this.account = void 0;
        this.signerReadyCallbacks = [];
        this.prompter = void 0;
        this.networks = void 0;
        this._openIntent = void 0;
        this._connectOptions = void 0;
        this.events = new (0, _eventemitter2.EventEmitter2)();
        this.onConnectOptionsChange = undefined;
        this.promptConnect = async function(options) {
            if (!options && !_this._connectOptions) // this is an unexpected state and should not happen
            throw new Error("prompter connect options are empty");
            if (!_this.prompter) // if prompter is null, we'll auto connect
            return _this.connect(options);
            const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch((_)=>{
                return {
                    connected: false
                };
            });
            const connectDetails = promptConnectDetails;
            if (connectDetails.connected && !connectDetails.session) connectDetails.session = await _this.walletSession(options == null ? void 0 : options.networkId);
            return promptConnectDetails;
        };
        // sendAsync implements the JsonRpcHandler interface for sending JsonRpcRequests to the wallet
        this.sendAsync = async function(request, callback, chainId) {
            const response = {
                jsonrpc: "2.0",
                id: request.id,
                result: null
            };
            await _this.getAccount();
            try {
                var _this$account;
                // only allow public json rpc method to the provider when user is not logged in, aka signer is not set
                if ((!_this.account || _this.account === null) && !permittedJsonRpcMethods.includes(request.method)) // throw new Error(`not logged in. ${request.method} is unavailable`)
                throw ErrSignedInRequired;
                // wallet account
                const account = _this.account;
                if (!account) throw new Error("WalletRequestHandler: wallet account is not configured");
                // fetch the provider for the specific chain, or undefined will select defaultChain
                const provider = (_this$account = _this.account) == null ? void 0 : _this$account.providerFor(chainId != null ? chainId : _this.defaultChainId());
                if (!provider) throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${chainId}`);
                const jsonRpcProvider = provider instanceof (0, _ethers.ethers).providers.JsonRpcProvider ? provider : undefined;
                switch(request.method){
                    case "net_version":
                        {
                            if (!jsonRpcProvider) throw new Error(`Account provider doesn't support send method`);
                            const result = await jsonRpcProvider.send("net_version", []);
                            response.result = result;
                            break;
                        }
                    case "eth_chainId":
                        {
                            if (!jsonRpcProvider) throw new Error(`Account provider doesn't support send method`);
                            const result = await jsonRpcProvider.send("eth_chainId", []);
                            response.result = result;
                            break;
                        }
                    case "eth_accounts":
                        {
                            const walletAddress = account.address;
                            response.result = [
                                walletAddress
                            ];
                            break;
                        }
                    case "eth_getBalance":
                        {
                            const [accountAddress, blockTag] = request.params;
                            const walletBalance = await provider.getBalance(accountAddress, blockTag);
                            response.result = walletBalance.toHexString();
                            break;
                        }
                    case "sequence_sign":
                    case "personal_sign":
                    case "eth_sign":
                        {
                            // note: message from json-rpc input is in hex format
                            let message;
                            // there is a difference in the order of the params:
                            // sequence_sign, personal_sign: [data, address]
                            // eth_sign: [address, data]
                            switch(request.method){
                                case "sequence_sign":
                                case "personal_sign":
                                    {
                                        const [data, _address] = request.params;
                                        message = data;
                                        break;
                                    }
                                case "eth_sign":
                                    {
                                        const [_address, data] = request.params;
                                        message = data;
                                        break;
                                    }
                            }
                            let sig = "";
                            // Message must be prefixed with "\x19Ethereum Signed Message:\n"
                            // as defined by EIP-191
                            const prefixedMessage = prefixEIP191Message(message);
                            // TODO:
                            // if (process.env.TEST_MODE === 'true' && this.prompter === null) {
                            const sequenceVerified = request.method === "sequence_sign";
                            if (_this.prompter === null) // prompter is null, so we'll sign from here
                            sig = await account.signMessage(prefixedMessage, chainId != null ? chainId : _this.defaultChainId(), sequenceVerified ? "eip6492" : "ignore");
                            else sig = await _this.prompter.promptSignMessage({
                                chainId: chainId,
                                message: prefixedMessage,
                                eip6492: sequenceVerified
                            }, _this.connectOptions);
                            if (sig && sig.length > 0) response.result = sig;
                            else // The user has declined the request when value is null
                            throw new Error("declined by user");
                            break;
                        }
                    case "sequence_signTypedData_v4":
                    case "eth_signTypedData":
                    case "eth_signTypedData_v4":
                        {
                            // note: signingAddress from json-rpc input is in hex format, and typedDataObject
                            // should be an object, but in some instances may be double string encoded
                            const [signingAddress, typedDataObject] = request.params;
                            let typedData = undefined;
                            if (typeof typedDataObject === "string") try {
                                typedData = JSON.parse(typedDataObject);
                            } catch (e) {
                                console.warn("walletRequestHandler: error parsing typedData", e);
                            }
                            else typedData = typedDataObject;
                            if (!typedData || !typedData.domain || !typedData.types || !typedData.message) throw new Error("invalid typedData object");
                            let sig = "";
                            const sequenceVerified = request.method === "sequence_signTypedData_v4";
                            if (_this.prompter === null) // prompter is null, so we'll sign from here
                            sig = await account.signTypedData(typedData.domain, typedData.types, typedData.message, chainId != null ? chainId : _this.defaultChainId(), sequenceVerified ? "eip6492" : "ignore");
                            else sig = await _this.prompter.promptSignMessage({
                                chainId: chainId,
                                typedData: typedData,
                                eip6492: sequenceVerified
                            }, _this.connectOptions);
                            if (sig && sig.length > 0) response.result = sig;
                            else // The user has declined the request when value is null
                            throw new Error("declined by user");
                            break;
                        }
                    case "eth_sendTransaction":
                        {
                            // https://eth.wiki/json-rpc/API#eth_sendtransaction
                            const transactionParams = fromExtended(request.params[0]).map((tx)=>{
                                // eth_sendTransaction uses 'gas'
                                // ethers and sequence use 'gasLimit'
                                if ("gas" in tx && tx.gasLimit === undefined) {
                                    tx.gasLimit = tx.gas;
                                    delete tx.gas;
                                }
                                return tx;
                            });
                            validateTransactionRequest(account.address, transactionParams);
                            let txnHash = "";
                            if (_this.prompter === null) {
                                var _txnResponse$hash;
                                // prompter is null, so we'll send from here
                                const txnResponse = await account.sendTransaction(transactionParams, chainId != null ? chainId : _this.defaultChainId());
                                txnHash = (_txnResponse$hash = txnResponse == null ? void 0 : txnResponse.hash) != null ? _txnResponse$hash : "";
                            } else // prompt user to provide the response
                            txnHash = await _this.prompter.promptSendTransaction(transactionParams, chainId, _this.connectOptions);
                            if (txnHash) response.result = txnHash;
                            else // The user has declined the request when value is null
                            throw new Error("declined by user");
                            break;
                        }
                    case "eth_signTransaction":
                        {
                            // https://eth.wiki/json-rpc/API#eth_signTransaction
                            const [transaction] = request.params;
                            const sender = (0, _ethers.ethers).utils.getAddress(transaction.from);
                            if (sender !== account.address) throw new Error("sender address does not match wallet");
                            validateTransactionRequest(account.address, transaction);
                            if (_this.prompter === null) // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,
                            // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.
                            //
                            // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however
                            // we will want to resolveProperties the big number values to hex strings
                            response.result = await account.signTransactions(transaction, chainId != null ? chainId : _this.defaultChainId());
                            else response.result = await _this.prompter.promptSignTransaction(transaction, chainId, _this.connectOptions);
                            break;
                        }
                    case "eth_sendRawTransaction":
                        // NOTE: we're not using a prompter here as the transaction is already signed
                        // and would have prompted the user upon signing.
                        // https://eth.wiki/json-rpc/API#eth_sendRawTransaction
                        if ((0, _core.commons).transaction.isSignedTransactionBundle(request.params[0])) {
                            const txChainId = (0, _ethers.BigNumber).from(request.params[0].chainId).toNumber();
                            const tx = await account.relayer(txChainId).relay(request.params[0]);
                            response.result = tx.hash;
                        } else {
                            const tx = await provider.sendTransaction(request.params[0]);
                            response.result = tx.hash;
                        }
                        break;
                    case "eth_getTransactionCount":
                        {
                            const address = (0, _ethers.ethers).utils.getAddress(request.params[0]);
                            const tag = request.params[1];
                            // TODO: Maybe we should fetch this data from the relayer or from the reader
                            // but for now we keep it simple and just use the provider
                            const count = await provider.getTransactionCount(address, tag);
                            response.result = (0, _ethers.ethers).BigNumber.from(count).toHexString();
                            break;
                        }
                    case "eth_blockNumber":
                        response.result = await provider.getBlockNumber();
                        break;
                    case "eth_getBlockByNumber":
                        response.result = await provider.getBlock(request.params[0]);
                        break;
                    case "eth_getBlockByHash":
                        response.result = await provider.getBlock(request.params[0]);
                        break;
                    case "eth_getTransactionByHash":
                        response.result = await provider.getTransaction(request.params[0]);
                        break;
                    case "eth_call":
                        {
                            const [transactionObject, blockTag] = request.params;
                            response.result = await provider.call(transactionObject, blockTag);
                            break;
                        }
                    case "eth_getCode":
                        {
                            const [contractAddress, blockTag] = request.params;
                            response.result = await provider.getCode(contractAddress, blockTag);
                            break;
                        }
                    case "eth_estimateGas":
                        {
                            const [transactionObject] = request.params;
                            response.result = await provider.estimateGas(transactionObject);
                            break;
                        }
                    case "eth_gasPrice":
                        {
                            const gasPrice = await provider.getGasPrice();
                            response.result = gasPrice.toHexString();
                            break;
                        }
                    case "wallet_switchEthereumChain":
                        {
                            const [switchParams] = request.params;
                            if (!switchParams.chainId || switchParams.chainId.length === 0) throw new Error("invalid chainId");
                            const _chainId = (0, _ethers.ethers).BigNumber.from(switchParams.chainId);
                            _this.setDefaultChainId(_chainId.toNumber());
                            response.result = null; // success
                            break;
                        }
                    // smart wallet method
                    case "sequence_getWalletContext":
                        response.result = account.contexts;
                        break;
                    // smart wallet method
                    case "sequence_getWalletConfig":
                        {
                            const [_chainId2] = request.params;
                            if (_chainId2) response.result = [
                                (await account.status(_chainId2)).onChain.config
                            ];
                            else response.result = await Promise.all(account.networks.map(async function(network) {
                                const status = await account.status(network.chainId);
                                return status.onChain.config;
                            }));
                            break;
                        }
                    // smart wallet method
                    case "sequence_getWalletState":
                        {
                            const [_chainId3] = request.params;
                            // TODO: Add getWalletState to the Signer interface
                            if (_chainId3) response.result = [
                                getLegacyWalletState(_chainId3, await account.status(_chainId3))
                            ];
                            else response.result = await Promise.all(account.networks.map(async function(network) {
                                const status = await account.status(network.chainId);
                                return getLegacyWalletState(network.chainId, status);
                            }));
                            break;
                        }
                    // smart wallet method
                    case "sequence_getNetworks":
                        // NOTE: must ensure that the response result below returns clean serialized data, which is to omit
                        // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.
                        // This is handled by this.getNetworks() but noted here for future readers.
                        response.result = await _this.getNetworks(true);
                        break;
                    case "sequence_isSequence":
                        response.result = true;
                        break;
                    // smart wallet method
                    case "sequence_updateConfig":
                        throw new Error("sequence_updateConfig method is not allowed from a dapp");
                    // smart wallet method
                    case "sequence_publishConfig":
                        throw new Error("sequence_publishConfig method is not allowed from a dapp");
                    // relayer method
                    case "sequence_gasRefundOptions":
                        break;
                    // relayer method
                    case "sequence_getNonce":
                        break;
                    // relayer method
                    case "sequence_relay":
                        break;
                    // set default network of wallet
                    case "sequence_setDefaultNetwork":
                        {
                            const [defaultChainId] = request.params;
                            if (!defaultChainId) throw new Error("invalid request, method argument defaultChainId cannot be empty");
                            _this.setDefaultChainId(defaultChainId);
                            response.result = await _this.getNetworks(true);
                            break;
                        }
                    default:
                        {
                            if (!jsonRpcProvider) throw new Error(`Account provider doesn't support send method`);
                            // NOTE: provider here will be chain-bound if chainId is provided
                            const providerResponse = await jsonRpcProvider.send(request.method, request.params);
                            response.result = providerResponse;
                        }
                }
            } catch (err) {
                (0, _utils.logger).error(err);
                // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md#rpc-errors
                response.result = null;
                response.error = _extends({}, new Error(err), {
                    code: 4001
                });
            }
            callback(undefined, response);
        };
        this.isSignedIn = async function() {
            await _this.signerReady();
            return !!_this.account;
        };
        this.getAccount = async function() {
            await _this.signerReady();
            if (_this.account === undefined) throw new Error("signerReady failed resolve");
            return _this.account;
        };
        this.account = _account;
        this.prompter = prompter;
        this.networks = networks;
    }
    defaultChainId() {
        var _this$prompter$getDef, _this$prompter;
        return (_this$prompter$getDef = (_this$prompter = this.prompter) == null ? void 0 : _this$prompter.getDefaultChainId()) != null ? _this$prompter$getDef : this.networks[0].chainId;
    }
    async signIn(account, options = {}) {
        this.setAccount(account);
        const { connect, defaultNetworkId } = options;
        // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform
        // necessary auth request, and then notify the dapp of the 'connect' details.
        //
        // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made
        // we don't trigger the promptConnect flow, as we consider the user just authenticated
        // for this dapp, so its safe to authorize in the promptSignInConnect() which will directly
        // connect after signing in.
        //
        // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows
        if (connect) {
            const connectOptions = this._connectOptions;
            let connectDetails;
            if (this.prompter !== null) {
                var _this$prompter2;
                connectDetails = await ((_this$prompter2 = this.prompter) == null ? void 0 : _this$prompter2.promptSignInConnect(connectOptions));
            } else connectDetails = await this.connect(connectOptions);
            this.notifyConnect(connectDetails);
            if (!connectOptions || connectOptions.keepWalletOpened !== true) this.notifyClose();
        }
        if (defaultNetworkId && this.defaultChainId() !== defaultNetworkId) {
            var _this$prompter3;
            await ((_this$prompter3 = this.prompter) == null ? void 0 : _this$prompter3.promptChangeNetwork(defaultNetworkId));
        }
    }
    signOut() {
        if (this.account) this.notifyDisconnect();
        // signed out state
        this.setAccount(null);
    }
    signerReset() {
        // resetting signer puts the wallet in an uninitialized state, which requires the app to
        // re-initiatize and set the signer either as "null" (ie. no signer) or "Signer" (ie. signed in).
        this.account = undefined;
    }
    signerReady(timeout = SIGNER_READY_TIMEOUT) {
        return new Promise((resolve, reject)=>{
            if (this.account !== undefined) resolve();
            else {
                setTimeout(()=>{
                    if (this.account === undefined) {
                        this.signerReadyCallbacks = [];
                        reject(`signerReady timed out`);
                    }
                }, timeout);
                this.signerReadyCallbacks.push(resolve);
            }
        });
    }
    async connect(options) {
        var _ref, _options$networkId;
        if (!this.account) return {
            connected: false,
            chainId: "0x0",
            error: "unable to connect without signed in account"
        };
        const networkId = (_ref = (_options$networkId = options == null ? void 0 : options.networkId) != null ? _options$networkId : this.defaultChainId()) != null ? _ref : (0, _network.ChainId).MAINNET;
        const chainId = (0, _network.findSupportedNetwork)(networkId).chainId;
        const connectDetails = {
            connected: true,
            chainId: (0, _ethers.ethers).utils.hexValue(chainId)
        };
        if (options && options.authorize) {
            // Perform ethauth eip712 request and construct the ConnectDetails response
            // including the auth proof
            const authOptions = {
                app: options.app,
                origin: options.origin,
                expiry: options.expiry,
                nonce: options.authorizeNonce
            };
            // if (typeof(options.authorize) === 'object') {
            //   authOptions = { ...authOptions, ...options.authorize }
            // }
            try {
                // TODO: Either implement account as a signer, or change signAuthorization to accept an account
                connectDetails.proof = await (0, _auth.signAuthorization)(this.account, chainId, authOptions);
            } catch (err) {
                (0, _utils.logger).warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);
                return {
                    connected: false,
                    chainId: "0x0",
                    error: `signAuthorization failed: ${err.message}`
                };
            }
        }
        // Build session response for connect details
        connectDetails.session = this.walletSession(chainId);
        return connectDetails;
    }
    // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler
    // (aka, the signer in this instance) and then responds with a wrapped response of
    // ProviderMessageResponse to be sent over the transport
    sendMessageRequest(message) {
        return new Promise((resolve)=>{
            this.sendAsync(message.data, (error, response)=>{
                // TODO: if response includes data.error, why do we need a separate error argument here?
                const responseMessage = _extends({}, message, {
                    data: response
                });
                // NOTE: we always resolve here, are the sendAsync call will wrap any exceptions
                // in the error field of the response to ensure we send back to the user
                resolve(responseMessage);
            }, message.chainId);
        });
    }
    on(event, fn) {
        this.events.on(event, fn);
    }
    once(event, fn) {
        this.events.once(event, fn);
    }
    async getAddress() {
        var _this$account$address, _this$account2;
        return (_this$account$address = (_this$account2 = this.account) == null ? void 0 : _this$account2.address) != null ? _this$account$address : "";
    }
    get openIntent() {
        return this._openIntent;
    }
    setOpenIntent(intent) {
        this._openIntent = intent;
    }
    get connectOptions() {
        return this._connectOptions;
    }
    setConnectOptions(options) {
        var _this$onConnectOption;
        this._connectOptions = options;
        (_this$onConnectOption = this.onConnectOptionsChange) == null || _this$onConnectOption.call(this, options);
    }
    async setDefaultChainId(chainId) {
        var _this$prompter4;
        await ((_this$prompter4 = this.prompter) == null ? void 0 : _this$prompter4.promptChangeNetwork(chainId));
        return this.defaultChainId();
    }
    async getNetworks(jsonRpcResponse) {
        if (!this.account) {
            (0, _utils.logger).warn("signer not set: getNetworks is returning an empty list");
            return [];
        }
        if (jsonRpcResponse) // omit provider and relayer objects as they are not serializable
        return this.account.networks.map((n)=>{
            const network = _extends({}, n);
            network.provider = undefined;
            network.relayer = undefined;
            return network;
        });
        else return this.account.networks;
    }
    walletSession(networkId) {
        if (!this.account) return undefined;
        const session = {
            walletContext: this.account.contexts,
            accountAddress: this.account.address,
            // The dapp shouldn't access the relayer directly, and the provider (as an object) is not serializable.
            networks: this.account.networks.map((n)=>_extends({}, n, {
                    provider: undefined,
                    relayer: undefined
                }))
        };
        if (networkId) {
            const network = (0, _network.findNetworkConfig)(session.networks, networkId);
            if (network) {
                var _session$networks;
                // Delete the isDefaultChain property from the session network
                (_session$networks = session.networks) == null || _session$networks.forEach((n)=>delete n.isDefaultChain);
                // Add the isDefaultChain property to the network with the given networkId
                network.isDefaultChain = true;
            }
        }
        return session;
    }
    notifyConnect(connectDetails, origin) {
        var _connectDetails$sessi;
        console.log("emit connect", connectDetails);
        this.events.emit("connect", connectDetails);
        if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
            var _connectDetails$sessi2;
            this.events.emit("accountsChanged", [
                (_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress
            ], origin);
        }
    }
    notifyDisconnect(origin) {
        this.events.emit("accountsChanged", [], origin);
        this.events.emit("disconnect", undefined, origin);
    }
    notifyChainChanged(chainId, origin) {
        this.events.emit("chainChanged", (0, _ethers.ethers).utils.hexValue(chainId), origin);
    }
    async notifyNetworks(networks) {
        const n = networks || await this.getNetworks(true);
        this.events.emit("networks", n);
        if (n.length > 0) {
            const defaultNetwork = n.find((network)=>network.chainId === this.defaultChainId());
            if (defaultNetwork) this.events.emit("chainChanged", (0, _ethers.ethers).utils.hexValue(defaultNetwork.chainId));
        } else this.events.emit("chainChanged", "0x0");
    }
    async notifyWalletContext() {
        if (!this.account) {
            (0, _utils.logger).warn("signer not set: skipping to notify wallet context");
            return;
        }
        const walletContext = this.account.contexts;
        this.events.emit("walletContext", walletContext);
    }
    notifyClose(error) {
        this.events.emit("close", error);
    }
    setAccount(account) {
        this.account = account;
        if (account !== undefined) {
            for(let i = 0; i < this.signerReadyCallbacks.length; i++)this.signerReadyCallbacks[i]();
            this.signerReadyCallbacks = [];
        }
    }
    async handleConfirmWalletDeployPrompt(prompter, account, sequenceVerified, chainId) {
        // check if wallet is deployed and up to date, if not, prompt user to deploy
        // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date
        if (!chainId) return true;
        const skipsDeploy = (status)=>{
            return status.canOnchainValidate || status.original.version === 2 && sequenceVerified;
        };
        const status = await account.status(chainId);
        if (skipsDeploy(status)) return true;
        const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions);
        // if client returned true, check again to make sure wallet is deployed and up to date
        if (promptResult) {
            const status2 = await account.status(chainId);
            if (skipsDeploy(status2)) return true;
            else {
                (0, _utils.logger).error("WalletRequestHandler: result for promptConfirmWalletDeploy is not correct");
                return false;
            }
        }
        return false;
    }
}
function getLegacyWalletState(chainId, status) {
    return {
        context: status.original.context,
        config: status.onChain.config,
        address: (0, _core.commons).context.addressOf(status.original.context, status.original.imageHash),
        chainId,
        deployed: status.onChain.deployed,
        imageHash: status.imageHash,
        lastImageHash: status.onChain.imageHash,
        published: true,
        status
    };
}
const permittedJsonRpcMethods = [
    "net_version",
    "eth_chainId",
    "eth_getBalance",
    "eth_getTransactionCount",
    "eth_blockNumber",
    "eth_getBlockByNumber",
    "eth_getBlockByHash",
    "eth_getTransactionByHash",
    "eth_getCode",
    "eth_estimateGas",
    "eth_gasPrice",
    "sequence_getWalletContext",
    "sequence_getNetworks",
    "sequence_setDefaultNetwork"
];
class SequenceSigner {
    get utils() {
        return this.provider.utils;
    }
    constructor(client, provider){
        this.client = client;
        this.provider = provider;
        this.singleNetworkSigners = {};
        this._isSigner = true;
        this._isSequenceSigner = true;
    }
    async getAddress() {
        return this.client.getAddress();
    }
    // This method shouldn't be used directly
    // it exists to maintain compatibility with ethers.Signer
    connect(provider) {
        if (!SequenceProvider.is(provider)) throw new Error("SequenceSigner can only be connected to a SequenceProvider");
        return new SequenceSigner(this.client, provider);
    }
    getSigner(chainId) {
        // The signer for the default network is this signer
        if (!chainId) return this;
        const useChainId = this.provider.toChainId(chainId);
        if (!this.singleNetworkSigners[useChainId]) this.singleNetworkSigners[useChainId] = new SingleNetworkSequenceSigner(this.client, this.provider, useChainId);
        return this.singleNetworkSigners[useChainId];
    }
    /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */ useChainId(chainId) {
        return this.provider.toChainId(chainId) || this.client.getChainId();
    }
    async signMessage(message, options) {
        const { eip6492 = true } = options || {};
        const chainId = this.useChainId(options == null ? void 0 : options.chainId);
        return this.client.signMessage(message, {
            eip6492,
            chainId
        });
    }
    async signTypedData(domain, types, message, options) {
        const { eip6492 = true } = options || {};
        const chainId = this.useChainId(options == null ? void 0 : options.chainId);
        return this.client.signTypedData({
            domain,
            types,
            message
        }, {
            eip6492,
            chainId
        });
    }
    getProvider(chainId) {
        return this.provider.getProvider(chainId);
    }
    async sendTransaction(transaction, options) {
        const chainId = this.useChainId(options == null ? void 0 : options.chainId);
        const resolved = await resolveArrayProperties(transaction);
        const txHash = await this.client.sendTransaction(resolved, {
            chainId
        });
        const provider = this.getProvider(chainId);
        try {
            return await (0, _ethers.ethers).utils.poll(async function() {
                const tx = await provider.getTransaction(txHash);
                return tx ? provider._wrapTransaction(tx, txHash) : undefined;
            }, {
                onceBlock: provider
            });
        } catch (err) {
            err.transactionHash = txHash;
            throw err;
        }
    }
    async getWalletConfig(chainId) {
        const useChainId = this.useChainId(chainId);
        return this.client.getOnchainWalletConfig({
            chainId: useChainId
        });
    }
    getNetworks() {
        return this.client.getNetworks();
    }
    async getBalance(blockTag, optionals) {
        const provider = this.getProvider(optionals == null ? void 0 : optionals.chainId);
        return provider.getBalance(this.getAddress(), blockTag);
    }
    async estimateGas(transaction, optionals) {
        return this.getProvider(optionals == null ? void 0 : optionals.chainId).estimateGas(transaction);
    }
    async call(transaction, blockTag, optionals) {
        return this.getProvider(optionals == null ? void 0 : optionals.chainId).call(transaction, blockTag);
    }
    getChainId() {
        return Promise.resolve(this.client.getChainId());
    }
    async getGasPrice(optionals) {
        return this.getProvider(optionals == null ? void 0 : optionals.chainId).getGasPrice();
    }
    async getFeeData(optionals) {
        return this.getProvider(optionals == null ? void 0 : optionals.chainId).getFeeData();
    }
    async resolveName(name) {
        const res = await this.provider.resolveName(name);
        // For some reason ethers.Signer expects this to return `string`
        // but ethers.providers.Provider expects this to return `string | null`.
        // The signer doesn't have any other source of information, so we'll
        // fail if the provider doesn't return a result.
        if (res === null) throw new Error(`ENS name not found: ${name}`);
        return res;
    }
    _checkProvider(_operation) {
    // We always have a provider, so this is a noop
    }
    populateTransaction(_transaction) {
        throw new Error("SequenceSigner does not support populateTransaction");
    }
    checkTransaction(_transaction) {
        throw new Error("SequenceSigner does not support checkTransaction");
    }
    getTransactionCount(_blockTag) {
        // We could try returning the sequence nonce here
        // but we aren't sure how ethers will use this nonce
        throw new Error("SequenceSigner does not support getTransactionCount");
    }
    signTransaction(_transaction) {
        // We could implement signTransaction/sendTransaction here
        // but first we need a way of serializing these signed transactions
        // and it could lead to more trouble, because the dapp could try to send this transaction
        // using a different provider, which would fail.
        throw new Error("SequenceWallet does not support signTransaction, use sendTransaction instead.");
    }
    static is(cand) {
        return cand && typeof cand === "object" && cand._isSequenceSigner === true;
    }
}
/**
 *  This is the same provider, but it only allows a single network at a time.
 *  the network defined by the constructor is the only one that can be used.
 *
 *  Attempting to call any method with a different network will throw an error.
 *  Attempting to change the network of this provider will throw an error.
 *
 *  NOTICE: These networks won't support ENS unless they are the mainnet.
 */ class SingleNetworkSequenceSigner extends SequenceSigner {
    constructor(client, provider, chainId){
        super(client, provider.getProvider(chainId));
        this.chainId = chainId;
        this._isSingleNetworkSequenceSigner = true;
    }
    _useChainId(chainId) {
        const provided = this.provider.toChainId(chainId);
        if (provided && provided !== this.chainId) throw new Error(`This signer only supports the network ${this.chainId}, but ${provided} was requested.`);
        return provided || this.provider.toChainId(this.chainId);
    }
    useChainId(chainId) {
        return this._useChainId(chainId);
    }
    getChainId() {
        return Promise.resolve(this.provider.toChainId(this.chainId));
    }
    /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */ getProvider(chainId) {
        return super.getProvider(this._useChainId(chainId));
    }
    getSigner(chainId) {
        if (this._useChainId(chainId) !== this.chainId) throw new Error(`Unreachable code`);
        return this;
    }
    static is(cand) {
        return cand && typeof cand === "object" && cand._isSingleNetworkSequenceSigner === true;
    }
}
/**
 *  This class is redundant with the SequenceSigner class, but it is here for now to
 *  maintain compatibility with the old wallet API. Eventually we should move these
 *  methods to the SequenceSigner class and deprecate this class.
 */ class WalletUtils {
    constructor(signer){
        this.signer = signer;
        if (SingleNetworkSequenceSigner.is(signer)) throw new Error("WalletUtils does not support SingleNetworkSequenceSigner");
    }
    // Sign message on a specified chain, or DefaultChain by default
    signMessage(message, chainId, eip6492) {
        return this.signer.signMessage(message, {
            chainId,
            eip6492
        });
    }
    // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default
    signTypedData(domain, types, message, chainId, eip6492) {
        return this.signer.signTypedData(domain, types, message, {
            chainId,
            eip6492
        });
    }
    // Verify signature of a digest, one of a message, typedData or other
    async isValidSignature(address, digest, signature, chainId) {
        return isValidSignature(address, digest, signature, this.signer.getProvider(chainId));
    }
    // Verify message signature
    async isValidMessageSignature(address, message, signature, chainId) {
        const provider = this.signer.getProvider(chainId);
        const prefixed = prefixEIP191Message(message);
        const digest = (0, _utils.encodeMessageDigest)(prefixed);
        return isValidSignature(address, digest, signature, provider);
    }
    // Verify typedData signature
    isValidTypedDataSignature(address, typedData, signature, chainId) {
        return this.isValidSignature(address, (0, _utils.encodeTypedDataDigest)(typedData), signature, chainId);
    }
}
class SequenceProvider extends (0, _ethers.ethers).providers.BaseProvider {
    constructor(client, providerFor, networks = (0, _network.allNetworks)){
        // We support a lot of networks
        // but we start with the default one
        super(client.getChainId());
        // Emit events as defined by EIP-1193
        this.client = client;
        this.providerFor = providerFor;
        this.networks = networks;
        this.singleNetworkProviders = {};
        this._isSequenceProvider = true;
        this.utils = void 0;
        this.signer = void 0;
        client.onConnect((details)=>{
            this.emit("connect", details);
        });
        client.onDisconnect((error)=>{
            this.emit("disconnect", error);
        });
        client.onDefaultChainIdChanged((chainId)=>{
            this.emit("chainChanged", chainId);
        });
        client.onAccountsChanged((accounts)=>{
            this.emit("accountsChanged", accounts);
        });
        // NOTICE: We don't emit 'open' and 'close' events
        // because these are handled by the library, and they
        // are not part of EIP-1193
        // devs can still access them using
        //   client.onOpen()
        //   client.onClose()
        // Create a Sequence signer too
        this.signer = new SequenceSigner(this.client, this);
        // Create a utils instance
        this.utils = new WalletUtils(this.signer);
    }
    getSigner(chainId) {
        return this.signer.getSigner(chainId);
    }
    connect(options) {
        return this.client.connect(options);
    }
    disconnect() {
        return this.client.disconnect();
    }
    isConnected() {
        return this.client.isConnected();
    }
    getSession() {
        return this.client.getSession();
    }
    listAccounts() {
        return [
            this.client.getAddress()
        ];
    }
    // @deprecated use getSigner() instead
    getAddress() {
        return this.client.getAddress();
    }
    getNetworks() {
        return this.client.getNetworks();
    }
    getChainId() {
        return this.client.getChainId();
    }
    setDefaultChainId(chainId) {
        return this.client.setDefaultChainId(this.toChainId(chainId));
    }
    isOpened() {
        return this.client.isOpened();
    }
    closeWallet() {
        return this.client.closeWallet();
    }
    getWalletContext() {
        return this.client.getWalletContext();
    }
    // @deprecated use getSigner() instead
    async getWalletConfig(chainId) {
        const useChainId = await this.useChainId(chainId);
        return this.client.getOnchainWalletConfig({
            chainId: useChainId
        });
    }
    authorize(options) {
        // Just an alias for connect with authorize: true
        return this.client.connect(_extends({}, options, {
            authorize: true
        }));
    }
    async openWallet(path, intent) {
        await this.client.openWallet(path, intent);
        return true;
    }
    toChainId(chainId) {
        if (chainId === undefined) return undefined;
        const resolved = (0, _network.findNetworkConfig)(this.networks, chainId);
        if (!resolved) throw new Error(`Unsupported network ${chainId}`);
        return resolved.chainId;
    }
    /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */ async useChainId(chainId) {
        return this.toChainId(chainId) || this.client.getChainId();
    }
    /**
   *  This generates a provider that ONLY works for the given chainId.
   *  the generated provider can't switch networks, and can't handle requests
   *  for other networks.
   */ getProvider(chainId) {
        // The provider without a chainId is... this one
        if (!chainId) return this;
        const useChainId = this.toChainId(chainId);
        if (!this.singleNetworkProviders[useChainId]) this.singleNetworkProviders[useChainId] = new SingleNetworkSequenceProvider(this.client, this.providerFor, useChainId);
        return this.singleNetworkProviders[useChainId];
    }
    /**
   *  This returns a subprovider, this is a regular non-sequence provider that
   *  can be used to fulfill read only requests on a given network.
   */ async _getSubprovider(chainId) {
        const useChainId = await this.useChainId(chainId);
        // Whoever implements providerFrom should memoize the generated provider
        // otherwise every instance of SequenceProvider will create a new subprovider
        const provider = this.providerFor(useChainId);
        if (!provider) throw new Error(`Unsupported network ${useChainId}`);
        return provider;
    }
    async perform(method, params) {
        var _provider$prepareRequ;
        // First we check if the method should be handled by the client
        if (method === "eth_chainId") return (0, _ethers.ethers).utils.hexValue(await this.useChainId());
        if (method === "eth_accounts") return [
            this.client.getAddress()
        ];
        if (method === "wallet_switchEthereumChain") {
            const args = params[0];
            const chainId = normalizeChainId(args);
            return this.setDefaultChainId(chainId);
        }
        // Usually these methods aren't used by calling the provider
        // but to maximize compatibility we support them too.
        // The correct way of accessing these methods is by using .getSigner()
        if (method === "eth_sendTransaction" || method === "eth_sign" || method === "eth_signTypedData" || method === "eth_signTypedData_v4" || method === "personal_sign" || // These methods will use EIP-6492
        // but this is handled directly by the wallet
        method === "sequence_sign" || method === "sequence_signTypedData_v4") // We pass the chainId to the client, if we don't pass one
        // the client will use its own default chainId
        return this.client.send({
            method,
            params
        }, this.getChainId());
        // Forward call to the corresponding provider
        // we use the provided chainId, or the default one provided by the client
        const provider = await this._getSubprovider();
        const prepared = (_provider$prepareRequ = provider.prepareRequest(method, params)) != null ? _provider$prepareRequ : [
            method,
            params
        ];
        return provider.send(prepared[0], prepared[1]);
    }
    send(method, params) {
        return this.perform(method, params);
    }
    request(request) {
        return this.perform(request.method, request.params);
    }
    async detectNetwork() {
        const chainId = this.client.getChainId();
        const network = (0, _network.findNetworkConfig)(this.networks, chainId);
        if (!network) throw new Error(`Unknown network ${chainId}`);
        return network;
    }
    // Override most of the methods, so we add support for an optional chainId
    // argument, which is used to select the provider to use.
    //
    // NOTICE: We could use generics to avoid repeating the same code
    // but this would make the code harder to read, and it's not worth it
    // since we only have a few methods to override.
    async waitForTransaction(transactionHash, confirmations, timeout, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.waitForTransaction(transactionHash, confirmations, timeout);
    }
    async getBlockNumber(optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getBlockNumber();
    }
    async getGasPrice(optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getGasPrice();
    }
    async getBalance(addressOrName, blockTag, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getBalance(addressOrName, blockTag);
    }
    async getTransactionCount(addressOrName, blockTag, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getTransactionCount(addressOrName, blockTag);
    }
    async getCode(addressOrName, blockTag, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getCode(addressOrName, blockTag);
    }
    async getStorageAt(addressOrName, position, blockTag, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getStorageAt(addressOrName, position, blockTag);
    }
    async call(transaction, blockTag, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.call(transaction, blockTag);
    }
    async estimateGas(transaction, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.estimateGas(transaction);
    }
    async getBlock(blockHashOrBlockTag, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getBlock(blockHashOrBlockTag);
    }
    async getTransaction(transactionHash, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getTransaction(transactionHash);
    }
    async getLogs(filter, optionals) {
        const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
        return provider.getLogs(filter);
    }
    // ENS methods
    async supportsENS() {
        const networks = await this.getNetworks();
        return networks.some((n)=>n.chainId === 1);
    }
    async getResolver(name) {
        if (!await this.supportsENS()) return null;
        // Resolver is always on the chainId 1
        const provider = await this._getSubprovider(1);
        return provider.getResolver(name);
    }
    async resolveName(name) {
        if ((0, _ethers.ethers).utils.isAddress(await name)) return name;
        if (!await this.supportsENS()) return null;
        // Resolver is always on the chainId 1
        const provider = await this._getSubprovider(1);
        return provider.resolveName(name);
    }
    async lookupAddress(address) {
        if (!await this.supportsENS()) return null;
        // Resolver is always on the chainId 1
        const provider = await this._getSubprovider(1);
        return provider.lookupAddress(address);
    }
    async getAvatar(nameOrAddress) {
        if (!await this.supportsENS()) return null;
        const provider = await this._getSubprovider(1);
        return provider.getAvatar(nameOrAddress);
    }
}
SequenceProvider.is = (provider)=>{
    return provider && typeof provider === "object" && provider._isSequenceProvider === true;
};
function normalizeChainId(chainId) {
    if (typeof chainId === "object") return normalizeChainId(chainId.chainId);
    return (0, _ethers.ethers).BigNumber.from(chainId).toNumber();
}
/**
 *  This is the same provider, but it only allows a single network at a time.
 *  the network defined by the constructor is the only one that can be used.
 *
 *  Attempting to call any method with a different network will throw an error.
 *  Attempting to change the network of this provider will throw an error.
 *
 *  NOTICE: These networks won't support ENS unless they are the mainnet.
 */ class SingleNetworkSequenceProvider extends SequenceProvider {
    constructor(client, providerFor, chainId){
        super(client, providerFor);
        this.chainId = chainId;
        this._isSingleNetworkSequenceProvider = true;
    }
    _useChainId(chainId) {
        const provided = this.toChainId(chainId);
        if (provided && provided !== this.chainId) throw new Error(`This provider only supports the network ${this.chainId}, but ${provided} was requested.`);
        return provided || super.toChainId(this.chainId);
    }
    useChainId(chainId) {
        return Promise.resolve(this._useChainId(chainId));
    }
    getChainId() {
        return super.toChainId(this.chainId);
    }
    async getNetwork() {
        const networks = await this.client.getNetworks();
        const res = (0, _network.findNetworkConfig)(networks, this.chainId);
        if (!res) throw new Error(`Unsupported network ${this.chainId}`);
        return res;
    }
    /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */ getProvider(chainId) {
        if (this._useChainId(chainId) !== this.chainId) throw new Error(`Unreachable code`);
        return this;
    }
    getSigner(chainId) {
        return super.getSigner(this._useChainId(chainId));
    }
    setDefaultChainId(_chainId) {
        throw new Error(`This provider only supports the network ${this.chainId}; use the parent provider to switch networks.`);
    }
    static is(cand) {
        return cand && typeof cand === "object" && cand._isSingleNetworkSequenceProvider === true;
    }
}
var packageJson = {
    name: "@0xsequence/provider",
    version: "1.6.2",
    description: "provider sub-package for Sequence",
    repository: "https://github.com/0xsequence/sequence.js/tree/master/packages/provider",
    source: "src/index.ts",
    main: "dist/0xsequence-provider.cjs.js",
    module: "dist/0xsequence-provider.esm.js",
    author: "Horizon Blockchain Games",
    license: "Apache-2.0",
    scripts: {
        test: "pnpm test:concurrently 'pnpm test:run'",
        "test:run": "pnpm test:file tests/**/*.spec.ts",
        "test:file": "NODE_OPTIONS='--import tsx' mocha --timeout 30000",
        typecheck: "tsc --noEmit",
        "test:concurrently": "concurrently -k --success first 'pnpm start:hardhat1' 'pnpm start:hardhat2'",
        "start:hardhat1": "pnpm start:hardhat1:verbose > /dev/null 2>&1",
        "start:hardhat2": "pnpm start:hardhat2:verbose > /dev/null 2>&1",
        "start:hardhat1:verbose": "hardhat node --config hardhat1.config.js --hostname 0.0.0.0 --port 9595",
        "start:hardhat2:verbose": "hardhat node --config hardhat2.config.js --hostname 0.0.0.0 --port 8595"
    },
    dependencies: {
        "@0xsequence/abi": "workspace:*",
        "@0xsequence/account": "workspace:*",
        "@0xsequence/auth": "workspace:*",
        "@0xsequence/core": "workspace:*",
        "@0xsequence/migration": "workspace:*",
        "@0xsequence/network": "workspace:*",
        "@0xsequence/relayer": "workspace:*",
        "@0xsequence/utils": "workspace:*",
        "@0xsequence/wallet": "workspace:*",
        eventemitter2: "^6.4.5",
        "webextension-polyfill": "^0.10.0"
    },
    peerDependencies: {
        ethers: ">=5.5 < 6"
    },
    devDependencies: {
        "@types/webextension-polyfill": "^0.10.0",
        hardhat: "^2.12.2",
        ethers: "^5.7.2"
    },
    files: [
        "src",
        "dist"
    ]
};
/**
 *  This session class is meant to persist the state of the wallet connection
 *  whitin the dapp. This enables the client to retain the wallet address (and some more)
 *  even if the user refreshes the page. Otherwise we would have to open the popup again.
 */ class SequenceClientSession {
    constructor(store){
        this.store = store;
    }
    connectedSession() {
        const session = this.getSession();
        if (session && session.accountAddress && session.walletContext && session.networks) return {
            accountAddress: session.accountAddress,
            walletContext: session.walletContext,
            networks: session.networks
        };
        throw new Error("Sequence session not connected");
    }
    hasSession() {
        var _this$getSession;
        return ((_this$getSession = this.getSession()) == null ? void 0 : _this$getSession.accountAddress) !== undefined;
    }
    setSession(session) {
        return this.store.setItem(SequenceClientSession.SESSION_LOCALSTORE_KEY, JSON.stringify(session));
    }
    getSession() {
        const session = this.store.getItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
        if (session) return JSON.parse(session);
        return undefined;
    }
    async clearSession() {
        return this.store.removeItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
    }
}
/**
 *  The wallet webapp doesn't really care what's the "default chain" for the user.
 *  so we don't even bother to send this information to the wallet. Instead, we
 *  track it locally using storage, that way the data stays always in sync.
 */ SequenceClientSession.SESSION_LOCALSTORE_KEY = "@sequence.session";
class DefaultChainIdTracker {
    constructor(store, startingChainId = 1){
        this.store = store;
        this.startingChainId = startingChainId;
        this.callbacks = [];
        store.onItemChange(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, (value)=>{
            if (value) {
                const chainId = parseInt(value);
                this.callbacks.forEach((cb)=>cb(chainId));
            }
        });
    }
    onDefaultChainIdChanged(callback) {
        this.callbacks.push(callback);
        return ()=>{
            this.callbacks = this.callbacks.filter((cb)=>cb !== callback);
        };
    }
    setDefaultChainId(chainId) {
        if (chainId !== this.getDefaultChainId()) this.store.setItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, chainId.toString());
    }
    getDefaultChainId() {
        const read = this.store.getItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY);
        if (!read || read.length === 0) return this.startingChainId;
        return parseInt(read);
    }
}
DefaultChainIdTracker.SESSION_CHAIN_ID_KEY = "@sequence.session.defaultChainId";
/**
 *  This is a wallet client for sequence wallet-webapp. It connects using *some* transport
 *  and it allows to perform all sequence specific (or write) operations related to the wallet.
 *s
 *  It doesn't implement a full ethereum Provider, it doesn't include read-only methods.
 */ // TODO: rename Client to transport.. or something.. like SequenceTransport ..
class SequenceClient {
    constructor(transport, store, options, projectAccessKey){
        var _options$defaultEIP;
        this.projectAccessKey = projectAccessKey;
        this.session = void 0;
        this.defaultChainId = void 0;
        this.callbacks = {};
        this.transport = void 0;
        this.defaultEIP6492 = void 0;
        if (isMuxTransportTemplate(transport)) this.transport = MuxMessageProvider.new(transport);
        else if (isProviderTransport(transport)) this.transport = transport;
        else throw new Error("Invalid transport");
        const defaultChainId = typeof options === "number" ? options : options == null ? void 0 : options.defaultChainId;
        this.defaultEIP6492 = typeof options === "number" ? false : (_options$defaultEIP = options == null ? void 0 : options.defaultEIP6492) != null ? _options$defaultEIP : false;
        this.session = new SequenceClientSession(store);
        this.defaultChainId = new DefaultChainIdTracker(store, defaultChainId);
        this.transport.on("accountsChanged", (accounts)=>{
            var _this$callbacks$accou;
            if (accounts.length > 1) console.warn("SequenceClient: wallet-webapp returned more than one account");
            (_this$callbacks$accou = this.callbacks.accountsChanged) == null || _this$callbacks$accou.forEach((cb)=>cb(accounts));
        });
        this.transport.on("connect", (response)=>{
            var _this$callbacks$conne;
            const chainIdHex = (0, _ethers.ethers).utils.hexValue(this.getChainId());
            (_this$callbacks$conne = this.callbacks.connect) == null || _this$callbacks$conne.forEach((cb)=>cb(_extends({}, response, {
                    // Ignore the full connect response
                    // use the chainId defined locally
                    chainId: chainIdHex
                })));
        });
        this.transport.on("disconnect", (error, origin)=>{
            var _this$callbacks$disco;
            (_this$callbacks$disco = this.callbacks.disconnect) == null || _this$callbacks$disco.forEach((cb)=>cb(error, origin));
        });
        this.transport.on("networks", (networks)=>{
            var _this$callbacks$netwo;
            (_this$callbacks$netwo = this.callbacks.networks) == null || _this$callbacks$netwo.forEach((cb)=>cb(networks));
        });
        this.transport.on("walletContext", (context)=>{
            var _this$callbacks$walle;
            (_this$callbacks$walle = this.callbacks.walletContext) == null || _this$callbacks$walle.forEach((cb)=>cb(context));
        });
        this.transport.on("open", (info)=>{
            var _this$callbacks$open;
            (_this$callbacks$open = this.callbacks.open) == null || _this$callbacks$open.forEach((cb)=>cb(info));
        });
        this.transport.on("close", ()=>{
            var _this$callbacks$close;
            (_this$callbacks$close = this.callbacks.close) == null || _this$callbacks$close.forEach((cb)=>cb());
        });
        this.transport.on("chainChanged", (chainIdHex, origin)=>{
            var _this$callbacks$chain;
            (_this$callbacks$chain = this.callbacks.chainChanged) == null || _this$callbacks$chain.forEach((cb)=>cb(chainIdHex, origin));
        });
        // We don't listen for the transport chainChanged event
        // instead we handle it locally, so we listen for changes in the store
        this.defaultChainId.onDefaultChainIdChanged((chainId)=>{
            var _this$callbacks$chain2;
            const chainIdHex = (0, _ethers.ethers).utils.hexValue(chainId);
            (_this$callbacks$chain2 = this.callbacks.chainChanged) == null || _this$callbacks$chain2.forEach((cb)=>cb(chainIdHex));
        });
    }
    // Callbacks
    registerCallback(eventName, callback) {
        if (!this.callbacks[eventName]) this.callbacks[eventName] = [];
        this.callbacks[eventName].push(callback);
        return ()=>{
            this.callbacks[eventName] = this.callbacks[eventName].filter((c)=>c !== callback);
        };
    }
    // Individual callbacks lead to more idiomatic code
    onOpen(callback) {
        return this.registerCallback("open", callback);
    }
    onClose(callback) {
        return this.registerCallback("close", callback);
    }
    onConnect(callback) {
        return this.registerCallback("connect", callback);
    }
    onDisconnect(callback) {
        return this.registerCallback("disconnect", callback);
    }
    onNetworks(callback) {
        return this.registerCallback("networks", callback);
    }
    onAccountsChanged(callback) {
        return this.registerCallback("accountsChanged", callback);
    }
    // @deprecated
    onWalletContext(callback) {
        return this.registerCallback("walletContext", callback);
    }
    onChainChanged(callback) {
        return this.registerCallback("chainChanged", callback);
    }
    onDefaultChainIdChanged(callback) {
        return this.registerCallback("chainChanged", callback);
    }
    getChainId() {
        return this.defaultChainId.getDefaultChainId();
    }
    setDefaultChainId(chainId) {
        return this.defaultChainId.setDefaultChainId(chainId);
    }
    // Proxy transport methods
    async openWallet(path, intent) {
        this.transport.openWallet(path, intent, this.getChainId());
        await this.transport.waitUntilOpened();
        return this.isOpened();
    }
    closeWallet() {
        return this.transport.closeWallet();
    }
    isOpened() {
        return this.transport.isOpened();
    }
    isConnected() {
        return this.session.hasSession();
    }
    getSession() {
        return this.session.getSession();
    }
    // Basic API
    getAddress() {
        const session = this.session.connectedSession();
        return session.accountAddress;
    }
    async connect(options) {
        if ((options == null ? void 0 : options.authorizeVersion) === undefined) // Populate default authorize version if not provided
        options.authorizeVersion = 2;
        if ((options == null ? void 0 : options.refresh) === true) this.disconnect();
        options.projectAccessKey = this.projectAccessKey;
        if (options) {
            if (options.authorize) {
                if (!options.app) throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);
                if (options.authorizeVersion === undefined) options.authorizeVersion = 2;
            }
        }
        await this.openWallet(undefined, {
            type: "connect",
            options: _extends({}, options, {
                networkId: this.getChainId(),
                clientVersion: packageJson.version
            })
        });
        const connectDetails = await this.transport.waitUntilConnected().catch((error)=>{
            if (error instanceof Error) return {
                connected: false,
                error: error.message
            };
            else return {
                connected: false,
                error: JSON.stringify(error)
            };
        });
        // Normalize chainId into a decimal string
        // TODO: Remove this once wallet-webapp returns chainId as a string
        if (connectDetails.chainId) connectDetails.chainId = (0, _ethers.ethers).BigNumber.from(connectDetails.chainId).toString();
        if (connectDetails.connected) {
            if (!connectDetails.session) throw new Error("impossible state, connect response is missing session");
            this.session.setSession(connectDetails.session);
        }
        return connectDetails;
    }
    disconnect() {
        if (this.isOpened()) this.closeWallet();
        return this.session.clearSession();
    }
    // Higher level API
    // Working with sendAsync is less idiomatic
    // but transport uses it instead of send, so we wrap it
    send(request, chainId) {
        // Internally when sending requests we use `legacy_sign`
        // to avoid the default EIP6492 behavior overriding an explicit
        // "legacy sign" request, so we map the method here.
        request.method = this.mapSignMethod(request.method);
        return new Promise((resolve, reject)=>{
            this.transport.sendAsync(request, (error, response)=>{
                if (error) reject(error);
                else if (response === undefined) reject(new Error(`Got undefined response for request: ${request}`));
                else if (typeof response === "object" && response.error) reject(response.error);
                else if (typeof response === "object" && response.result) resolve(response.result);
                else reject(new Error(`Got invalid response for request: ${request}`));
            }, chainId || this.getChainId());
        });
    }
    async getNetworks(pull) {
        const connectedSession = this.session.connectedSession();
        if (pull) {
            connectedSession.networks = await this.send({
                method: "sequence_getNetworks"
            });
            this.session.setSession(connectedSession);
        }
        return connectedSession.networks;
    }
    // NOTICE: `legacy_sign` will get overriden by `send`
    // it is done this way to ensure that:
    //  - `send` handles `personal_sign` as a request for the default sign method
    //  - explicit `personal_sign` is not replaced by `sequence_sign` (if default is EI6492)
    signMethod(options) {
        if ((options == null ? void 0 : options.eip6492) === undefined) return "personal_sign";
        return options.eip6492 ? "sequence_sign" : "legacy_sign";
    }
    signTypedDataMethod(options) {
        if ((options == null ? void 0 : options.eip6492) === undefined) return "eth_signTypedData_v4";
        return options.eip6492 ? "sequence_signTypedData_v4" : "legacy_signTypedData_v4";
    }
    mapSignMethod(method) {
        if (method === "personal_sign") {
            if (this.defaultEIP6492) return "sequence_sign";
            else return "personal_sign";
        }
        if (method === "eth_signTypedData_v4") {
            if (this.defaultEIP6492) return "sequence_signTypedData_v4";
            else return "eth_signTypedData_v4";
        }
        if (method === "legacy_sign") return "personal_sign";
        if (method === "legacy_signTypedData_v4") return "eth_signTypedData_v4";
        return method;
    }
    async signMessage(message, options) {
        const method = this.signMethod(options);
        // Address is ignored by the wallet webapp
        return this.send({
            method,
            params: [
                message,
                this.getAddress()
            ]
        }, options == null ? void 0 : options.chainId);
    }
    async signTypedData(typedData, options) {
        const method = this.signTypedDataMethod(options);
        // TODO: Stop using ethers for this, this is the only place where we use it
        // and it makes the client depend on ethers.
        const encoded = (0, _ethers.ethers).utils._TypedDataEncoder.getPayload(typedData.domain, typedData.types, typedData.message);
        // The sign typed data will use one of the following chainIds, in order:
        // - The one provided in the options
        // - The one provided in the typedData.domain.chainId
        // - The default chainId
        return this.send({
            method,
            params: [
                this.getAddress(),
                encoded
            ]
        }, (options == null ? void 0 : options.chainId) || typedData.domain.chainId && (0, _ethers.ethers).BigNumber.from(typedData.domain.chainId).toNumber() || this.getChainId());
    }
    async sendTransaction(tx, options) {
        const sequenceTxs = Array.isArray(tx) ? tx : [
            tx
        ];
        const extendedTxs = toExtended(sequenceTxs);
        return this.send({
            method: "eth_sendTransaction",
            params: [
                extendedTxs
            ]
        }, options == null ? void 0 : options.chainId);
    }
    async getWalletContext() {
        return this.send({
            method: "sequence_getWalletContext"
        });
    }
    async getOnchainWalletConfig(options) {
        // NOTICE: sequence_getWalletConfig sends the chainId as a param
        const res = await this.send({
            method: "sequence_getWalletConfig",
            params: [
                (options == null ? void 0 : options.chainId) || this.getChainId()
            ]
        }, options == null ? void 0 : options.chainId);
        return Array.isArray(res) ? res[0] : res;
    }
}
const DefaultProviderConfig = {
    transports: {
        walletAppURL: "https://sequence.app",
        windowTransport: {
            enabled: true
        },
        proxyTransport: {
            enabled: false
        }
    },
    defaultNetwork: 1
};
let sequenceWalletProvider;
const initWallet = (partialConfig)=>{
    var _config$networks$filt, _config$networks, _findNetworkConfig;
    const projectAccessKey = partialConfig == null ? void 0 : partialConfig.projectAccessKey;
    if (!projectAccessKey) console.warn("Please pass a projectAccessKey in initWallet config as it will be required in near future.");
    if (sequenceWalletProvider) return sequenceWalletProvider;
    // Combine both the provided config and the default config
    const config = _extends({}, DefaultProviderConfig, partialConfig, {
        transports: _extends({}, DefaultProviderConfig.transports, partialConfig == null ? void 0 : partialConfig.transports)
    });
    const rpcProviders = {};
    // Find any new networks that aren't already defined in sequence.js
    // and add them to the list of networks, (they must have a rpcUrl and chainId)
    const newNetworks = (_config$networks$filt = (_config$networks = config.networks) == null ? void 0 : _config$networks.filter((n)=>{
        n.rpcUrl !== undefined && n.chainId !== undefined && (0, _network.allNetworks).find((an)=>an.chainId === n.chainId);
    })) != null ? _config$networks$filt : [];
    // Override any information about the networks using the config
    const combinedNetworks = (0, _network.allNetworks).map((n)=>{
        var _config$networks2;
        const network = (_config$networks2 = config.networks) == null ? void 0 : _config$networks2.find((cn)=>cn.chainId === n.chainId);
        return network ? _extends({}, n, network) : n;
    }).concat(newNetworks).map((network)=>{
        const toAppend = projectAccessKey ? `/${projectAccessKey}` : "";
        network.rpcUrl = network.rpcUrl + toAppend;
        return network;
    });
    // This builds a "public rpc" on demand, we build them on demand because we don't want to
    // generate a bunch of providers for networks that aren't used.
    const providerForChainId = (chainId)=>{
        if (!rpcProviders[chainId]) {
            var _combinedNetworks$fin;
            const rpcUrl = (_combinedNetworks$fin = combinedNetworks.find((n)=>n.chainId === chainId)) == null ? void 0 : _combinedNetworks$fin.rpcUrl;
            if (!rpcUrl) throw new Error(`no rpcUrl found for chainId: ${chainId}`);
            const baseProvider = new (0, _ethers.ethers).providers.JsonRpcProvider(rpcUrl);
            const router = new (0, _network.JsonRpcRouter)([
                (0, _network.loggingProviderMiddleware),
                (0, _network.exceptionProviderMiddleware),
                new (0, _network.CachedProvider)()
            ], new (0, _network.JsonRpcSender)(baseProvider));
            rpcProviders[chainId] = new (0, _ethers.ethers).providers.Web3Provider(router, chainId);
        }
        return rpcProviders[chainId];
    };
    // This is the starting default network (as defined by the config)
    // it can be later be changed using `wallet_switchEthereumChain` or some
    // of the other methods on the provider.
    const defaultNetwork = config.defaultNetwork ? (_findNetworkConfig = (0, _network.findNetworkConfig)(combinedNetworks, config.defaultNetwork)) == null ? void 0 : _findNetworkConfig.chainId : undefined;
    if (!defaultNetwork && config.defaultNetwork) throw new Error(`defaultNetwork not found for chainId: ${config.defaultNetwork}`);
    // Generate ItemStore
    const itemStore = config.localStorage || useBestStore();
    // Create client, provider and return signer
    const client = new SequenceClient(config.transports, itemStore, {
        defaultChainId: defaultNetwork,
        defaultEIP6492: config.defaultEIP6492
    }, projectAccessKey);
    sequenceWalletProvider = new SequenceProvider(client, providerForChainId);
    return sequenceWalletProvider;
};
const unregisterWallet = ()=>{
    if (!sequenceWalletProvider) return;
    sequenceWalletProvider.client.closeWallet();
    sequenceWalletProvider.client.transport.unregister();
    sequenceWalletProvider = undefined;
};
const getWallet = ()=>{
    if (!sequenceWalletProvider) throw new Error("Wallet has not been initialized, call sequence.initWallet(config) first.");
    return sequenceWalletProvider;
};

},{"eventemitter2":"j95ue","@0xsequence/utils":"7jY5X","ethers":"hdHML","@0xsequence/network":"01lBM","@0xsequence/core":"cIuGJ","@0xsequence/auth":"9VCSm","@0xsequence/abi":"hbXMf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j95ue":[function(require,module,exports) {
var process = require("f0c43874c9d914b6");
!function(undefined) {
    var hasOwnProperty = Object.hasOwnProperty;
    var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    var defaultMaxListeners = 10;
    var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
    var symbolsSupported = typeof Symbol === "function";
    var reflectSupported = typeof Reflect === "object";
    var setImmediateSupported = typeof setImmediate === "function";
    var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
    var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
    } : Object.keys;
    function init() {
        this._events = {};
        if (this._conf) configure.call(this, this._conf);
    }
    function configure(conf) {
        if (conf) {
            this._conf = conf;
            conf.delimiter && (this.delimiter = conf.delimiter);
            if (conf.maxListeners !== undefined) this._maxListeners = conf.maxListeners;
            conf.wildcard && (this.wildcard = conf.wildcard);
            conf.newListener && (this._newListener = conf.newListener);
            conf.removeListener && (this._removeListener = conf.removeListener);
            conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
            conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
            if (this.wildcard) this.listenerTree = {};
        }
    }
    function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. " + "Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) errorMsg += " Event name: " + eventName + ".";
        if (typeof process !== "undefined" && process.emitWarning) {
            var e = new Error(errorMsg);
            e.name = "MaxListenersExceededWarning";
            e.emitter = this;
            e.count = count;
            process.emitWarning(e);
        } else {
            console.error(errorMsg);
            if (console.trace) console.trace();
        }
    }
    var toArray = function(a, b, c) {
        var n = arguments.length;
        switch(n){
            case 0:
                return [];
            case 1:
                return [
                    a
                ];
            case 2:
                return [
                    a,
                    b
                ];
            case 3:
                return [
                    a,
                    b,
                    c
                ];
            default:
                var arr = new Array(n);
                while(n--)arr[n] = arguments[n];
                return arr;
        }
    };
    function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for(var i = 0; i < len; i++){
            key = keys[i];
            obj[key] = i < valuesCount ? values[i] : undefined;
        }
        return obj;
    }
    function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on, off;
        if (options.on || options.off) {
            on = options.on;
            off = options.off;
        }
        if (target.addEventListener) {
            on = target.addEventListener;
            off = target.removeEventListener;
        } else if (target.addListener) {
            on = target.addListener;
            off = target.removeListener;
        } else if (target.on) {
            on = target.on;
            off = target.off;
        }
        if (!on && !off) throw Error("target does not implement any known event API");
        if (typeof on !== "function") throw TypeError("on method must be a function");
        if (typeof off !== "function") throw TypeError("off method must be a function");
        this._on = on;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) _observers.push(this);
        else emitter._observers = [
            this
        ];
    }
    Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
            var observer = this;
            var target = this._target;
            var emitter = this._emitter;
            var listeners = this._listeners;
            var handler = function() {
                var args = toArray.apply(null, arguments);
                var eventObj = {
                    data: args,
                    name: localEvent,
                    original: event
                };
                if (reducer) {
                    var result = reducer.call(target, eventObj);
                    if (result !== false) emitter.emit.apply(emitter, [
                        eventObj.name
                    ].concat(args));
                    return;
                }
                emitter.emit.apply(emitter, [
                    localEvent
                ].concat(args));
            };
            if (listeners[event]) throw Error("Event '" + event + "' is already listening");
            this._listenersCount++;
            if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
                this._onNewListener = function(_event) {
                    if (_event === localEvent && listeners[event] === null) {
                        listeners[event] = handler;
                        observer._on.call(target, event, handler);
                    }
                };
                emitter.on("newListener", this._onNewListener);
                this._onRemoveListener = function(_event) {
                    if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                        listeners[event] = null;
                        observer._off.call(target, event, handler);
                    }
                };
                listeners[event] = null;
                emitter.on("removeListener", this._onRemoveListener);
            } else {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
            }
        },
        unsubscribe: function(event) {
            var observer = this;
            var listeners = this._listeners;
            var emitter = this._emitter;
            var handler;
            var events;
            var off = this._off;
            var target = this._target;
            var i;
            if (event && typeof event !== "string") throw TypeError("event must be a string");
            function clearRefs() {
                if (observer._onNewListener) {
                    emitter.off("newListener", observer._onNewListener);
                    emitter.off("removeListener", observer._onRemoveListener);
                    observer._onNewListener = null;
                    observer._onRemoveListener = null;
                }
                var index = findTargetIndex.call(emitter, observer);
                emitter._observers.splice(index, 1);
            }
            if (event) {
                handler = listeners[event];
                if (!handler) return;
                off.call(target, event, handler);
                delete listeners[event];
                if (!--this._listenersCount) clearRefs();
            } else {
                events = ownKeys(listeners);
                i = events.length;
                while(i-- > 0){
                    event = events[i];
                    off.call(target, event, listeners[event]);
                }
                this._listeners = {};
                this._listenersCount = 0;
                clearRefs();
            }
        }
    });
    function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options) return computedOptions;
        if (typeof options !== "object") throw TypeError("options must be an object");
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value;
        var reducer;
        function reject(reason) {
            throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for(var i = 0; i < length; i++){
            option = keys[i];
            if (!allowUnknown && !hasOwnProperty.call(schema, option)) throw Error('Unknown "' + option + '" option');
            value = options[option];
            if (value !== undefined) {
                reducer = reducers[option];
                computedOptions[option] = reducer ? reducer(value, reject) : value;
            }
        }
        return computedOptions;
    }
    function constructorReducer(value, reject) {
        if (typeof value !== "function" || !value.hasOwnProperty("prototype")) reject("value must be a constructor");
        return value;
    }
    function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) return function(v, reject) {
            if (typeof v === firstType) return v;
            reject(message);
        };
        if (len === 2) return function(v, reject) {
            var kind = typeof v;
            if (kind === firstType || kind === secondType) return v;
            reject(message);
        };
        return function(v, reject) {
            var kind = typeof v;
            var i = len;
            while(i-- > 0){
                if (kind === types[i]) return v;
            }
            reject(message);
        };
    }
    var functionReducer = makeTypeReducer([
        "function"
    ]);
    var objectFunctionReducer = makeTypeReducer([
        "object",
        "function"
    ]);
    function makeCancelablePromise(Promise1, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise1(function(resolve, reject, onCancel) {
            options = resolveOptions(options, {
                timeout: 0,
                overload: false
            }, {
                timeout: function(value, reject) {
                    value *= 1;
                    if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) reject("timeout must be a positive number");
                    return value;
                }
            });
            isCancelable = !options.overload && typeof Promise1.prototype.cancel === "function" && typeof onCancel === "function";
            function cleanup() {
                if (callbacks) callbacks = null;
                if (timer) {
                    clearTimeout(timer);
                    timer = 0;
                }
            }
            var _resolve = function(value) {
                cleanup();
                resolve(value);
            };
            var _reject = function(err) {
                cleanup();
                reject(err);
            };
            if (isCancelable) executor(_resolve, _reject, onCancel);
            else {
                callbacks = [
                    function(reason) {
                        _reject(reason || Error("canceled"));
                    }
                ];
                executor(_resolve, _reject, function(cb) {
                    if (subscriptionClosed) throw Error("Unable to subscribe on cancel event asynchronously");
                    if (typeof cb !== "function") throw TypeError("onCancel callback must be a function");
                    callbacks.push(cb);
                });
                subscriptionClosed = true;
            }
            if (options.timeout > 0) timer = setTimeout(function() {
                var reason = Error("timeout");
                reason.code = "ETIMEDOUT";
                timer = 0;
                promise.cancel(reason);
                reject(reason);
            }, options.timeout);
        });
        if (!isCancelable) promise.cancel = function(reason) {
            if (!callbacks) return;
            var length = callbacks.length;
            for(var i = 1; i < length; i++)callbacks[i](reason);
            // internal callback to reject the promise
            callbacks[0](reason);
            callbacks = null;
        };
        return promise;
    }
    function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) return -1;
        var len = observers.length;
        for(var i = 0; i < len; i++){
            if (observers[i]._target === observer) return i;
        }
        return -1;
    }
    // Attention, function return type now is array, always !
    // It has zero elements if no any matches found and one or more
    // elements (leafs) if there are matches
    //
    function searchListenerTree(handlers, type, tree, i, typeLength) {
        if (!tree) return null;
        if (i === 0) {
            var kind = typeof type;
            if (kind === "string") {
                var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
                if ((n = type.indexOf(delimiter)) !== -1) {
                    ns = new Array(5);
                    do {
                        ns[l++] = type.slice(j, n);
                        j = n + dl;
                    }while ((n = type.indexOf(delimiter, j)) !== -1);
                    ns[l++] = type.slice(j);
                    type = ns;
                    typeLength = l;
                } else {
                    type = [
                        type
                    ];
                    typeLength = 1;
                }
            } else if (kind === "object") typeLength = type.length;
            else {
                type = [
                    type
                ];
                typeLength = 1;
            }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
        if (i === typeLength) //
        // If at the end of the event(s) list and the tree has listeners
        // invoke those listeners.
        //
        {
            if (tree._listeners) {
                if (typeof tree._listeners === "function") {
                    handlers && handlers.push(tree._listeners);
                    listeners = [
                        tree
                    ];
                } else {
                    handlers && handlers.push.apply(handlers, tree._listeners);
                    listeners = [
                        tree
                    ];
                }
            }
        } else {
            if (currentType === "*") {
                //
                // If the event emitted is '*' at this part
                // or there is a concrete match at this patch
                //
                branches = ownKeys(tree);
                n = branches.length;
                while(n-- > 0){
                    branch = branches[n];
                    if (branch !== "_listeners") {
                        _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
                        if (_listeners) {
                            if (listeners) listeners.push.apply(listeners, _listeners);
                            else listeners = _listeners;
                        }
                    }
                }
                return listeners;
            } else if (currentType === "**") {
                endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
                if (endReached && tree._listeners) // The next element has a _listeners, add it to the handlers.
                listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
                branches = ownKeys(tree);
                n = branches.length;
                while(n-- > 0){
                    branch = branches[n];
                    if (branch !== "_listeners") {
                        if (branch === "*" || branch === "**") {
                            if (tree[branch]._listeners && !endReached) {
                                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                                if (_listeners) {
                                    if (listeners) listeners.push.apply(listeners, _listeners);
                                    else listeners = _listeners;
                                }
                            }
                            _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                        } else if (branch === nextType) _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
                        else // No match on this one, shift into the tree but not in the type array.
                        _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                        if (_listeners) {
                            if (listeners) listeners.push.apply(listeners, _listeners);
                            else listeners = _listeners;
                        }
                    }
                }
                return listeners;
            } else if (tree[currentType]) listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
        }
        xTree = tree["*"];
        if (xTree) //
        // If the listener tree will allow any match for this part,
        // then recursively explore all branches of the tree
        //
        searchListenerTree(handlers, type, xTree, i + 1, typeLength);
        xxTree = tree["**"];
        if (xxTree) {
            if (i < typeLength) {
                if (xxTree._listeners) // If we have a listener on a '**', it will catch all, so add its handler.
                searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
                // Build arrays of matching next branches and others.
                branches = ownKeys(xxTree);
                n = branches.length;
                while(n-- > 0){
                    branch = branches[n];
                    if (branch !== "_listeners") {
                        if (branch === nextType) // We know the next element will match, so jump twice.
                        searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
                        else if (branch === currentType) // Current node matches, move into the tree.
                        searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
                        else {
                            isolatedBranch = {};
                            isolatedBranch[branch] = xxTree[branch];
                            searchListenerTree(handlers, type, {
                                "**": isolatedBranch
                            }, i + 1, typeLength);
                        }
                    }
                }
            } else if (xxTree._listeners) // We have reached the end and still on a '**'
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            else if (xxTree["*"] && xxTree["*"]._listeners) searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
        }
        return listeners;
    }
    function growListenerTree(type, listener, prepend) {
        var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns;
        if (typeof type === "string") {
            if ((i = type.indexOf(delimiter)) !== -1) {
                ns = new Array(5);
                do {
                    ns[len++] = type.slice(j, i);
                    j = i + dl;
                }while ((i = type.indexOf(delimiter, j)) !== -1);
                ns[len++] = type.slice(j);
            } else {
                ns = [
                    type
                ];
                len = 1;
            }
        } else {
            ns = type;
            len = type.length;
        }
        //
        // Looks for two consecutive '**', if so, don't add the event at all.
        //
        if (len > 1) for(i = 0; i + 1 < len; i++){
            if (ns[i] === "**" && ns[i + 1] === "**") return;
        }
        var tree = this.listenerTree, name;
        for(i = 0; i < len; i++){
            name = ns[i];
            tree = tree[name] || (tree[name] = {});
            if (i === len - 1) {
                if (!tree._listeners) tree._listeners = listener;
                else {
                    if (typeof tree._listeners === "function") tree._listeners = [
                        tree._listeners
                    ];
                    if (prepend) tree._listeners.unshift(listener);
                    else tree._listeners.push(listener);
                    if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                        tree._listeners.warned = true;
                        logPossibleMemoryLeak.call(this, tree._listeners.length, name);
                    }
                }
                return true;
            }
        }
        return true;
    }
    function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while(i-- > 0){
            branchName = branches[i];
            branch = tree[branchName];
            if (branchName === "_listeners") path = root;
            else path = root ? root.concat(branchName) : [
                branchName
            ];
            isArrayPath = asArray || typeof branchName === "symbol";
            hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
            if (typeof branch === "object") collectTreeEvents.call(this, branch, events, path, isArrayPath);
        }
        return events;
    }
    function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i = keys.length;
        var obj, key, flag;
        while(i-- > 0){
            key = keys[i];
            obj = root[key];
            if (obj) {
                flag = true;
                if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) delete root[key];
            }
        }
        return flag;
    }
    function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
    }
    Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
    };
    function setupListener(event, listener, options) {
        if (options === true) promisify = true;
        else if (options === false) async = true;
        else {
            if (!options || typeof options !== "object") throw TypeError("options should be an object or true");
            var async = options.async;
            var promisify = options.promisify;
            var nextTick = options.nextTick;
            var objectify = options.objectify;
        }
        if (async || nextTick || promisify) {
            var _listener = listener;
            var _origin = listener._origin || listener;
            if (nextTick && !nextTickSupported) throw Error("process.nextTick is not supported");
            if (promisify === undefined) promisify = listener.constructor.name === "AsyncFunction";
            listener = function() {
                var args = arguments;
                var context = this;
                var event = this.event;
                return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
                    _setImmediate(resolve);
                }).then(function() {
                    context.event = event;
                    return _listener.apply(context, args);
                }) : (nextTick ? process.nextTick : _setImmediate)(function() {
                    context.event = event;
                    _listener.apply(context, args);
                });
            };
            listener._async = true;
            listener._origin = _origin;
        }
        return [
            listener,
            objectify ? new Listener(this, event, listener) : this
        ];
    }
    function EventEmitter(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
    }
    EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property
    EventEmitter.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") throw TypeError("target musts be an object");
        var emitter = this;
        options = resolveOptions(options, {
            on: undefined,
            off: undefined,
            reducers: undefined
        }, {
            on: functionReducer,
            off: functionReducer,
            reducers: objectFunctionReducer
        });
        function listen(events) {
            if (typeof events !== "object") throw TypeError("events must be an object");
            var reducers = options.reducers;
            var index = findTargetIndex.call(emitter, target);
            var observer;
            if (index === -1) observer = new TargetObserver(emitter, target, options);
            else observer = emitter._observers[index];
            var keys = ownKeys(events);
            var len = keys.length;
            var event;
            var isSingleReducer = typeof reducers === "function";
            for(var i = 0; i < len; i++){
                event = keys[i];
                observer.subscribe(event, events[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);
            }
        }
        isArray(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
    };
    EventEmitter.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) return false;
        var i = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") throw TypeError("target should be an object");
        while(i-- > 0){
            observer = observers[i];
            if (!target || observer._target === target) {
                observer.unsubscribe(event);
                matched = true;
            }
        }
        return matched;
    };
    // By default EventEmitters will print a warning if more than
    // 10 listeners are added to it. This is a useful default which
    // helps finding memory leaks.
    //
    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.delimiter = ".";
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined) {
            this._maxListeners = n;
            if (!this._conf) this._conf = {};
            this._conf.maxListeners = n;
        }
    };
    EventEmitter.prototype.getMaxListeners = function() {
        return this._maxListeners;
    };
    EventEmitter.prototype.event = "";
    EventEmitter.prototype.once = function(event, fn, options) {
        return this._once(event, fn, false, options);
    };
    EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
        return this._once(event, fn, true, options);
    };
    EventEmitter.prototype._once = function(event, fn, prepend, options) {
        return this._many(event, 1, fn, prepend, options);
    };
    EventEmitter.prototype.many = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, false, options);
    };
    EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, true, options);
    };
    EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
        var self = this;
        if (typeof fn !== "function") throw new Error("many only accepts instances of Function");
        function listener() {
            if (--ttl === 0) self.off(event, listener);
            return fn.apply(this, arguments);
        }
        listener._origin = fn;
        return this._on(event, listener, prepend, options);
    };
    EventEmitter.prototype.emit = function() {
        if (!this._events && !this._all) return false;
        this._events || init.call(this);
        var type = arguments[0], ns, wildcard = this.wildcard;
        var args, l, i, j, containsSymbol;
        if (type === "newListener" && !this._newListener) {
            if (!this._events.newListener) return false;
        }
        if (wildcard) {
            ns = type;
            if (type !== "newListener" && type !== "removeListener") {
                if (typeof type === "object") {
                    l = type.length;
                    if (symbolsSupported) {
                        for(i = 0; i < l; i++)if (typeof type[i] === "symbol") {
                            containsSymbol = true;
                            break;
                        }
                    }
                    if (!containsSymbol) type = type.join(this.delimiter);
                }
            }
        }
        var al = arguments.length;
        var handler;
        if (this._all && this._all.length) {
            handler = this._all.slice();
            for(i = 0, l = handler.length; i < l; i++){
                this.event = type;
                switch(al){
                    case 1:
                        handler[i].call(this, type);
                        break;
                    case 2:
                        handler[i].call(this, type, arguments[1]);
                        break;
                    case 3:
                        handler[i].call(this, type, arguments[1], arguments[2]);
                        break;
                    default:
                        handler[i].apply(this, arguments);
                }
            }
        }
        if (wildcard) {
            handler = [];
            searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
        } else {
            handler = this._events[type];
            if (typeof handler === "function") {
                this.event = type;
                switch(al){
                    case 1:
                        handler.call(this);
                        break;
                    case 2:
                        handler.call(this, arguments[1]);
                        break;
                    case 3:
                        handler.call(this, arguments[1], arguments[2]);
                        break;
                    default:
                        args = new Array(al - 1);
                        for(j = 1; j < al; j++)args[j - 1] = arguments[j];
                        handler.apply(this, args);
                }
                return true;
            } else if (handler) // need to make copy of handlers because list can change in the middle
            // of emit call
            handler = handler.slice();
        }
        if (handler && handler.length) {
            if (al > 3) {
                args = new Array(al - 1);
                for(j = 1; j < al; j++)args[j - 1] = arguments[j];
            }
            for(i = 0, l = handler.length; i < l; i++){
                this.event = type;
                switch(al){
                    case 1:
                        handler[i].call(this);
                        break;
                    case 2:
                        handler[i].call(this, arguments[1]);
                        break;
                    case 3:
                        handler[i].call(this, arguments[1], arguments[2]);
                        break;
                    default:
                        handler[i].apply(this, args);
                }
            }
            return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
            if (arguments[1] instanceof Error) throw arguments[1]; // Unhandled 'error' event
            else throw new Error("Uncaught, unspecified 'error' event.");
        }
        return !!this._all;
    };
    EventEmitter.prototype.emitAsync = function() {
        if (!this._events && !this._all) return false;
        this._events || init.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
        var args, l, i, j;
        if (type === "newListener" && !this._newListener) {
            if (!this._events.newListener) return Promise.resolve([
                false
            ]);
        }
        if (wildcard) {
            ns = type;
            if (type !== "newListener" && type !== "removeListener") {
                if (typeof type === "object") {
                    l = type.length;
                    if (symbolsSupported) {
                        for(i = 0; i < l; i++)if (typeof type[i] === "symbol") {
                            containsSymbol = true;
                            break;
                        }
                    }
                    if (!containsSymbol) type = type.join(this.delimiter);
                }
            }
        }
        var promises = [];
        var al = arguments.length;
        var handler;
        if (this._all) for(i = 0, l = this._all.length; i < l; i++){
            this.event = type;
            switch(al){
                case 1:
                    promises.push(this._all[i].call(this, type));
                    break;
                case 2:
                    promises.push(this._all[i].call(this, type, arguments[1]));
                    break;
                case 3:
                    promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                    break;
                default:
                    promises.push(this._all[i].apply(this, arguments));
            }
        }
        if (wildcard) {
            handler = [];
            searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else handler = this._events[type];
        if (typeof handler === "function") {
            this.event = type;
            switch(al){
                case 1:
                    promises.push(handler.call(this));
                    break;
                case 2:
                    promises.push(handler.call(this, arguments[1]));
                    break;
                case 3:
                    promises.push(handler.call(this, arguments[1], arguments[2]));
                    break;
                default:
                    args = new Array(al - 1);
                    for(j = 1; j < al; j++)args[j - 1] = arguments[j];
                    promises.push(handler.apply(this, args));
            }
        } else if (handler && handler.length) {
            handler = handler.slice();
            if (al > 3) {
                args = new Array(al - 1);
                for(j = 1; j < al; j++)args[j - 1] = arguments[j];
            }
            for(i = 0, l = handler.length; i < l; i++){
                this.event = type;
                switch(al){
                    case 1:
                        promises.push(handler[i].call(this));
                        break;
                    case 2:
                        promises.push(handler[i].call(this, arguments[1]));
                        break;
                    case 3:
                        promises.push(handler[i].call(this, arguments[1], arguments[2]));
                        break;
                    default:
                        promises.push(handler[i].apply(this, args));
                }
            }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
            if (arguments[1] instanceof Error) return Promise.reject(arguments[1]); // Unhandled 'error' event
            else return Promise.reject("Uncaught, unspecified 'error' event.");
        }
        return Promise.all(promises);
    };
    EventEmitter.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
    };
    EventEmitter.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
    };
    EventEmitter.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
    };
    EventEmitter.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
    };
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prototype._onAny = function(fn, prepend) {
        if (typeof fn !== "function") throw new Error("onAny only accepts instances of Function");
        if (!this._all) this._all = [];
        // Add the function to the event listener collection.
        if (prepend) this._all.unshift(fn);
        else this._all.push(fn);
        return this;
    };
    EventEmitter.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
            this._onAny(type, listener);
            return this;
        }
        if (typeof listener !== "function") throw new Error("on only accepts instances of Function");
        this._events || init.call(this);
        var returnValue = this, temp;
        if (options !== undefined) {
            temp = setupListener.call(this, type, listener, options);
            listener = temp[0];
            returnValue = temp[1];
        }
        // To avoid recursion in the case that type == "newListeners"! Before
        // adding it to the listeners, first emit "newListeners".
        if (this._newListener) this.emit("newListener", type, listener);
        if (this.wildcard) {
            growListenerTree.call(this, type, listener, prepend);
            return returnValue;
        }
        if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;
        else {
            if (typeof this._events[type] === "function") // Change to array.
            this._events[type] = [
                this._events[type]
            ];
            // If we've already got an array, just add
            if (prepend) this._events[type].unshift(listener);
            else this._events[type].push(listener);
            // Check for listener leak
            if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
                this._events[type].warned = true;
                logPossibleMemoryLeak.call(this, this._events[type].length, type);
            }
        }
        return returnValue;
    };
    EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") throw new Error("removeListener only takes instances of Function");
        var handlers, leafs = [];
        if (this.wildcard) {
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
            if (!leafs) return this;
        } else {
            // does not use listeners(), so no side effect of creating _events[type]
            if (!this._events[type]) return this;
            handlers = this._events[type];
            leafs.push({
                _listeners: handlers
            });
        }
        for(var iLeaf = 0; iLeaf < leafs.length; iLeaf++){
            var leaf = leafs[iLeaf];
            handlers = leaf._listeners;
            if (isArray(handlers)) {
                var position = -1;
                for(var i = 0, length = handlers.length; i < length; i++)if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                    position = i;
                    break;
                }
                if (position < 0) continue;
                if (this.wildcard) leaf._listeners.splice(position, 1);
                else this._events[type].splice(position, 1);
                if (handlers.length === 0) {
                    if (this.wildcard) delete leaf._listeners;
                    else delete this._events[type];
                }
                if (this._removeListener) this.emit("removeListener", type, listener);
                return this;
            } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
                if (this.wildcard) delete leaf._listeners;
                else delete this._events[type];
                if (this._removeListener) this.emit("removeListener", type, listener);
            }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
    };
    EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
            fns = this._all;
            for(i = 0, l = fns.length; i < l; i++)if (fn === fns[i]) {
                fns.splice(i, 1);
                if (this._removeListener) this.emit("removeListenerAny", fn);
                return this;
            }
        } else {
            fns = this._all;
            if (this._removeListener) for(i = 0, l = fns.length; i < l; i++)this.emit("removeListenerAny", fns[i]);
            this._all = [];
        }
        return this;
    };
    EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
    EventEmitter.prototype.removeAllListeners = function(type) {
        if (type === undefined) {
            !this._events || init.call(this);
            return this;
        }
        if (this.wildcard) {
            var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
            if (!leafs) return this;
            for(i = 0; i < leafs.length; i++){
                leaf = leafs[i];
                leaf._listeners = null;
            }
            this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) this._events[type] = null;
        return this;
    };
    EventEmitter.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i;
        var listenerTree;
        if (type === undefined) {
            if (this.wildcard) throw Error("event name required for wildcard emitter");
            if (!_events) return [];
            keys = ownKeys(_events);
            i = keys.length;
            allListeners = [];
            while(i-- > 0){
                listeners = _events[keys[i]];
                if (typeof listeners === "function") allListeners.push(listeners);
                else allListeners.push.apply(allListeners, listeners);
            }
            return allListeners;
        } else {
            if (this.wildcard) {
                listenerTree = this.listenerTree;
                if (!listenerTree) return [];
                var handlers = [];
                var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
                searchListenerTree.call(this, handlers, ns, listenerTree, 0);
                return handlers;
            }
            if (!_events) return [];
            listeners = _events[type];
            if (!listeners) return [];
            return typeof listeners === "function" ? [
                listeners
            ] : listeners;
        }
    };
    EventEmitter.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
    };
    EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
    };
    EventEmitter.prototype.hasListeners = function(type) {
        if (this.wildcard) {
            var handlers = [];
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
            return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));
    };
    EventEmitter.prototype.listenersAny = function() {
        if (this._all) return this._all;
        else return [];
    };
    EventEmitter.prototype.waitFor = function(event, options) {
        var self = this;
        var type = typeof options;
        if (type === "number") options = {
            timeout: options
        };
        else if (type === "function") options = {
            filter: options
        };
        options = resolveOptions(options, {
            timeout: 0,
            filter: undefined,
            handleError: false,
            Promise: Promise,
            overload: false
        }, {
            filter: functionReducer,
            Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
            function listener() {
                var filter = options.filter;
                if (filter && !filter.apply(self, arguments)) return;
                self.off(event, listener);
                if (options.handleError) {
                    var err = arguments[0];
                    err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
                } else resolve(toArray.apply(null, arguments));
            }
            onCancel(function() {
                self.off(event, listener);
            });
            self._on(event, listener, false);
        }, {
            timeout: options.timeout,
            overload: options.overload
        });
    };
    function once(emitter, name, options) {
        options = resolveOptions(options, {
            Promise: Promise,
            timeout: 0,
            overload: false
        }, {
            Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
            var handler;
            if (typeof emitter.addEventListener === "function") {
                handler = function() {
                    resolve(toArray.apply(null, arguments));
                };
                onCancel(function() {
                    emitter.removeEventListener(name, handler);
                });
                emitter.addEventListener(name, handler, {
                    once: true
                });
                return;
            }
            var eventListener = function() {
                errorListener && emitter.removeListener("error", errorListener);
                resolve(toArray.apply(null, arguments));
            };
            var errorListener;
            if (name !== "error") {
                errorListener = function(err) {
                    emitter.removeListener(name, eventListener);
                    reject(err);
                };
                emitter.once("error", errorListener);
            }
            onCancel(function() {
                errorListener && emitter.removeListener("error", errorListener);
                emitter.removeListener(name, eventListener);
            });
            emitter.once(name, eventListener);
        }, {
            timeout: options.timeout,
            overload: options.overload
        });
    }
    var prototype = EventEmitter.prototype;
    Object.defineProperties(EventEmitter, {
        defaultMaxListeners: {
            get: function() {
                return prototype._maxListeners;
            },
            set: function(n) {
                if (typeof n !== "number" || n < 0 || Number.isNaN(n)) throw TypeError("n must be a non-negative number");
                prototype._maxListeners = n;
            },
            enumerable: true
        },
        once: {
            value: once,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperties(prototype, {
        _maxListeners: {
            value: defaultMaxListeners,
            writable: true,
            configurable: true
        },
        _observers: {
            value: null,
            writable: true,
            configurable: true
        }
    });
    if (typeof define === "function" && define.amd) // AMD. Register as an anonymous module.
    define(function() {
        return EventEmitter;
    });
    else {
        var _global;
        // CommonJS
        module.exports = EventEmitter;
    }
}();

},{"f0c43874c9d914b6":"d5jf4"}],"8HBJR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Protocol version.
 *
 * @public
 */ parcelHelpers.export(exports, "protocol", ()=>(0, _socketIoParser.protocol));
/**
 * Expose constructors for standalone build.
 *
 * @public
 */ parcelHelpers.export(exports, "Manager", ()=>(0, _managerJs.Manager));
parcelHelpers.export(exports, "Socket", ()=>(0, _socketJs.Socket));
parcelHelpers.export(exports, "io", ()=>lookup);
parcelHelpers.export(exports, "connect", ()=>lookup);
parcelHelpers.export(exports, "default", ()=>lookup);
var _urlJs = require("./url.js");
var _managerJs = require("./manager.js");
var _socketJs = require("./socket.js");
var _socketIoParser = require("socket.io-parser");
/**
 * Managers cache.
 */ const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, _urlJs.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    let io;
    if (newConnection) io = new (0, _managerJs.Manager)(source, opts);
    else {
        if (!cache[id]) cache[id] = new (0, _managerJs.Manager)(source, opts);
        io = cache[id];
    }
    if (parsed.query && !opts.query) opts.query = parsed.queryKey;
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: (0, _managerJs.Manager),
    Socket: (0, _socketJs.Socket),
    io: lookup,
    connect: lookup
});

},{"./url.js":"9Ze3o","./manager.js":"94vh9","./socket.js":"kbWgu","socket.io-parser":"2lQL3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Ze3o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */ parcelHelpers.export(exports, "url", ()=>url);
var _engineIoClient = require("engine.io-client");
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || typeof location !== "undefined" && location;
    if (null == uri) uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) uri = loc.protocol + uri;
            else uri = loc.host + uri;
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            if ("undefined" !== typeof loc) uri = loc.protocol + "//" + uri;
            else uri = "https://" + uri;
        }
        // parse
        obj = (0, _engineIoClient.parse)(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) obj.port = "80";
        else if (/^(http|ws)s$/.test(obj.protocol)) obj.port = "443";
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}

},{"engine.io-client":"jBHFs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jBHFs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transport", ()=>(0, _transportJs.Transport));
parcelHelpers.export(exports, "TransportError", ()=>(0, _transportJs.TransportError));
parcelHelpers.export(exports, "transports", ()=>(0, _indexJs.transports));
parcelHelpers.export(exports, "installTimerFunctions", ()=>(0, _utilJs.installTimerFunctions));
parcelHelpers.export(exports, "parse", ()=>(0, _parseuriJs.parse));
parcelHelpers.export(exports, "nextTick", ()=>(0, _websocketConstructorJs.nextTick));
parcelHelpers.export(exports, "Socket", ()=>(0, _socketJs.Socket));
parcelHelpers.export(exports, "protocol", ()=>protocol);
var _socketJs = require("./socket.js");
var _transportJs = require("./transport.js");
var _indexJs = require("./transports/index.js");
var _utilJs = require("./util.js");
var _parseuriJs = require("./contrib/parseuri.js");
var _websocketConstructorJs = require("./transports/websocket-constructor.js");
const protocol = (0, _socketJs.Socket).protocol;

},{"./socket.js":"kpkbh","./transport.js":"kwKKC","./transports/index.js":"2neV7","./util.js":"d7eyH","./contrib/parseuri.js":"5RFyz","./transports/websocket-constructor.js":"dDJnh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpkbh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Socket", ()=>Socket);
var _indexJs = require("./transports/index.js");
var _utilJs = require("./util.js");
var _parseqsJs = require("./contrib/parseqs.js");
var _parseuriJs = require("./contrib/parseuri.js");
var _componentEmitter = require("@socket.io/component-emitter");
var _engineIoParser = require("engine.io-parser");
var _websocketConstructorJs = require("./transports/websocket-constructor.js");
class Socket extends (0, _componentEmitter.Emitter) {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */ constructor(uri, opts = {}){
        super();
        this.binaryType = (0, _websocketConstructorJs.defaultBinaryType);
        this.writeBuffer = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            uri = (0, _parseuriJs.parse)(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol === "https" || uri.protocol === "wss";
            opts.port = uri.port;
            if (uri.query) opts.query = uri.query;
        } else if (opts.host) opts.hostname = (0, _parseuriJs.parse)(opts.host).host;
        (0, _utilJs.installTimerFunctions)(this, opts);
        this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) // if no port is specified manually, use the protocol default
        opts.port = this.secure ? "443" : "80";
        this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
        this.transports = opts.transports || [
            "polling",
            "websocket",
            "webtransport"
        ];
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: false
        }, opts);
        this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") this.opts.query = (0, _parseqsJs.decode)(this.opts.query);
        // set on handshake
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        // set on heartbeat
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this.beforeunloadEventListener = ()=>{
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener("beforeunload", this.beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
                this.offlineEventListener = ()=>{
                    this.onClose("transport close", {
                        description: "network connection lost"
                    });
                };
                addEventListener("offline", this.offlineEventListener, false);
            }
        }
        this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */ createTransport(name) {
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = (0, _engineIoParser.protocol);
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id) query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        }, this.opts.transportOptions[name]);
        return new (0, _indexJs.transports)[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */ open() {
        let transport;
        if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) transport = "websocket";
        else if (0 === this.transports.length) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(()=>{
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        } else transport = this.transports[0];
        this.readyState = "opening";
        // Retry with the next transport if the transport is disabled (jsonp: false)
        try {
            transport = this.createTransport(transport);
        } catch (e) {
            this.transports.shift();
            this.open();
            return;
        }
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */ setTransport(transport) {
        if (this.transport) this.transport.removeAllListeners();
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason)=>this.onClose("transport close", reason));
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */ probe(name) {
        let transport = this.createTransport(name);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = ()=>{
            if (failed) return;
            transport.send([
                {
                    type: "ping",
                    data: "probe"
                }
            ]);
            transport.once("packet", (msg)=>{
                if (failed) return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport) return;
                    Socket.priorWebsocketSuccess = "websocket" === transport.name;
                    this.transport.pause(()=>{
                        if (failed) return;
                        if ("closed" === this.readyState) return;
                        cleanup();
                        this.setTransport(transport);
                        transport.send([
                            {
                                type: "upgrade"
                            }
                        ]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                } else {
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed) return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err)=>{
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) freezeTransport();
        }
        // Remove all listeners on the transport and on self
        const cleanup = ()=>{
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") // favor WebTransport
        this.setTimeoutFn(()=>{
            if (!failed) transport.open();
        }, 200);
        else transport.open();
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */ onOpen() {
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
        // we check for `readyState` in case an `open`
        // listener already closed the socket
        if ("open" === this.readyState && this.opts.upgrade) {
            let i = 0;
            const l = this.upgrades.length;
            for(; i < l; i++)this.probe(this.upgrades[i]);
        }
    }
    /**
     * Handles a packet.
     *
     * @private
     */ onPacket(packet) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            this.resetPingTimeout();
            switch(packet.type){
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this.sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this.onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */ onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState) return;
        this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */ resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(()=>{
            this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) this.pingTimeoutTimer.unref();
    }
    /**
     * Called on `drain` event
     *
     * @private
     */ onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) this.emitReserved("drain");
        else this.flush();
    }
    /**
     * Flush write buffers.
     *
     * @private
     */ flush() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            const packets = this.getWritablePackets();
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this.prevBufferLen = packets.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */ getWritablePackets() {
        const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) return this.writeBuffer;
        let payloadSize = 1; // first packet type
        for(let i = 0; i < this.writeBuffer.length; i++){
            const data = this.writeBuffer[i].data;
            if (data) payloadSize += (0, _utilJs.byteLength)(data);
            if (i > 0 && payloadSize > this.maxPayload) return this.writeBuffer.slice(0, i);
            payloadSize += 2; // separator + packet type
        }
        return this.writeBuffer;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */ write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */ sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) return;
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn) this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */ close() {
        const close = ()=>{
            this.onClose("forced close");
            this.transport.close();
        };
        const cleanupAndClose = ()=>{
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = ()=>{
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) this.once("drain", ()=>{
                if (this.upgrading) waitForUpgrade();
                else close();
            });
            else if (this.upgrading) waitForUpgrade();
            else close();
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */ onError(err) {
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */ onClose(reason, description) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
            // clear timers
            this.clearTimeoutFn(this.pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (typeof removeEventListener === "function") {
                removeEventListener("beforeunload", this.beforeunloadEventListener, false);
                removeEventListener("offline", this.offlineEventListener, false);
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this.prevBufferLen = 0;
        }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */ filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for(; i < j; i++)if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
        return filteredUpgrades;
    }
}
Socket.protocol = (0, _engineIoParser.protocol);

},{"./transports/index.js":"2neV7","./util.js":"d7eyH","./contrib/parseqs.js":"aFNEN","./contrib/parseuri.js":"5RFyz","@socket.io/component-emitter":"dzQbR","engine.io-parser":"2SHiP","./transports/websocket-constructor.js":"dDJnh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2neV7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transports", ()=>transports);
var _pollingJs = require("./polling.js");
var _websocketJs = require("./websocket.js");
var _webtransportJs = require("./webtransport.js");
const transports = {
    websocket: (0, _websocketJs.WS),
    webtransport: (0, _webtransportJs.WT),
    polling: (0, _pollingJs.Polling)
};

},{"./polling.js":"HgHsi","./websocket.js":"8y2e2","./webtransport.js":"k7fng","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"HgHsi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Polling", ()=>Polling);
parcelHelpers.export(exports, "Request", ()=>Request);
var _transportJs = require("../transport.js");
var _yeastJs = require("../contrib/yeast.js");
var _engineIoParser = require("engine.io-parser");
var _xmlhttprequestJs = require("./xmlhttprequest.js");
var _componentEmitter = require("@socket.io/component-emitter");
var _utilJs = require("../util.js");
var _globalThisJs = require("../globalThis.js");
function empty() {}
const hasXHR2 = function() {
    const xhr = new (0, _xmlhttprequestJs.XHR)({
        xdomain: false
    });
    return null != xhr.responseType;
}();
class Polling extends (0, _transportJs.Transport) {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */ constructor(opts){
        super(opts);
        this.polling = false;
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) port = isSSL ? "443" : "80";
            this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        }
        /**
         * XHR supports binary
         */ const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
        if (this.opts.withCredentials) this.cookieJar = (0, _xmlhttprequestJs.createCookieJar)();
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */ doOpen() {
        this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */ pause(onPause) {
        this.readyState = "pausing";
        const pause = ()=>{
            this.readyState = "paused";
            onPause();
        };
        if (this.polling || !this.writable) {
            let total = 0;
            if (this.polling) {
                total++;
                this.once("pollComplete", function() {
                    --total || pause();
                });
            }
            if (!this.writable) {
                total++;
                this.once("drain", function() {
                    --total || pause();
                });
            }
        } else pause();
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */ poll() {
        this.polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */ onData(data) {
        const callback = (packet)=>{
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") this.onOpen();
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({
                    description: "transport closed by the server"
                });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0, _engineIoParser.decodePayload)(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this.polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) this.poll();
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */ doClose() {
        const close = ()=>{
            this.write([
                {
                    type: "close"
                }
            ]);
        };
        if ("open" === this.readyState) close();
        else // in case we're trying to close while
        // handshaking is in progress (GH-164)
        this.once("open", close);
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */ write(packets) {
        this.writable = false;
        (0, _engineIoParser.encodePayload)(packets, (data)=>{
            this.doWrite(data, ()=>{
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */ uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) query[this.opts.timestampParam] = (0, _yeastJs.yeast)();
        if (!this.supportsBinary && !query.sid) query.b64 = 1;
        return this.createUri(schema, query);
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @private
     */ request(opts = {}) {
        Object.assign(opts, {
            xd: this.xd,
            cookieJar: this.cookieJar
        }, this.opts);
        return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */ doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context)=>{
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */ doPoll() {
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context)=>{
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
class Request extends (0, _componentEmitter.Emitter) {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */ constructor(uri, opts){
        super();
        (0, _utilJs.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.data = undefined !== opts.data ? opts.data : null;
        this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */ create() {
        var _a;
        const opts = (0, _utilJs.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        const xhr = this.xhr = new (0, _xmlhttprequestJs.XHR)(opts);
        try {
            xhr.open(this.method, this.uri, true);
            try {
                if (this.opts.extraHeaders) {
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for(let i in this.opts.extraHeaders)if (this.opts.extraHeaders.hasOwnProperty(i)) xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                }
            } catch (e) {}
            if ("POST" === this.method) try {
                xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e) {}
            try {
                xhr.setRequestHeader("Accept", "*/*");
            } catch (e) {}
            (_a = this.opts.cookieJar) === null || _a === void 0 || _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) xhr.withCredentials = this.opts.withCredentials;
            if (this.opts.requestTimeout) xhr.timeout = this.opts.requestTimeout;
            xhr.onreadystatechange = ()=>{
                var _a;
                if (xhr.readyState === 3) (_a = this.opts.cookieJar) === null || _a === void 0 || _a.parseCookies(xhr);
                if (4 !== xhr.readyState) return;
                if (200 === xhr.status || 1223 === xhr.status) this.onLoad();
                else // make sure the `error` event handler that's user-set
                // does not throw in the same tick and gets caught here
                this.setTimeoutFn(()=>{
                    this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                }, 0);
            };
            xhr.send(this.data);
        } catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(()=>{
                this.onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */ onError(err) {
        this.emitReserved("error", err, this.xhr);
        this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */ cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) return;
        this.xhr.onreadystatechange = empty;
        if (fromError) try {
            this.xhr.abort();
        } catch (e) {}
        if (typeof document !== "undefined") delete Request.requests[this.index];
        this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */ onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this.cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */ abort() {
        this.cleanup();
    }
}
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */ if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") // @ts-ignore
    attachEvent("onunload", unloadHandler);
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThis ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for(let i in Request.requests)if (Request.requests.hasOwnProperty(i)) Request.requests[i].abort();
}

},{"../transport.js":"kwKKC","../contrib/yeast.js":"5cPiI","engine.io-parser":"2SHiP","./xmlhttprequest.js":"gG0MI","@socket.io/component-emitter":"dzQbR","../util.js":"d7eyH","../globalThis.js":"7zbHc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kwKKC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TransportError", ()=>TransportError);
parcelHelpers.export(exports, "Transport", ()=>Transport);
var _engineIoParser = require("engine.io-parser");
var _componentEmitter = require("@socket.io/component-emitter");
var _utilJs = require("./util.js");
var _parseqsJs = require("./contrib/parseqs.js");
class TransportError extends Error {
    constructor(reason, description, context){
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
class Transport extends (0, _componentEmitter.Emitter) {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */ constructor(opts){
        super();
        this.writable = false;
        (0, _utilJs.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */ onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */ open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */ close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */ send(packets) {
        if (this.readyState === "open") this.write(packets);
    }
    /**
     * Called upon open
     *
     * @protected
     */ onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */ onData(data) {
        const packet = (0, _engineIoParser.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */ onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */ onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */ pause(onPause) {}
    createUri(schema, query = {}) {
        return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) return ":" + this.opts.port;
        else return "";
    }
    _query(query) {
        const encodedQuery = (0, _parseqsJs.encode)(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}

},{"engine.io-parser":"2SHiP","@socket.io/component-emitter":"dzQbR","./util.js":"d7eyH","./contrib/parseqs.js":"aFNEN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2SHiP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPacketEncoderStream", ()=>createPacketEncoderStream);
parcelHelpers.export(exports, "createPacketDecoderStream", ()=>createPacketDecoderStream);
parcelHelpers.export(exports, "protocol", ()=>protocol);
parcelHelpers.export(exports, "encodePacket", ()=>(0, _encodePacketJs.encodePacket));
parcelHelpers.export(exports, "encodePayload", ()=>encodePayload);
parcelHelpers.export(exports, "decodePacket", ()=>(0, _decodePacketJs.decodePacket));
parcelHelpers.export(exports, "decodePayload", ()=>decodePayload);
var _encodePacketJs = require("./encodePacket.js");
var _decodePacketJs = require("./decodePacket.js");
var _commonsJs = require("./commons.js");
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback)=>{
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i)=>{
        // force base64 encoding for binary packets
        (0, _encodePacketJs.encodePacket)(packet, false, (encodedPacket)=>{
            encodedPackets[i] = encodedPacket;
            if (++count === length) callback(encodedPackets.join(SEPARATOR));
        });
    });
};
const decodePayload = (encodedPayload, binaryType)=>{
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for(let i = 0; i < encodedPackets.length; i++){
        const decodedPacket = (0, _decodePacketJs.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") break;
    }
    return packets;
};
function createPacketEncoderStream() {
    return new TransformStream({
        transform (packet, controller) {
            (0, _encodePacketJs.encodePacketToBinary)(packet, (encodedPacket)=>{
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                } else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                } else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") header[0] |= 0x80;
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        }
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk)=>acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) return chunks.shift();
    const buffer = new Uint8Array(size);
    let j = 0;
    for(let i = 0; i < size; i++){
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) chunks[0] = chunks[0].slice(j);
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) TEXT_DECODER = new TextDecoder();
    const chunks = [];
    let state = 0 /* READ_HEADER */ ;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform (chunk, controller) {
            chunks.push(chunk);
            while(true){
                if (state === 0 /* READ_HEADER */ ) {
                    if (totalLength(chunks) < 1) break;
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) state = 3 /* READ_PAYLOAD */ ;
                    else if (expectedLength === 126) state = 1 /* READ_EXTENDED_LENGTH_16 */ ;
                    else state = 2 /* READ_EXTENDED_LENGTH_64 */ ;
                } else if (state === 1 /* READ_EXTENDED_LENGTH_16 */ ) {
                    if (totalLength(chunks) < 2) break;
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* READ_PAYLOAD */ ;
                } else if (state === 2 /* READ_EXTENDED_LENGTH_64 */ ) {
                    if (totalLength(chunks) < 8) break;
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 21) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue((0, _commonsJs.ERROR_PACKET));
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* READ_PAYLOAD */ ;
                } else {
                    if (totalLength(chunks) < expectedLength) break;
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0, _decodePacketJs.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* READ_HEADER */ ;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue((0, _commonsJs.ERROR_PACKET));
                    break;
                }
            }
        }
    });
}
const protocol = 4;

},{"./encodePacket.js":"lUiyb","./decodePacket.js":"k0BCP","./commons.js":"kLmJ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUiyb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodePacketToBinary", ()=>encodePacketToBinary);
parcelHelpers.export(exports, "encodePacket", ()=>encodePacket);
var _commonsJs = require("./commons.js");
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = (obj)=>{
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback)=>{
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) return callback(data);
        else return encodeBlobAsBase64(data, callback);
    } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) return callback(data);
        else return encodeBlobAsBase64(new Blob([
            data
        ]), callback);
    }
    // plain string
    return callback((0, _commonsJs.PACKET_TYPES)[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback)=>{
    const fileReader = new FileReader();
    fileReader.onload = function() {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
function toArray(data) {
    if (data instanceof Uint8Array) return data;
    else if (data instanceof ArrayBuffer) return new Uint8Array(data);
    else return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) return packet.data.arrayBuffer().then(toArray).then(callback);
    else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) return callback(toArray(packet.data));
    encodePacket(packet, false, (encoded)=>{
        if (!TEXT_ENCODER) TEXT_ENCODER = new TextEncoder();
        callback(TEXT_ENCODER.encode(encoded));
    });
}

},{"./commons.js":"kLmJ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kLmJ7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PACKET_TYPES", ()=>PACKET_TYPES);
parcelHelpers.export(exports, "PACKET_TYPES_REVERSE", ()=>PACKET_TYPES_REVERSE);
parcelHelpers.export(exports, "ERROR_PACKET", ()=>ERROR_PACKET);
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key)=>{
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = {
    type: "error",
    data: "parser error"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k0BCP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodePacket", ()=>decodePacket);
var _commonsJs = require("./commons.js");
var _base64ArraybufferJs = require("./contrib/base64-arraybuffer.js");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType)=>{
    if (typeof encodedPacket !== "string") return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
    };
    const type = encodedPacket.charAt(0);
    if (type === "b") return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
    const packetType = (0, _commonsJs.PACKET_TYPES_REVERSE)[type];
    if (!packetType) return 0, _commonsJs.ERROR_PACKET;
    return encodedPacket.length > 1 ? {
        type: (0, _commonsJs.PACKET_TYPES_REVERSE)[type],
        data: encodedPacket.substring(1)
    } : {
        type: (0, _commonsJs.PACKET_TYPES_REVERSE)[type]
    };
};
const decodeBase64Packet = (data, binaryType)=>{
    if (withNativeArrayBuffer) {
        const decoded = (0, _base64ArraybufferJs.decode)(data);
        return mapBinary(decoded, binaryType);
    } else return {
        base64: true,
        data
    }; // fallback for old browsers
};
const mapBinary = (data, binaryType)=>{
    switch(binaryType){
        case "blob":
            if (data instanceof Blob) // from WebSocket + binaryType "blob"
            return data;
            else // from HTTP long-polling or WebTransport
            return new Blob([
                data
            ]);
        case "arraybuffer":
        default:
            if (data instanceof ArrayBuffer) // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
            return data;
            else // from WebTransport (Uint8Array)
            return data.buffer;
    }
};

},{"./commons.js":"kLmJ7","./contrib/base64-arraybuffer.js":"c3dDo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c3dDo":[function(require,module,exports) {
// imported from https://github.com/socketio/base64-arraybuffer
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for(let i = 0; i < chars.length; i++)lookup[chars.charCodeAt(i)] = i;
const encode = (arraybuffer)=>{
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
    for(i = 0; i < len; i += 3){
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) base64 = base64.substring(0, base64.length - 1) + "=";
    else if (len % 3 === 1) base64 = base64.substring(0, base64.length - 2) + "==";
    return base64;
};
const decode = (base64)=>{
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") bufferLength--;
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for(i = 0; i < len; i += 4){
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dzQbR":[function(require,module,exports) {
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Emitter", ()=>Emitter);
function Emitter(obj) {
    if (obj) return mixin(obj);
}
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */ function mixin(obj) {
    for(var key in Emitter.prototype)obj[key] = Emitter.prototype[key];
    return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */ Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */ Emitter.prototype.once = function(event, fn) {
    function on() {
        this.off(event, on);
        fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */ Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    // all
    if (0 == arguments.length) {
        this._callbacks = {};
        return this;
    }
    // specific event
    var callbacks = this._callbacks["$" + event];
    if (!callbacks) return this;
    // remove all handlers
    if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
    }
    // remove specific handler
    var cb;
    for(var i = 0; i < callbacks.length; i++){
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
        }
    }
    // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.
    if (callbacks.length === 0) delete this._callbacks["$" + event];
    return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */ Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    if (callbacks) {
        callbacks = callbacks.slice(0);
        for(var i = 0, len = callbacks.length; i < len; ++i)callbacks[i].apply(this, args);
    }
    return this;
};
// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */ Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */ Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7eyH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "installTimerFunctions", ()=>installTimerFunctions);
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
parcelHelpers.export(exports, "byteLength", ()=>byteLength);
var _globalThisJs = require("./globalThis.js");
function pick(obj, ...attr) {
    return attr.reduce((acc, k)=>{
        if (obj.hasOwnProperty(k)) acc[k] = obj[k];
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = globalThis.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThis.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);
    } else {
        obj.setTimeoutFn = globalThis.setTimeout.bind(globalThis);
        obj.clearTimeoutFn = globalThis.clearTimeout.bind(globalThis);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
    if (typeof obj === "string") return utf8Length(obj);
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for(let i = 0, l = str.length; i < l; i++){
        c = str.charCodeAt(i);
        if (c < 0x80) length += 1;
        else if (c < 0x800) length += 2;
        else if (c < 0xd800 || c >= 0xe000) length += 3;
        else {
            i++;
            length += 4;
        }
    }
    return length;
}

},{"./globalThis.js":"7zbHc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7zbHc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "globalThisShim", ()=>globalThisShim);
const globalThisShim = (()=>{
    if (typeof self !== "undefined") return self;
    else if (typeof window !== "undefined") return window;
    else return Function("return this")();
})();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFNEN":[function(require,module,exports) {
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */ parcelHelpers.export(exports, "decode", ()=>decode);
function encode(obj) {
    let str = "";
    for(let i in obj)if (obj.hasOwnProperty(i)) {
        if (str.length) str += "&";
        str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
    return str;
}
function decode(qs) {
    let qry = {};
    let pairs = qs.split("&");
    for(let i = 0, l = pairs.length; i < l; i++){
        let pair = pairs[i].split("=");
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cPiI":[function(require,module,exports) {
// imported from https://github.com/unshiftio/yeast
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */ parcelHelpers.export(exports, "encode", ()=>encode);
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */ parcelHelpers.export(exports, "decode", ()=>decode);
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */ parcelHelpers.export(exports, "yeast", ()=>yeast);
"use strict";
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i = 0, prev;
function encode(num) {
    let encoded = "";
    do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
    }while (num > 0);
    return encoded;
}
function decode(str) {
    let decoded = 0;
    for(i = 0; i < str.length; i++)decoded = decoded * length + map[str.charAt(i)];
    return decoded;
}
function yeast() {
    const now = encode(+new Date());
    if (now !== prev) return seed = 0, prev = now;
    return now + "." + encode(seed++);
}
//
// Map each character to its index.
//
for(; i < length; i++)map[alphabet[i]] = i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gG0MI":[function(require,module,exports) {
// browser shim for xmlhttprequest module
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XHR", ()=>XHR);
parcelHelpers.export(exports, "createCookieJar", ()=>createCookieJar);
var _hasCorsJs = require("../contrib/has-cors.js");
var _globalThisJs = require("../globalThis.js");
function XHR(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || (0, _hasCorsJs.hasCORS))) return new XMLHttpRequest();
    } catch (e) {}
    if (!xdomain) try {
        return new globalThis[[
            "Active"
        ].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {}
}
function createCookieJar() {}

},{"../contrib/has-cors.js":"kPgMI","../globalThis.js":"7zbHc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPgMI":[function(require,module,exports) {
// imported from https://github.com/component/has-cors
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasCORS", ()=>hasCORS);
let value = false;
try {
    value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
// if XMLHttp support is disabled in IE then it will throw
// when trying to create
}
const hasCORS = value;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8y2e2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WS", ()=>WS);
var _transportJs = require("../transport.js");
var _yeastJs = require("../contrib/yeast.js");
var _utilJs = require("../util.js");
var _websocketConstructorJs = require("./websocket-constructor.js");
var _engineIoParser = require("engine.io-parser");
var Buffer = require("64d8415e9cf90979").Buffer;
// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends (0, _transportJs.Transport) {
    /**
     * WebSocket transport constructor.
     *
     * @param {Object} opts - connection options
     * @protected
     */ constructor(opts){
        super(opts);
        this.supportsBinary = !opts.forceBase64;
    }
    get name() {
        return "websocket";
    }
    doOpen() {
        if (!this.check()) // let probe timeout
        return;
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative ? {} : (0, _utilJs.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) opts.headers = this.opts.extraHeaders;
        try {
            this.ws = (0, _websocketConstructorJs.usingBrowserWebSocket) && !isReactNative ? protocols ? new (0, _websocketConstructorJs.WebSocket)(uri, protocols) : new (0, _websocketConstructorJs.WebSocket)(uri) : new (0, _websocketConstructorJs.WebSocket)(uri, protocols, opts);
        } catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */ addEventListeners() {
        this.ws.onopen = ()=>{
            if (this.opts.autoUnref) this.ws._socket.unref();
            this.onOpen();
        };
        this.ws.onclose = (closeEvent)=>this.onClose({
                description: "websocket connection closed",
                context: closeEvent
            });
        this.ws.onmessage = (ev)=>this.onData(ev.data);
        this.ws.onerror = (e)=>this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for(let i = 0; i < packets.length; i++){
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0, _engineIoParser.encodePacket)(packet, this.supportsBinary, (data)=>{
                // always create a new object (GH-437)
                const opts = {};
                if (!(0, _websocketConstructorJs.usingBrowserWebSocket)) {
                    if (packet.options) opts.compress = packet.options.compress;
                    if (this.opts.perMessageDeflate) {
                        const len = // @ts-ignore
                        "string" === typeof data ? Buffer.byteLength(data) : data.length;
                        if (len < this.opts.perMessageDeflate.threshold) opts.compress = false;
                    }
                }
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    if (0, _websocketConstructorJs.usingBrowserWebSocket) // TypeError is thrown when passing the second argument on Safari
                    this.ws.send(data);
                    else this.ws.send(data, opts);
                } catch (e) {}
                if (lastPacket) // fake drain
                // defer to next tick to allow Socket to clear writeBuffer
                (0, _websocketConstructorJs.nextTick)(()=>{
                    this.writable = true;
                    this.emitReserved("drain");
                }, this.setTimeoutFn);
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */ uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) query[this.opts.timestampParam] = (0, _yeastJs.yeast)();
        // communicate binary support capabilities
        if (!this.supportsBinary) query.b64 = 1;
        return this.createUri(schema, query);
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @private
     */ check() {
        return !!(0, _websocketConstructorJs.WebSocket);
    }
}

},{"64d8415e9cf90979":"fCgem","../transport.js":"kwKKC","../contrib/yeast.js":"5cPiI","../util.js":"d7eyH","./websocket-constructor.js":"dDJnh","engine.io-parser":"2SHiP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dDJnh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
parcelHelpers.export(exports, "WebSocket", ()=>WebSocket);
parcelHelpers.export(exports, "usingBrowserWebSocket", ()=>usingBrowserWebSocket);
parcelHelpers.export(exports, "defaultBinaryType", ()=>defaultBinaryType);
var _globalThisJs = require("../globalThis.js");
const nextTick = (()=>{
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) return (cb)=>Promise.resolve().then(cb);
    else return (cb, setTimeoutFn)=>setTimeoutFn(cb, 0);
})();
const WebSocket = globalThis.WebSocket || globalThis.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";

},{"../globalThis.js":"7zbHc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k7fng":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WT", ()=>WT);
var _transportJs = require("../transport.js");
var _websocketConstructorJs = require("./websocket-constructor.js");
var _engineIoParser = require("engine.io-parser");
class WT extends (0, _transportJs.Transport) {
    get name() {
        return "webtransport";
    }
    doOpen() {
        // @ts-ignore
        if (typeof WebTransport !== "function") return;
        // @ts-ignore
        this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        this.transport.closed.then(()=>{
            this.onClose();
        }).catch((err)=>{
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this.transport.ready.then(()=>{
            this.transport.createBidirectionalStream().then((stream)=>{
                const decoderStream = (0, _engineIoParser.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = (0, _engineIoParser.createPacketEncoderStream)();
                encoderStream.readable.pipeTo(stream.writable);
                this.writer = encoderStream.writable.getWriter();
                const read = ()=>{
                    reader.read().then(({ done, value })=>{
                        if (done) return;
                        this.onPacket(value);
                        read();
                    }).catch((err)=>{});
                };
                read();
                const packet = {
                    type: "open"
                };
                if (this.query.sid) packet.data = `{"sid":"${this.query.sid}"}`;
                this.writer.write(packet).then(()=>this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for(let i = 0; i < packets.length; i++){
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this.writer.write(packet).then(()=>{
                if (lastPacket) (0, _websocketConstructorJs.nextTick)(()=>{
                    this.writable = true;
                    this.emitReserved("drain");
                }, this.setTimeoutFn);
            });
        }
    }
    doClose() {
        var _a;
        (_a = this.transport) === null || _a === void 0 || _a.close();
    }
}

},{"../transport.js":"kwKKC","./websocket-constructor.js":"dDJnh","engine.io-parser":"2SHiP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5RFyz":[function(require,module,exports) {
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parse", ()=>parse);
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor"
];
function parse(str) {
    if (str.length > 2000) throw "URI too long";
    const src = str, b = str.indexOf("["), e = str.indexOf("]");
    if (b != -1 && e != -1) str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
    let m = re.exec(str || ""), uri = {}, i = 14;
    while(i--)uri[parts[i]] = m[i] || "";
    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
        uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
        uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri["path"]);
    uri.queryKey = queryKey(uri, uri["query"]);
    return uri;
}
function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == "/" || path.length === 0) names.splice(0, 1);
    if (path.slice(-1) == "/") names.splice(names.length - 1, 1);
    return names;
}
function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
        if ($1) data[$1] = $2;
    });
    return data;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"94vh9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Manager", ()=>Manager);
var _engineIoClient = require("engine.io-client");
var _socketJs = require("./socket.js");
var _socketIoParser = require("socket.io-parser");
var _onJs = require("./on.js");
var _backo2Js = require("./contrib/backo2.js");
var _componentEmitter = require("@socket.io/component-emitter");
class Manager extends (0, _componentEmitter.Emitter) {
    constructor(uri, opts){
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        (0, _engineIoClient.installTimerFunctions)(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new (0, _backo2Js.Backoff)({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || _socketIoParser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect) this.open();
    }
    reconnection(v) {
        if (!arguments.length) return this._reconnection;
        this._reconnection = !!v;
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined) return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined) return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 || _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined) return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 || _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined) return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 || _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length) return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */ maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */ open(fn) {
        if (~this._readyState.indexOf("open")) return this;
        this.engine = new (0, _engineIoClient.Socket)(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = (0, _onJs.on)(socket, "open", function() {
            self.onopen();
            fn && fn();
        });
        const onError = (err)=>{
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) fn(err);
            else // Only do this if there is no fn to handle the error
            this.maybeReconnectOnOpen();
        };
        // emit `error`
        const errorSub = (0, _onJs.on)(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            // set timer
            const timer = this.setTimeoutFn(()=>{
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) timer.unref();
            this.subs.push(()=>{
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */ connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */ onopen() {
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push((0, _onJs.on)(socket, "ping", this.onping.bind(this)), (0, _onJs.on)(socket, "data", this.ondata.bind(this)), (0, _onJs.on)(socket, "error", this.onerror.bind(this)), (0, _onJs.on)(socket, "close", this.onclose.bind(this)), (0, _onJs.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */ onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */ ondata(data) {
        try {
            this.decoder.add(data);
        } catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */ ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        (0, _engineIoClient.nextTick)(()=>{
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */ onerror(err) {
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */ socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new (0, _socketJs.Socket)(this, nsp, opts);
            this.nsps[nsp] = socket;
        } else if (this._autoConnect && !socket.active) socket.connect();
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */ _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps){
            const socket = this.nsps[nsp];
            if (socket.active) return;
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */ _packet(packet) {
        const encodedPackets = this.encoder.encode(packet);
        for(let i = 0; i < encodedPackets.length; i++)this.engine.write(encodedPackets[i], packet.options);
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */ cleanup() {
        this.subs.forEach((subDestroy)=>subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */ _close() {
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine) this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */ disconnect() {
        return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */ onclose(reason, description) {
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) this.reconnect();
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */ reconnect() {
        if (this._reconnecting || this.skipReconnect) return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        } else {
            const delay = this.backoff.duration();
            this._reconnecting = true;
            const timer = this.setTimeoutFn(()=>{
                if (self.skipReconnect) return;
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect) return;
                self.open((err)=>{
                    if (err) {
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    } else self.onreconnect();
                });
            }, delay);
            if (this.opts.autoUnref) timer.unref();
            this.subs.push(()=>{
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */ onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}

},{"engine.io-client":"jBHFs","./socket.js":"kbWgu","socket.io-parser":"2lQL3","./on.js":"8FFT1","./contrib/backo2.js":"cZLsm","@socket.io/component-emitter":"dzQbR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kbWgu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */ parcelHelpers.export(exports, "Socket", ()=>Socket);
var _socketIoParser = require("socket.io-parser");
var _onJs = require("./on.js");
var _componentEmitter = require("@socket.io/component-emitter");
/**
 * Internal events.
 * These events can't be emitted by the user.
 */ const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1
});
class Socket extends (0, _componentEmitter.Emitter) {
    /**
     * `Socket` constructor.
     */ constructor(io, nsp, opts){
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */ this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */ this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */ this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */ this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */ this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */ this._queueSeq = 0;
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) this.auth = opts.auth;
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect) this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */ get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */ subEvents() {
        if (this.subs) return;
        const io = this.io;
        this.subs = [
            (0, _onJs.on)(io, "open", this.onopen.bind(this)),
            (0, _onJs.on)(io, "packet", this.onpacket.bind(this)),
            (0, _onJs.on)(io, "error", this.onerror.bind(this)),
            (0, _onJs.on)(io, "close", this.onclose.bind(this))
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */ get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */ connect() {
        if (this.connected) return this;
        this.subEvents();
        if (!this.io["_reconnecting"]) this.io.open(); // ensure open
        if ("open" === this.io._readyState) this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */ open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */ send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */ emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) throw new Error('"' + ev.toString() + '" is a reserved event name');
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: (0, _socketIoParser.PacketType).EVENT,
            data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) ;
        else if (this.connected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        } else this.sendBuffer.push(packet);
        this.flags = {};
        return this;
    }
    /**
     * @private
     */ _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(()=>{
            delete this.acks[id];
            for(let i = 0; i < this.sendBuffer.length; i++)if (this.sendBuffer[i].id === id) this.sendBuffer.splice(i, 1);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks[id] = (...args)=>{
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, [
                null,
                ...args
            ]);
        };
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */ emitWithAck(ev, ...args) {
        // the timeout flag is optional
        const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;
        return new Promise((resolve, reject)=>{
            args.push((arg1, arg2)=>{
                if (withErr) return arg1 ? reject(arg1) : resolve(arg2);
                else return resolve(arg1);
            });
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */ _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") ack = args.pop();
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({
                fromQueue: true
            }, this.flags)
        };
        args.push((err, ...responseArgs)=>{
            if (packet !== this._queue[0]) // the packet has already been acknowledged
            return;
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    this._queue.shift();
                    if (ack) ack(err);
                }
            } else {
                this._queue.shift();
                if (ack) ack(null, ...responseArgs);
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */ _drainQueue(force = false) {
        if (!this.connected || this._queue.length === 0) return;
        const packet = this._queue[0];
        if (packet.pending && !force) return;
        packet.pending = true;
        packet.tryCount++;
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */ packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */ onopen() {
        if (typeof this.auth == "function") this.auth((data)=>{
            this._sendConnectPacket(data);
        });
        else this._sendConnectPacket(this.auth);
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */ _sendConnectPacket(data) {
        this.packet({
            type: (0, _socketIoParser.PacketType).CONNECT,
            data: this._pid ? Object.assign({
                pid: this._pid,
                offset: this._lastOffset
            }, data) : data
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */ onerror(err) {
        if (!this.connected) this.emitReserved("connect_error", err);
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */ onclose(reason, description) {
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */ onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace) return;
        switch(packet.type){
            case (0, _socketIoParser.PacketType).CONNECT:
                if (packet.data && packet.data.sid) this.onconnect(packet.data.sid, packet.data.pid);
                else this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                break;
            case (0, _socketIoParser.PacketType).EVENT:
            case (0, _socketIoParser.PacketType).BINARY_EVENT:
                this.onevent(packet);
                break;
            case (0, _socketIoParser.PacketType).ACK:
            case (0, _socketIoParser.PacketType).BINARY_ACK:
                this.onack(packet);
                break;
            case (0, _socketIoParser.PacketType).DISCONNECT:
                this.ondisconnect();
                break;
            case (0, _socketIoParser.PacketType).CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */ onevent(packet) {
        const args = packet.data || [];
        if (null != packet.id) args.push(this.ack(packet.id));
        if (this.connected) this.emitEvent(args);
        else this.receiveBuffer.push(Object.freeze(args));
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners)listener.apply(this, args);
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") this._lastOffset = args[args.length - 1];
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */ ack(id) {
        const self = this;
        let sent = false;
        return function(...args) {
            // prevent double callbacks
            if (sent) return;
            sent = true;
            self.packet({
                type: (0, _socketIoParser.PacketType).ACK,
                id: id,
                data: args
            });
        };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */ onack(packet) {
        const ack = this.acks[packet.id];
        if ("function" === typeof ack) {
            ack.apply(this, packet.data);
            delete this.acks[packet.id];
        }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */ onconnect(id, pid) {
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */ emitBuffered() {
        this.receiveBuffer.forEach((args)=>this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet)=>{
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */ ondisconnect() {
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */ destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy)=>subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */ disconnect() {
        if (this.connected) this.packet({
            type: (0, _socketIoParser.PacketType).DISCONNECT
        });
        // remove socket from pool
        this.destroy();
        if (this.connected) // fire events
        this.onclose("io client disconnect");
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */ close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */ compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */ get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */ timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */ onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */ prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */ offAny(listener) {
        if (!this._anyListeners) return this;
        if (listener) {
            const listeners = this._anyListeners;
            for(let i = 0; i < listeners.length; i++)if (listener === listeners[i]) {
                listeners.splice(i, 1);
                return this;
            }
        } else this._anyListeners = [];
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */ listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */ onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */ prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */ offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) return this;
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for(let i = 0; i < listeners.length; i++)if (listener === listeners[i]) {
                listeners.splice(i, 1);
                return this;
            }
        } else this._anyOutgoingListeners = [];
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */ listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */ notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners)listener.apply(this, packet.data);
        }
    }
}

},{"socket.io-parser":"2lQL3","./on.js":"8FFT1","@socket.io/component-emitter":"dzQbR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2lQL3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protocol", ()=>protocol);
parcelHelpers.export(exports, "PacketType", ()=>PacketType);
/**
 * A socket.io Encoder instance
 */ parcelHelpers.export(exports, "Encoder", ()=>Encoder);
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */ parcelHelpers.export(exports, "Decoder", ()=>Decoder);
var _componentEmitter = require("@socket.io/component-emitter");
var _binaryJs = require("./binary.js");
var _isBinaryJs = require("./is-binary.js");
/**
 * These strings must not be used as event names, as they have a special meaning.
 */ const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
];
const protocol = 5;
var PacketType;
(function(PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */ constructor(replacer){
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */ encode(obj) {
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if ((0, _isBinaryJs.hasBinary)(obj)) return this.encodeAsBinary({
                type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
                nsp: obj.nsp,
                data: obj.data,
                id: obj.id
            });
        }
        return [
            this.encodeAsString(obj)
        ];
    }
    /**
     * Encode packet as string.
     */ encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) str += obj.attachments + "-";
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) str += obj.nsp + ",";
        // immediately followed by the id
        if (null != obj.id) str += obj.id;
        // json data
        if (null != obj.data) str += JSON.stringify(obj.data, this.replacer);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */ encodeAsBinary(obj) {
        const deconstruction = (0, _binaryJs.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
class Decoder extends (0, _componentEmitter.Emitter) {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */ constructor(reviver){
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */ add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) super.emitReserved("decoded", packet);
            } else // non-binary full packet
            super.emitReserved("decoded", packet);
        } else if ((0, _isBinaryJs.isBinary)(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        } else throw new Error("Unknown type: " + obj);
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */ decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === undefined) throw new Error("unknown packet type " + p.type);
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while(str.charAt(++i) !== "-" && i != str.length);
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") throw new Error("Illegal attachments");
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while(++i){
                const c = str.charAt(i);
                if ("," === c) break;
                if (i === str.length) break;
            }
            p.nsp = str.substring(start, i);
        } else p.nsp = "/";
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while(++i){
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length) break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) p.data = payload;
            else throw new Error("invalid payload");
        }
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        } catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch(type){
            case PacketType.CONNECT:
                return isObject(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */ destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */ class BinaryReconstructor {
    constructor(packet){
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */ takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = (0, _binaryJs.reconstructPacket)(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */ finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}

},{"@socket.io/component-emitter":"dzQbR","./binary.js":"juaze","./is-binary.js":"0mMso","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"juaze":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */ parcelHelpers.export(exports, "deconstructPacket", ()=>deconstructPacket);
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */ parcelHelpers.export(exports, "reconstructPacket", ()=>reconstructPacket);
var _isBinaryJs = require("./is-binary.js");
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return {
        packet: pack,
        buffers: buffers
    };
}
function _deconstructPacket(data, buffers) {
    if (!data) return data;
    if ((0, _isBinaryJs.isBinary)(data)) {
        const placeholder = {
            _placeholder: true,
            num: buffers.length
        };
        buffers.push(data);
        return placeholder;
    } else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for(let i = 0; i < data.length; i++)newData[i] = _deconstructPacket(data[i], buffers);
        return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for(const key in data)if (Object.prototype.hasOwnProperty.call(data, key)) newData[key] = _deconstructPacket(data[key], buffers);
        return newData;
    }
    return data;
}
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
function _reconstructPacket(data, buffers) {
    if (!data) return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
        if (isIndexValid) return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        else throw new Error("illegal attachments");
    } else if (Array.isArray(data)) for(let i = 0; i < data.length; i++)data[i] = _reconstructPacket(data[i], buffers);
    else if (typeof data === "object") {
        for(const key in data)if (Object.prototype.hasOwnProperty.call(data, key)) data[key] = _reconstructPacket(data[key], buffers);
    }
    return data;
}

},{"./is-binary.js":"0mMso","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"0mMso":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */ parcelHelpers.export(exports, "isBinary", ()=>isBinary);
parcelHelpers.export(exports, "hasBinary", ()=>hasBinary);
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj)=>{
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") return false;
    if (Array.isArray(obj)) {
        for(let i = 0, l = obj.length; i < l; i++){
            if (hasBinary(obj[i])) return true;
        }
        return false;
    }
    if (isBinary(obj)) return true;
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) return hasBinary(obj.toJSON(), true);
    for(const key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) return true;
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8FFT1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "on", ()=>on);
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZLsm":[function(require,module,exports) {
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Backoff", ()=>Backoff);
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */ Backoff.prototype.duration = function() {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */ Backoff.prototype.reset = function() {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */ Backoff.prototype.setMin = function(min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */ Backoff.prototype.setMax = function(max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */ Backoff.prototype.setJitter = function(jitter) {
    this.jitter = jitter;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["wtkGg","1xC6H"], null, "parcelRequire4831")

//# sourceMappingURL=login.0f6ec1b5.js.map
